/**
	© MacMailler, 2012Ч2014.
*/

#include <a_samp>
#include "..\include\main"

#define __GamemodeName__		"GWRP"
#define __GamemodeVersion__		"0.3"
#define __GamemodeCopyright__	"(c)Bangalte & Mendes"

#define __DBPrefix__			""

#define __TableUsers__			__DBPrefix__"users"
#define __TableHouses__			__DBPrefix__"houses"
#define __TableBusines__		__DBPrefix__"busines"
#define __TableStuffs__			__DBPrefix__"stuffs"
#define __TableSpawns__			__DBPrefix__"spawns"
#define __TableBanned__			__DBPrefix__"banned"
#define __TableBlacklist__		__DBPrefix__"blacklist"
#define __TableFracInfo__		__DBPrefix__"frac_info"
#define __TableFracModels__		__DBPrefix__"frac_models"
#define __TableFracVehicles__	__DBPrefix__"frac_vehicles"
#define __TableFracSkins__		__DBPrefix__"frac_skins"
#define __TableGangInfo__		__DBPrefix__"ganginfo"
#define __TableRefills__		__DBPrefix__"busines_refill"
#define __TablePickups__		__DBPrefix__"pickups"
#define __TableVehicles__		__DBPrefix__"vehicles"
#define __TableFracRanks__		__DBPrefix__"frac_ranks"
#define __TableAntidmzones__	__DBPrefix__"antidmzones"
#define __TableExtraVehicles__	__DBPrefix__"extra_vehicles"
#define __TableHouseGarages__	__DBPrefix__"houses_garage"

#define LOG_ANTICHEAT			"anticheat"
#define LOG_ADMINCHAT			"adminchat"
#define LOG_REPORT				"report"
#define LOG_ADMWARN				"admwarn"
#define LOG_PAYDAY_STATS		"debug"
#define LOG_MYSQL_ERROR			"sqlerror"
#define LOG_GOV_CHAT			"gov"
#define LOG_AD_CHAT				"ad"
#define LOG_CHANGENAME			"changename"
#define LOG_HELPER_CHAT			"helperchat"
#define LOG_HOUSE				"houses"
#define LOG_PAY					"pay"

#define __SERVER_NAME_LC		"GreatWorld"
#define __SERVER_NAME_L			"GreatWorld"
#define __SERVER_NAME_C			"GreatWorld"
#define __SERVER_PREFIX			"[RP]"
#define __SERVER_SITE			"http://greatworld-rp.url.ph/"

#define MAX_FC					(300)
#define MAX_GAS 				(100)
#define MAX_FRAC				(19)
#define MAX_JOBS				(12)
#define MAX_RANK				(23)
#define MAX_HWEAP				(6)
#define MAX_SPAWNS				(5)
#define MAX_BIZNES				(128)
#define MAX_HOUSES				(1024)
#define MAX_PORTALS				(200)
#define MAX_AFK_TIME 			(600)
#define MAX_ZONE_SIZE			(60.0)
#define MAX_COMPONENT 			(14)
#define MAX_VEHICLESex			(200)
#define MAX_ANTIDM_ZONES		(50)
#define MAX_FRAC_GATE			(50)
#define MAX_REFILLS				(100)

#define START_MONEY				(5000)
#define START_LEVEL				(1)

#define T_DIST 					(15.0)
#define AFK_TEXT_SET 			(2)
#define FC_DEF_NUMBER			"NONE"

#define CHECKPOINT_NONE			(0)
#define CHECKPOINT_HOME 		(12)

#define JAILED_MAN 				(268)
#define JAILED_WOMEN 			(69)

#define INVALID_BIZ_ID			(0xFFFF)
#define INVALID_HOUSE_ID		(0xFFFF)

#define OFFSET_HOUSE			(INVALID_HOUSE_ID)
#define OFFSET_BIZZ				(INVALID_HOUSE_ID + MAX_HOUSES)

#define Bizz_PaintBall			(40)
#define Bizz_EstateAgency		(38)
#define Bizz_Church				(64)
#define Bizz_PowerHouse			(34)
#define Bizz_TelephoneCompany	(35)
#define Bizz_Lottery			(31)
#define Bizz_HouseService		(32)
#define Bizz_RifaSklad			(37)
#define Bizz_GarageLS			(66)
#define Bizz_GarageSF 			(68)
#define Bizz_GarageLV			(67)
#define Bizz_AutoSolonClassA	(39)
#define Bizz_AutoSolonClassB	(36)
#define Bizz_AutoSolonClassC	(51)
#define Bizz_AutoSolonClassD	(69)
#define Bizz_ProdSkladLS		(58)
#define Bizz_ProdSkladSF		(44)

#define TelephonePrice			500
#define ScrathCardPrice			10000
#define PhoneBookPrice			5000
#define DicePrice				500
#define CarKeyPrice				5000
#define CandomPrice 			50
#define CDPlayerPrice 			2500
#define GPSPrice 				70000

#define JOB_NONE 				(0)
#define JOB_DETECTIVE 			(1)
#define JOB_LAWYER 				(2)
#define JOB_WHORE 				(3)
#define JOB_DRUGDEALER			(4)
#define JOB_THEFTAUTO 			(5)
#define JOB_MECHANIC 			(6)
#define JOB_GUNDEALER 			(7)
#define JOB_AUTODEALER 			(8)
#define JOB_BUSMAN 				(9)
#define JOB_TRUCKER 			(10)

#define TEAM_CIV				(0)
#define TEAM_COP				(1)
#define TEAM_FBI				(2)
#define TEAM_ARMY				(3)
#define TEAM_MEDIC				(4)
#define TEAM_LCN				(5)
#define TEAM_YAKUZA				(6)
#define TEAM_GOV				(7)
#define TEAM_FARMERS			(8)
#define TEAM_PRESS				(9)
#define TEAM_TAXI				(10)
#define TEAM_LICENZERS			(11)
#define TEAM_STREETDOGS			(12)
#define TEAM_RUSSIAN			(13)
#define TEAM_GROVE				(14)
#define TEAM_CORONOS			(15)
#define TEAM_BALLAS				(16)
#define TEAM_RIFA				(17)
#define TEAM_VAGOS				(18)

#define D_NONE 					(10)
#define D_ATM			 		(500)
#define D_JOB			 		(600)
#define D_REF			 		(700)
#define D_WAIT					(800)
#define D_MENU					(900)
#define D_GIFT					(1000)
#define D_GGUN					(1100)
#define D_BARN					(1200)
#define D_EDIT					(1300)
#define D_GOTO					(1400)
#define D_HELP					(1500)
#define D_BANK					(1600)
#define D_AUTH 					(1700)
#define D_REGG 					(1800)
#define D_MASK					(1900)
#define D_FBANK					(2000)
#define D_RADIO					(2100)
#define D_BMENU					(2200)
#define D_HMENU					(2300)
#define D_CRANK					(2400)
#define D_REFILL 				(2600)
#define D_EN_BIZ				(2700)
#define D_EX_BIZ				(2800)
#define D_ARMOUR				(3000)
#define D_ONLINE 				(3100)
#define D_HEALME 				(3200)
#define D_TUNING				(3400)
#define D_OFFLINE 				(3500)
#define D_NETSTAT				(3600)
#define D_SETSTAT				(3700)
#define D_GOCLEAN				(3800)
#define D_RENTCAR				(3900)
#define D_BANLIST				(4000)
#define D_WEATHER				(4100)
#define D_PDDTEST				(4300)
#define D_PORTABLE				(4400)
#define D_EN_HOUSE 				(4500)
#define D_EX_HOUSE 				(4600)
#define D_GIVE_PASS 			(4700)
#define D_FIGHTSTYLE 			(4800)
#define D_CHANGE_PASS 			(4900)
#define D_FACTORY_JOB			(5000)
#define TP_EDIT					(5100)
#define D_LMENU					(5200)
#define D_ADD_FC				(5300)
#define D_DEL_FC				(5400)
#define D_ADD_MODEL				(5500)
#define D_SHOW_MODEL			(5600)
#define D_EDIT_MODEL			(5700)
#define D_DONATE				(5800)
#define D_FARE					(5900)
#define D_SKILL					(6000)
#define D_SPAWN					(6100)
#define D_SERVICE				(6200)
#define D_LOGIN					(6300)
#define D_EV_MENU				(6400)

#define FIND_ICON				(0)
#define ZAHVAT_ICON				(1)

#define REFUEL_TIME				(10000)
#define NUMBER_OF_TRUCKS		(8)

#define	MODER1LVL				(1)
#define MODER2LVL				(2)
#define MODER3LVL				(4)
#define SUPERMODER				(3)
#define ADMINISTRATOR			(5)

#define ADV_TIME				(600)
#define SEC_TIMER				(900)
#define GAINS_TIME				(900)

#define Fc::					FC_
#define Td::					TextDraw
#define Pt:: 					PlayerTextDraw
#define Pl::					PL_
#define Bl::					BL_
#define Gm::					GM_
#define Gz::					GangZone
#define Db::					mysql_
#define Iter::					Iter_
#define Portal::				TP_
#define PickupHndlr::			PH_

#define Mnu::					MNU_
#define T3d::					T3D_
#define Obj::					OBJ_
#define Veh::					VEH_
#define Pup::					PUP_
#define Area::					AREA_

#define GetIndexFromBizID(%0)	interpolationSearch2D(BizzInfo,%0,bID,Iter::Count(Biznes))
#define IsPlayerLeader(%0)		Pl::Info[%0][pLeader]
#define IsValidFrac(%0)			(1 <= %0 <= MAX_FRAC)

#define EXP(%0)					((Pl::Info[%0][pLevel]+1) * levelexp)
#define costlvl(%0)				((Pl::Info[%0][pLevel]+1) * levelcost)
#define PERCENT(%0,%1)			((%0 * %1) / 100)
#define rndNum(%0,%1) 			(%0 + random(%1))
#define PL_FracID(%0)			(Pl::Info[%0][pMember] | Pl::Info[%0][pLeader])
#define rgb<%0>					(%0>>>8)
#define GetJailedSkin(%0) 		((Pl::Info[%0][pSex]==2)?(JAILED_WOMEN):(JAILED_MAN))

#define IsACop(%0) 				(TEAM_COP<=Pl::FracID(%0)<=TEAM_ARMY)
#define IsALicenzer(%0) 		(Pl::FracID(%0)==TEAM_LICENZERS)
#define IsPHelper(%0,%1)		(Pl::Info[%0][pHelper]>=%1)
#define IsAHelperDuty(%0) 		(HelperDuty[%0])
#define IsPMuted(%0) 			(Pl::Info[%0][pMuted]==1)

#define IsAMehCar(%0)			(isJobVehicle(JOB_MECHANIC,%0))
#define IsABusCar(%0)			(isJobVehicle(JOB_BUSMAN,%0))
#define IsATruckCar(%0)			(isJobVehicle(JOB_TRUCKER,%0))
#define IsANews(%0)				(isTeamVehicle(TEAM_PRESS,%0))
#define IsATaxiCar(%0)			(isTeamVehicle(TEAM_TAXI,%0))
#define IsAnAmbulance(%0)		(isTeamVehicle(TEAM_MEDIC,%0))
#define IsATruckrifa(%0)		(isTeamVehicle(TEAM_RIFA,%0))
#define IsACopCar(%0)			(TEAM_COP <= Fc::FracID(%0) <= TEAM_ARMY)
#define IsACompTruck(%0)		(comptruck[0] <= %0 <= comptruck[1])

#define AddObject				CreateDynamicObject
#define Add3DText				CreateDynamic3DTextLabel

#define _GREY_ARROW				"{888888}ї {ffffff}"

#define INFINITY 				0x7F800000
#define COLOR_RED1 0xf9b0b0FF


// MySQL handle
enum Db::e_Conf {
	Db::Host[128],
	Db::User[64],
	Db::Base[64],
	Db::Pass[64],
	Db::Charset[16],
	Db::Debug,
}
//—истема рыбалки
new fishkg[MAX_PLAYERS][6];
new sFlood[MAX_PLAYERS];
new Flood[MAX_PLAYERS];
new fishes[MAX_PLAYERS];
new strfish[MAX_PLAYERS][6][128];
new FishNamesNumber = 22;
new FishNames[22][20] =
{
	{"белого амура"},
	{"горбуша"},
	{"густера"},
	{"елеца"},
	{"леща"},
	{"лосос€"},
	{"сома"},
	{"судака"},
	{"угор€"},
	{"хариуса"},
	{"ботинок"},
	{"щуку"},
	{"€зь"},
	{"сазана"},
	{"тунца"},
	{"ель"},
	{"дельфина"},
	{"акулу"},
	{"морскую черепаху"},
	{"форель"},
	{"медузу"},
	{"рыбу-меч"}
};
enum pFishing
{
	pFish1[20]
};
new Fishes[MAX_PLAYERS][pFishing];
stock IsABoat(carid){switch(GetVehicleModel(carid)){case 472,473,493,595,484,430,452..454,446:return true;}return false;}
stock IsAtFishPlace(playerid)
{
	if(IsPlayerConnected(playerid))
	{
		if(PlayerToPoint(1.0,playerid,403.8266,-2088.7598,7.8359) || PlayerToPoint(1.0,playerid,398.7553,-2088.7490,7.8359)) return true;
		else if(PlayerToPoint(1.0,playerid,396.2197,-2088.6692,7.8359) || PlayerToPoint(1.0,playerid,391.1094,-2088.7976,7.8359)) return true;
		else if(PlayerToPoint(1.0,playerid,383.4157,-2088.7849,7.8359) || PlayerToPoint(1.0,playerid,374.9598,-2088.7979,7.8359)) return true;
		else if(PlayerToPoint(1.0,playerid,369.8107,-2088.7927,7.8359) || PlayerToPoint(1.0,playerid,367.3637,-2088.7925,7.8359)) return true;
		else if(PlayerToPoint(1.0,playerid,362.2244,-2088.7981,7.8359) || PlayerToPoint(1.0,playerid,354.5382,-2088.7979,7.8359)) return true;
	}
	return false;
}
//
forward PlayerToPoint(Float:radi, playerid, Float:x, Float:y, Float:z);
forward LicClose();
forward Armygate();
forward Armygate2();
forward Arvorotacl();
forward housecl(); // копируешь и вставл€ешь со своим названием
new housegate; // тоже самое что и выше
new arvorota;
new licgate;
new armygate[2];
new timermc[MAX_PLAYERS];
new Db::Conf[Db::e_Conf];
new connDb;

enum pickupInfo {
	pOld,
	pDelay,
Float:pOldPos[3],
}
new PickupInfo[MAX_PLAYERS][pickupInfo];

enum e_AFKInfo {
	afk_Time[2],
	afk_State,
Float:afk_Pos,
Text3D:afk_Text,
};
new AFKInfo[MAX_PLAYERS][e_AFKInfo];

new
Fc::TOTAL,
TOTAL_VEHICLES
;

// Menus`s
new Menu:MainMenu;
new Menu:IntMenu;
new Menu:BuyMenu;
new Menu:BarMenu;
new Menu:PizaMenu;
new Menu:SkinMenu;
new Menu:Ammu1Menu;
new Menu:Ammu2Menu;
new Menu:BurgerMenu;
new Menu:HitmanMenu;
new Menu:ClothesMenu;
//
new Menu:ammonac;
//
new Menu:degun;
new Menu:sdgun;
new Menu:shotgun;
new Menu:mp5gun;
new Menu:m4a1gun;
new Menu:ak47gun;
new Menu:rifflegun;
//
new Menu:ammonac2;
new Menu:ammonac3;
// Global string`s
new src[512];
new query[2048];
new temp[255];
new plname[24];
new dialog[2048];
new string_ah[512];
new dialogtext[3000];

new RegEx:ValidRPName;
new RegEx:ValidText;

// Debug
#define	TOTAL_PLAYER_PAID		(0)
#define	TOTAL_SAVE_BIZNES		(1)
#define	TOTAL_SAVE_HOUSES		(2)
#define	TOTAL_SAVE_ACCOUNT		(3)
#define	TOTAL_QUERY_ERRORS		(4)
#define	TOTAL_RCON_LOGINS		(5)
new DEBUG[6];

// Pickup`s
new boj;
new buy[2];
new Piza;
new proba;
new weapon1;
new weapon2;
new weapon3;
new weapon4;
new healash;
new healcnn;
new healfbi;
new testpdd;
new fire_ext;
new Parashut;
new saveTuning;
new givepasport;
new FactorySklad;
new FactoryPickup[3];
new EstateAgency;

new respuk		[4];
new mak			[2];
new barn		[2];
new Bank		[2];
new helpp		[3];
new prolaps		[2];
new hitpickup   [2];
new ammozakona	[4];

new pickupd[MAX_PLAYERS][2];

// Area`s
new Area::ASH;
new Area::Shamal;
new Area::jailField;
new Area::poppyField;


// TextDraws`s
new Text:Time;
new Text:Copyright;
new Text:Logo[1];

new PlayerText:Pt::Spec[MAX_PLAYERS];
new PlayerText:Pt::Fuel[MAX_PLAYERS];
new PlayerText:Pt::Name[MAX_PLAYERS];
new PlayerText:Pt::Speed[MAX_PLAYERS][3];
new PlayerText:Pt::Status[MAX_PLAYERS];

// 3D Text`s
new Text3D:ah_text;
new Text3D:FactoryInfo[2];
new Text3D:AttachText[MAX_VEHICLES];


new const VehicleNames[212][20] = {
	"Landstalker"      ,"Bravura"      ,"Buffalo"  ,"Linerunner"    ,"Pereniel"       ,"Sentinel" ,"Dumper"          ,"Firetruck","Trashmaster" ,"Stretch"    ,"Manana"           ,"Infernus"         ,
	"Voodoo"           ,"Pony"         ,"Mule"     ,"Cheetah"       ,"Ambulance"      ,"Leviathan","Moonbeam"        ,"Esperanto","Taxi"        ,"Washington" ,"Bobcat"           ,"Mr Whoopee"       ,"BF Injection",
	"Hunter"           ,"Premier"      ,"Enforcer" ,"Securicar"     ,"Banshee"        ,"Predator" ,"Bus"             ,"Rhino"    ,"Barracks"    ,"Hotknife"   ,"Trailer"          ,"Previon"          ,"Coach"       ,"Cabbie"   ,
	"Stallion"         ,"Rumpo"        ,"RC Bandit","Romero"        ,"Packer"         ,"Monster"  ,"Admiral"         ,"Squalo"   ,"Seasparrow"  ,"Pizzaboy"   ,"Tram"             ,"Trailer"          ,"Turismo"     ,"Speeder"  ,
	"Reefer"           ,"Tropic"       ,"Flatbed"  ,"Yankee"        ,"Caddy"          ,"Solair"   ,"Berkley's RC Van","Skimmer"  ,"PCJ-600"     ,"Faggio"     ,"Freeway"          ,"RC Baron"         ,"RC Raider"   ,
	"Glendale"         ,"Oceanic"      ,"Sanchez"  ,"Sparrow"       ,"Patriot"        ,"Quad"     ,"Coastguard"      ,"Dinghy"   ,"Hermes"      ,"Sabre"      ,"Rustler"          ,"ZR3 50"           ,"Walton"      ,"Regina"   ,
	"Comet"            ,"BMX"          ,"Burrito"  ,"Camper"        ,"Marquis"        ,"Baggage"  ,"Dozer"           ,"Maverick" ,"News Chopper","Rancher"    ,"FBI Rancher"      ,"Virgo"            ,"Greenwood"   ,
	"Jetmax"           ,"Hotring"      ,"Sandking" ,"Blista Compact","Police Maverick","Boxville" ,"Benson"          ,"Mesa"     ,"RC Goblin"   ,"Hotring A"  ,"Hotring B"        ,
	"Bloodring Banger" ,"Rancher"      ,"Super GT" ,"Elegant"       ,"Journey"        ,"Bike"     ,"Mountain Bike"   ,"Beagle"   ,"Cropdust"    ,"Stunt"      ,"Tanker"           ,"RoadTrain"        ,
	"Nebula"           ,"Majestic"     ,"Buccaneer","Shamal"        ,"Hydra"          ,"FCR-900"  ,"NRG-500"         ,"HPV1000"  ,"Cement Truck","Tow Truck"  ,"Fortune"          ,"Cadrona"          ,"FBI Truck"   ,
	"Willard"          ,"Forklift"     ,"Tractor"  ,"Combine"       ,"Feltzer"        ,"Remington","Slamvan"         ,"Blade"    ,"Freight"     ,"Streak"     ,"Vortex"           ,"Vincent"          ,"Bullet"      ,"Clover"   ,
	"Sadler"           ,"Firetruck"    ,"Hustler"  ,"Intruder"      ,"Primo"          ,"Cargobob" ,"Tampa"           ,"Sunrise"  ,"Merit"       ,"Utility"    ,"Nevada"           ,"Yosemite"         ,"Windsor"     ,"Monster A",
	"Monster B"        ,"Uranus"       ,"Jester"   ,"Sultan"        ,"Stratum"        ,"Elegy"    ,"Raindance"       ,"RC Tiger" ,"Flash"       ,"Tahoma"     ,"Savanna"          ,"Bandito"          ,"Freight"     ,"Trailer"  ,
	"Kart"             ,"Mower"        ,"Duneride" ,"Sweeper"       ,"Broadway"       ,"Tornado"  ,"AT-400"          ,"DFT-30"   ,"Huntley"     ,"Stafford"   ,"BF-400"           ,"Newsvan"          ,"Tug"         ,"Trailer A","Emperor",
	"Wayfarer"         ,"Euros"        ,"Hotdog"   ,"Club"          ,"Trailer B"      ,"Trailer C","Andromada"       ,"Dodo"     ,"RC Cam"      ,"Launch"     ,"Police Car (LSPD)","Police Car (SFPD)",
	"Police Car (LVPD)","Police Ranger","Picador"  ,"S.W.A.T."      ,"Alpha"          ,"Phoenix"  ,"Glendale"        ,"Sadler"   ,"L Trailer A" ,"L Trailer B",
	"Stair Trailer"    ,"Boxville"     ,"Farm Plow","U Trailer"
};

new const Float:MaxVehicleSpeed[212] = {
	160.00, 160.00, 200.00, 120.00, 150.00, 165.00, 110.00, 170.00, 110.00, 180.00, 160.00,
	240.00, 160.00, 160.00, 140.00, 230.00, 155.00, 200.00, 150.00, 160.00, 180.00, 180.00,
	165.00, 145.00, 170.00, 200.00, 200.00, 170.00, 170.00, 200.00, 190.00, 130.00, 80.000,
	180.00, 200.00, 120.00, 160.00, 160.00, 160.00, 160.00, 160.00, 75.000, 150.00, 150.00,
	110.00, 165.00, 190.00, 200.00, 190.00, 150.00, 120.00, 240.00, 190.00, 190.00, 190.00,
	140.00, 160.00, 160.00, 165.00, 160.00, 200.00, 190.00, 260.00, 190.00, 75.000, 75.000,
	160.00, 160.00, 190.00, 200.00, 170.00, 160.00, 190.00, 190.00, 160.00, 160.00, 200.00,
	200.00, 150.00, 165.00, 200.00, 120.00, 150.00, 120.00, 190.00, 160.00, 100.00, 200.00,
	200.00, 170.00, 170.00, 160.00, 160.00, 190.00, 220.00, 170.00, 200.00, 200.00, 140.00,
	140.00, 160.00, 75.000, 260.00, 260.00, 160.00, 260.00, 230.00, 165.00, 140.00, 120.00,
	140.00, 200.00, 200.00, 200.00, 120.00, 120.00, 165.00, 165.00, 160.00, 340.00, 340.00,
	190.00, 190.00, 190.00, 110.00, 160.00, 160.00, 160.00, 170.00, 160.00, 60.000, 70.000,
	140.00, 200.00, 160.00, 160.00, 160.00, 110.00, 110.00, 150.00, 160.00, 230.00, 160.00,
	165.00, 260.00, 160.00, 160.00, 160.00, 200.00, 160.00, 160.00, 165.00, 160.00, 200.00,
	170.00, 180.00, 110.00, 110.00, 200.00, 200.00, 200.00, 200.00, 200.00, 200.00, 75.000,
	200.00, 160.00, 160.00, 170.00, 110.00, 110.00, 90.000, 60.000, 110.00, 60.000, 160.00,
	160.00, 200.00, 110.00, 160.00, 165.00, 190.00, 160.00, 170.00, 120.00, 165.00, 260.00,
	200.00, 140.00, 200.00, 260.00, 120.00, 200.00, 200.00, 60.000, 190.00, 200.00, 200.00,
	200.00, 160.00, 165.00, 110.00, 200.00, 200.00, 260.00, 260.00, 160.00, 160.00, 160.00,
	140.00, 160.00, 260.00
};

enum rInfo {
	rName[16],
	rUrl [64],
}
new RadioInfo[][rInfo] = {
	{"OFF", 			"-" },
	{"DFM", 			"http://92.50.177.134:8000/dfm.mp3"},
	{"4Life",			"http://play.radio4life.ru:8000/radio"},
	{"Europa +",		"http://webcast.emg.fm:55655/europaplus128.mp3"},
	{"Radio 13",		"http://play.radio13.ru:10000/"},
	{"Zaycev FM", 		"http://radio.zaycev.fm:9002/ZaycevFM(128)"},
	{"ENERGY FM",		"http://217.199.213.168:8000/v1_1"},
	{"Radio Record",	"http://radio01-cn03.akadostream.ru:8000/radiorecord128.mp3"}
};

new CP						[MAX_PLAYERS];
new MG2						[MAX_PLAYERS];
new Fixr					[MAX_PLAYERS char];
new Fell					[MAX_PLAYERS];
new Wait					[MAX_PLAYERS char];
new Music					[MAX_PLAYERS];
new CarID					[MAX_PLAYERS];
new Mobile					[MAX_PLAYERS];
new Condom					[MAX_PLAYERS];
new HireCar					[MAX_PLAYERS];
new gLastCar				[MAX_PLAYERS];
new CellTime				[MAX_PLAYERS];
new CarCalls				[MAX_PLAYERS];
new SexOffer				[MAX_PLAYERS];
new SexPrice				[MAX_PLAYERS];
new DrugGram				[MAX_PLAYERS];
new FindTime				[MAX_PLAYERS];
new CarOffer				[MAX_PLAYERS];
new CarPrice				[MAX_PLAYERS];
new TempSkin				[MAX_PLAYERS];
new useknock				[MAX_PLAYERS];
new UsedFind				[MAX_PLAYERS];
new LiveOffer				[MAX_PLAYERS];
new STDPlayer				[MAX_PLAYERS];
new JailPrice				[MAX_PLAYERS];
new RepairCar				[MAX_PLAYERS];
new DrugOffer				[MAX_PLAYERS];
new DrugPrice				[MAX_PLAYERS];
new AnimClear				[MAX_PLAYERS];
new ChosenSkin				[MAX_PLAYERS];
new GettingJob				[MAX_PLAYERS];
new CallLawyer				[MAX_PLAYERS];
new WantLawyer				[MAX_PLAYERS];
new ReduceTime				[MAX_PLAYERS];
new VoprosTime				[MAX_PLAYERS];
new acceptgruz				[MAX_PLAYERS char];
new WantedTime				[MAX_PLAYERS];
new TicketOffer				[MAX_PLAYERS];
new TicketMoney				[MAX_PLAYERS];
new RepairOffer				[MAX_PLAYERS];
new RepairPrice				[MAX_PLAYERS];
new RefillOffer				[MAX_PLAYERS];
new RefillPrice				[MAX_PLAYERS];
new checkpointb				[MAX_PLAYERS];
new checkpoints				[MAX_PLAYERS];
new DrugIntoxic				[MAX_PLAYERS];
new JobWaitTime				[MAX_PLAYERS];
new BusCallTime				[MAX_PLAYERS];
new BusAccepted				[MAX_PLAYERS];
new MatsHolding				[MAX_PLAYERS];
new TalkingLive				[MAX_PLAYERS];
new TaxiCallTime			[MAX_PLAYERS];
new TaxiAccepted			[MAX_PLAYERS];
new TransportTime			[MAX_PLAYERS];
new TransportCost			[MAX_PLAYERS];
new TransportDuty			[MAX_PLAYERS];
new MedicCallTime			[MAX_PLAYERS][2];
new ApprovedLawyer			[MAX_PLAYERS];
new PlayerTazeTime			[MAX_PLAYERS];
new TransportValue			[MAX_PLAYERS];
new TransportMoney			[MAX_PLAYERS];
new SelectCharPlace			[MAX_PLAYERS];
new TransportDriver			[MAX_PLAYERS];
new MechanicCallTime		[MAX_PLAYERS][2];
new PlayerCheckpoints		[MAX_PLAYERS][6];

new ProposeOffer			[MAX_PLAYERS]; // свадьба
new MarryWitness			[MAX_PLAYERS]; // свидетель
new MarryWitnessOffer		[MAX_PLAYERS]; // свидетель
new MarriageCeremoney		[MAX_PLAYERS];
new ProposedTo				[MAX_PLAYERS];
new GotProposedBy			[MAX_PLAYERS];
new DivorceOffer			[MAX_PLAYERS];


new KG						[MAX_PLAYERS][2];
new OnJob					[MAX_PLAYERS];
new StartJob				[MAX_PLAYERS];
new PlayerObject			[MAX_PLAYERS];


new Pl::Drunk				[MAX_PLAYERS];
new Pl::CarInt				[MAX_PLAYERS];
new Pl::Stoned				[MAX_PLAYERS];
new Pl::NetStats			[MAX_PLAYERS];
new Pl::DrunkTime			[MAX_PLAYERS];
new Pl::CuffedTime			[MAX_PLAYERS];
new Pl::CheckpointStatus	[MAX_PLAYERS];


new bool:Gag				[MAX_PLAYERS];
new bool:GrabPer            [MAX_PLAYERS];
new bool:gOoc				[MAX_PLAYERS];
new bool:gFam				[MAX_PLAYERS];
new bool:gNews				[MAX_PLAYERS];
new bool:gDice				[MAX_PLAYERS];
new bool:OnAir				[MAX_PLAYERS];
new bool:TogTP				[MAX_PLAYERS];
new bool:OnDuty				[MAX_PLAYERS];
new bool:BigEar				[MAX_PLAYERS];
new bool:HidePM				[MAX_PLAYERS];
new bool:EditMode			[MAX_PLAYERS];
new bool:MedicBill			[MAX_PLAYERS];
new bool:SwitchKey			[MAX_PLAYERS];
new bool:AdminDuty			[MAX_PLAYERS];
new bool:WatchingTV			[MAX_PLAYERS];
new 	 WrongLogin			[MAX_PLAYERS];
new bool:PlayerTied			[MAX_PLAYERS];
new bool:HelperDuty			[MAX_PLAYERS];
new bool:SpawnChange		[MAX_PLAYERS];
new bool:SuspectKill		[MAX_PLAYERS];
new bool:PhoneOnline		[MAX_PLAYERS];
new bool:MoneyMessage		[MAX_PLAYERS];
new bool:TakingLesson		[MAX_PLAYERS];
new bool:PlayerUseTazed		[MAX_PLAYERS];

new bool:gCarLock			[MAX_VEHICLES char] = {false, ...};
new bool:VehicleBoot		[MAX_VEHICLES char] = {false, ...};
new bool:VehicleLight		[MAX_VEHICLES char] = {false, ...};
new bool:VehicleBonnet		[MAX_VEHICLES char] = {false, ...};

new Iterator:AshQueue<MAX_PLAYERS>;
new Iterator:CreatedCars<MAX_VEHICLES>;
new Iterator:ToglogPlayers<MAX_PLAYERS>;
new Iterator:AdminPlayers<MAX_PLAYERS>;
new Iterator:HelperPlayers<MAX_PLAYERS>;
new Iterator:WantedPlayers<MAX_PLAYERS>;
new Iterator:LeaderPlayers<MAX_PLAYERS>;
new Iterator:enginedVehicles<MAX_VEHICLES>;
new Iterator:Houses<MAX_HOUSES>;
new Iterator:Biznes<MAX_BIZNES>;
new Iterator:Refills<MAX_REFILLS>;

new Iterator:MedicCalls<MAX_PLAYERS>;
new Iterator:MechanicCalls<MAX_PLAYERS>;
new Iterator:JobPlayers[MAX_JOBS]<MAX_PLAYERS>;
new Iterator:JobVehicles[MAX_JOBS]<MAX_VEHICLES>;
new Iterator:TeamPlayers[MAX_FRAC]<MAX_PLAYERS>;
new Iterator:TeamVehicles[MAX_FRAC]<MAX_VEHICLES>;
new Iterator:inStreamPlayers[MAX_PLAYERS]<MAX_PLAYERS>;
new Iterator:inStreamVehicles[MAX_PLAYERS]<MAX_VEHICLES>;
new Iterator:vehiclePassengers[MAX_VEHICLES]<MAX_PLAYERS>;

new GangBiznes[MAX_FRAC char];
new NameChange[MAX_PLAYERS char];
new bool:GMTest[MAX_PLAYERS char];
new bool:usePlusC[MAX_PLAYERS char];
new bool:isEngined[MAX_VEHICLES char];
new bool:useBannyHop[MAX_PLAYERS char];
new bool:InAntiDmZone[MAX_PLAYERS char];
new bool:PlayerLogged[MAX_PLAYERS char];
new timeleft[MAX_PLAYERS];
new slotused[MAX_PLAYERS char];


new noooc = 1;
new OnAirMax;
new addtimer = 60000;
new levelcost = 25000;
new deathcost = 50;
new callcost = 10; //20 seconds
new timeshift = 0;
new levelexp = 4;
new cchargetime = 60;
new shifthour;
new ghour;
new Medics;
new Mechanics;
new TaxiDrivers, TaxiCall = INVALID_PLAYER_ID;
new BusDrivers, BusCall = INVALID_PLAYER_ID;
new bool:adds = true;

// Timer`s
static serverUpdate;

new STD1[] = {0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3};
new STD2[] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3};
new STD3[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3};
new STD4[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 3};
new SELLCAR1[] = {1000, 1124, 1245, 1349, 1475, 1574, 1636, 1762, 1895, 1946, 2000};
new SELLCAR2[] = {2099, 2135, 2255, 2378, 2457, 2563, 2614, 2721, 2878, 2988, 3000};
new SELLCAR3[] = {3058, 3175, 3212, 3377, 3454, 3555, 3678, 3751, 3865, 3964, 4000};
new SELLCAR4[] = {4077, 4123, 4275, 4378, 4422, 4565, 4613, 4752, 4897, 4911, 5000};

new wrongWeapon[] = { 16, 17, 18, 19, 20, 21, 26, 27, 34, 35, 36, 37, 38, 39, 40, 47 };

new Float:CargoInfo[][3] = {
	{0.0,0.0,0.0},
	{-59.0808,0.1278,3.1172},
	{-1017.7874,-681.4913,32.0078},
	{823.9176,854.6870,11.8571},
	{578.8217,1221.5995,11.7113},
	{266.3958,1407.6863,10.4828},
	{-1890.8984,-1731.3362,21.7500},
	{2783.4919,-2475.8999,13.6347}
};

new ATMp[2];
new Float:ATMs[][4] = {
	{2235.427,-1150.405,25.515,181.245},
	{1367.233,-1283.083,13.000,260.000},
	{1833.169,-1846.869,13.221,-90.622},
	{1928.606,-1768.946,13.189,-271.868},
	{1003.041,-930.357,41.971,11.327},
	{501.860,-1364.001,15.775,113.278},
	{-79.431,-1172.427,1.774,-113.278},
	{-2033.096,-52.185,35.011,90.622},
	{-1980.677,145.389,27.330,-90.622},
	{-1693.100,414.963,6.822,45.311},
	{-2281.511,-80.277,34.981,181.245},
	{157.817,-1947.213,3.416,124.606}
};

new Float:BarCoord[][4] = {
	{4.0 ,495.7801  ,-76.0305  ,998.7578} ,
	{4.0 ,499.9654  ,-20.2515  ,1000.6797},
	{4.0 ,1215.9480 ,-13.3519  ,1000.9219},
	{10.0,-2658.9749,1407.4136 ,906.2734} ,
	{7.0 ,1207.2    ,-28.4     ,1000.9}   ,
	{7.0 ,968.6     ,-47.1     ,1001.1}   ,
	{7.0 ,-224.7    ,1404.9    ,27.7}     ,
	{7.0 ,2536.1    ,-1321.2   ,1031.4}   ,
	{10.0,1257.7211 ,-791.0063 ,1084.0078},
	{10.0,1262.6    ,-794.5    ,88.3}     ,
	{10.0,-785.8726 ,500.0969  ,1371.7422},
	{10.0,-782.4619 ,500.0730  ,1371.7490},
	{10.0, 223.0705 ,1407.3998 ,27.7734}  ,
	{10.0,2537.5303 ,-1288.9594,1054.6406},
	{10.0,1487.4    ,-666.9    ,95.6}     ,
	{10.0,-328.1    ,1803.1    ,42.7}     ,
	{10.0,1257.2    ,-791.0    ,1084.0}   ,
	{10.0,1104.500  ,-824.8508 ,106.1270} ,
	{10.0,1104.9603 ,-828.8508 ,107.1270} ,
	{4.0 ,241.4241  ,1022.6302 ,1084.0194},
	{20.0,2196.1833 ,1608.6389 ,1005.0625},
	{12.0,2575.6638 ,-1682.2990,1033.7017},
	{12.0,2192.8100 ,-1153.7800,25.6700},
	{7.0 ,825.0572  ,-2056.0303,12.8672}
};

enum intHouse
{
	intH,
	intPrice,
Float:intX,
Float:intY,
Float:intZ,
}
new HouseInt[][intHouse] = {
	{2 , 500000,2467.9895,-1698.2231,1013.5078}, // Ryder House
	{5 , 500000,2233.7095,-1114.6260,1050.8828}, // Safe House group 1
	{9 , 500000,2317.7146,-1026.5259,1050.2178}, // Safe House group 3
	{10, 500000,2259.5728,-1135.7870,1050.6328}, // Safe House group 4
	{3 , 500000,235.1864 ,1187.1646 ,1080.2578}, // Byrglary House X1
	{2 , 500000,226.0055 ,1240.0029 ,1082.1406}, // Byrglary House X2
	{1 , 500000,223.0618 ,1287.3446 ,1082.1406}, // Byrglary House X3
	{5 , 500000,226.9107 ,1114.3109 ,1080.9961}, // Byrglary House X4
	{12, 500000,443.2735 ,509.3156  ,1001.4195}, // Motel Room
	{10, 500000,23.9266  ,1340.6561 ,1084.3750}, // Byrglary House X14
	{12, 500000,2324.2925,-1148.8942,1050.7101}, // Unuded Safe House
	{4 , 500000,-260.7433,1456.6342 ,1084.3672}, // Byrglary House X15
	{5 , 500000,22.8225  ,1403.7344 ,1084.4297}, // Byrglary House X16
	{5 , 500000,140.2087 ,1366.6652 ,1083.8594}, // Byrglary House X17
	{6 , 500000,234.2954 ,1064.2416 ,1084.2115}, // Byrglary House X18
	{6 , 500000,-68.8532 ,1351.4395 ,1080.2109}, // Byrglary House X19
	{8 , 500000,2807.6042,-1174.1803,1025.5703}, // Colonel Furhbegers
	{1 , 500000,2217.5000,-1076.1509,1050.4844}, // The Calems Toe Safehouse
	{2 , 500000,2237.4856,-1080.2096,1049.0234}, // old Venturas Strip Casino
	{8 , 500000,2365.2268,-1135.3055,1050.8750}, // Verdant Bluffs Safehouse
	{8 , 500000,-42.7179 ,1405.9940 ,1084.4297}, // Byrglary House X21
	{7 , 800000, 225.8882,1021.8793 ,1084.0165} // Gold bar
};


enum jInfo {
	jID,
	jP,
	jV,
Float:jPos[3],
	jName[24],
}
new JobsInfo[][jInfo] = {
	{0,	-1,	0,	{0.0,	   0.0,		  0.0},		  "Ѕезработный"},
    {1, -1, 0, {323.3337,1890.7698,907.8959}, "ƒетектив"},
	{2,	-1, 0,	{291.6608,1914.3309,907.8959}, "јдвокат"},
	{3,	-1,	0,	{2415.8638,-1220.7854, 25.273400}, "ѕроститутка"},
	{4,	-1,	0,	{2166.3772,-1675.3829, 15.085900}, "Ќаркодилер"},
	{5,	-1,	0,	{1109.3318,-1796.3042, 16.593800}, "јвтоугонщик"},
	{6,	-1,	0,	{-1932.385, 276.21170, 41.039100}, "јвтомеханик"},
	{7,	-1,	0,	{1366.4325,-1275.2096, 13.546900}, "√андилер"},
	{8,	-1,	0,	{531.79300,-1292.4044, 17.242200}, "јвтодилер"},
	{9,	-1,	0,	{1154.2208,-1770.8203, 16.599200}, "јвтобусник"},
	{10,-1,	0,	{-77.72880,-1136.3896, 1.0781000}, "ƒальнобойщик"}
};
enum dInfo {
	dPrice,
	dDrunk,
	dName[24],
Float:dHP,
}
new DrinkInfo[][dInfo] = {
	{3,		0,	"Soda",			5.0},
	{3,		0,	"Coca-Cola",	5.0},
	{3,		0,	"Tea",			5.0},
	{2,		0,	"Water",		5.0},
	{5,		1,	"Beer",			15.0},
	{10,	3,	"Vodka",		25.0},
	{20,	2,	"Whiskey",		25.0},
	{20,	2,	"Tequila",		25.0},
	{25,	2,	"Martini",		25.0},
	{30,	4,	"Samagon",		30.0},
	{100,	4,	"Coniak",		35.0},
	{1,		0,	"Cigarette",	0.0}
};

enum burgsInfo {
	bPrice,
	bDescription[24],
Float:bHP,
}
new BurgerInfo[][burgsInfo] = {
	{10,	"Hamburger",		5.0},
	{10,	"CheeseBurger",		5.0},
	{30,	"BigMak",			10.0},
	{35,	"RoyalCheeseBurger",15.0},
	{28,	"MakFluri",			11.0},
	{60,	"ChikenMakNafix",	25.0},
	{31,	"Vishnevi Pirojok",	18.0},
	{8,		"Rojok",			4.0}
};

new PizzaInfo[][burgsInfo] = {
	{3,		"Soda",			5.0},
	{3,		"Coca-Cola",	5.0},
	{3,		"Tea",			5.0},
	{2,		"Water",		3.0},
	{15,	"PiZZa",		15.0},
	{50,	"Big PiZZa",	25.0},
	{30,	"BigMak",		10.0}
};

new EatInfo[][burgsInfo] = {
	{10,	"ѕерловка",		10.0},
	{15,	" артофель",	18.0},
	{15,	"√речка",		15.0},
	{10,	" омпот",		10.0},
	{5,		"„ай",			10.0}
};


enum ammoInfo
{
	gID,
	gAmmo,
	gPrice,
	gName[24],
}
new Ammu1Info[][ammoInfo] = {
	{24,	50,		3500,	"Deagle"},
	{22,	100,	2000,	"Pistol 9mm"},
	{23,	100,	2200,	"Silenced 9mm"},
	{25,	30,		3000,	"ShotGun"},
	{31,	200,	7000,	"M4"},
	{29,	200,	5000,	"MP5"},
	{30,	200,	7000,	"AK-47"},
	{5,		1,		500,	"BassBall Bat"},
	{1,		1,		500,	"Brass Knuckles"},
	{7,		1,		500,	"Billiard Cue"},
	{10,	1,		600,	"Purple Dildo"}
};

new Ammu2Info[][ammoInfo] = {
	{24,	50,		1500,	"Deagle"},
	{22,	100,	1000,	"Pistol 9mm"},
	{23 ,	100,	1200,	"Silenced 9mm"},
	{25,	30,		1500,	"ShotGun"},
	{31,	500,	3500,	"M4"},
	{29,	500,	2500,	"MP5"},
	{30,	500,	3000,	"AK-47"},
	{3,		1,		500,	"Nite Stick"},
	{41,	500,	500,	"Spraycan"}
};

enum hitInfo
{
	gID,
	gAmmo,
	gRank,
	gPrice,
	gName[24],
}
new HitmanAmmo[][hitInfo] = {
	{4, 	1, 		1,	1000,	"Knife"},
	{24,	50,		1,	1500,	"Deagle"},
	{23 ,	100,	1,	1200,	"Silenced 9mm"},
	{25,	30,		1,	1500,	"ShotGun"},
	{31,	300,	3,	3500,	"M4"},
	{29,	300,	2,	2500,	"MP5"},
	{30,	300,	4,	3000,	"AK-47"},
	{34,	10,		4,	5000,	"Sniper Rifle"}
};


enum spInfo {
	spInt,
	spVirt,
Float:spX,
Float:spY,
Float:spZ,
Float:spA,
}
new SpawnInfo[MAX_SPAWNS][spInfo];

new FracID		[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 };
new trailerID	[] = { 435, 611, 450, 591, 606, 607, 610, 569, 590, 584, 570, 608 };
new FightStyles	[] = { 4, 5, 6, 7, 15, 16 };
static const correctAnswer[] = {
	' ',
	'b', 'c', 'b', 'b', 'c', 'b', 'c', 'd', 'd', 'b',
	'd', 'b', 'b', 'd', 'b', 'a', 'd', 'b', 'b', 'a'
};

enum tpInfo
{
	tpVw,
	tpInt,
	tpLocal,
Float:tpPos[4],
}
new TeleportDest[MAX_PLAYERS][tpInfo];

new comptruck[2];

new engine,light,alarm,doors,bonnet,boot,objective;
new Float:posx, Float:posy, Float:posz;
new Float:vehx, Float:vehy, Float:vehz;
new Float:angle,Float:distance;


enum Fc::Enum {
	Fc::Id[2],				// 0 - ид транспорта в Ѕд. 1 - ид созданного транспорта на сервере
	Fc::Model,
	Fc::FracId,
	Fc::RankId,
	Fc::Color[2],			// 0 - первый цет. 1 - второй цвет.
	Fc::Number[10],
Float:Fc::RespPos[4],	// 0 - x. 1 - y. 2 - z. 3 - angle.
}
new Fc::Info[MAX_FC][Fc::Enum];

new Fc::FORBIDDEN_VEH[] = { 441, 449, 450, 470, 569, 577, 584, 590, 591, 592, 594, 606, 607, 608, 610, 611 };

new Gangs[] = { 12, 14, 15, 16, 17, 18 };
new Teams[] = { 1, 2, 3, 4, 7 };
new Mafias[] = { 5, 6, 13 };

new ZahvatDeath[MAX_PLAYERS];
new ZahvatKills[MAX_FRAC char];
new ZahvatScore[MAX_FRAC];
new GangOnBattle[MAX_FRAC];
new GangSolderCount[MAX_FRAC];
enum pInfo {
	pID,
	pVip,
	pLevel,
	pAdmin,
	pHelper,
	pTime,
	pReg,
	pSex,
	pAge,
	pOrigin,
	pMuted,
	pExp,
	pBank,
	pCrimes,
	pKills,
	pDeaths,
	pArrested,
	pWantedL,
	pWantedD,
	pPhoneBook,
	pLottoNr,
	pJob,
	pPayCheck,
	pJailed,
	pJailTime,
	pMats,
	pDrugs,
	pLeader,
	pMember,
	pRank,
	pChar,
	pContractTime,
	pSkill[8], // 0 - det, 1 - sex, 2 - law, 3 - mech, 4 - jack, 5 - car, 6 - news, 7 - drugs
	pLocal,
	pNumber,
	pHouseKey,
	pBizKey,
	pLic[5], // 0 - car, 1 - fly, 2 - boat, 3 - gun, 4 - fish
	pCarTime,
	pPayDay,
	pPayDayHad,
	pCDPlayer,
	pWarns,
	pFuel,
	pMutedTime,
	pReport,
	pBanned,
	pTest,
	pRebuke,
	pFightstyle,
	pPasport[3],
	pLastVisit,
	pWait,
	pUpdate,
	pHunger,
	pCamPos,
	bool:pMaskOn,
	pMarried, // свадьба
	pMarriedTo[MAX_PLAYER_NAME], // свадьба
	pMedKarta,
	pMedHour,
	pGPS
};
new Pl::Info[MAX_PLAYERS][pInfo];


enum Bl::enum {
	Bl::Marker,

	Bl::Finder,
	Bl::Observe,

bool:Bl::isKilled,

	Bl::onFrac[MAX_FRAC],
	Bl::Kills[MAX_FRAC],
}
new Bl::Info[MAX_PLAYERS][Bl::enum];


enum spec_enum
{
	pSpecID,
	pSpecVw		[2],
	pSpecInt	[2],
	pSpecState	[2],
}
new Pl::SpecInfo[MAX_PLAYERS][spec_enum];


enum syncInfo {
	sKillerID,
	sReasonID,
}
new SyncInfo[MAX_PLAYERS][syncInfo];

enum hInfo {
	hID,
	hOwned,
	hLock,
	hOwner[MAX_PLAYER_NAME],
	hDescription[28],
	hPrice,
	hLevel,
	hInt,
	hTv,
	hDate,
	hRent[2],
	hSafe[5],
	hGuns[MAX_HWEAP],
	hAmmos[MAX_HWEAP],
Float:hEnter[4],
Float:hExit[4],

	hvModel,
	hvColor[2],
	hvPark,
Float:hvSpawn[4],

bool:hgGarage,
Float:hgIntPos[4],
Float:hgStreetPos[4],
	hgPickupInt,
	hgPickupStreet,

	hPickup,
	hMapIcon,
	hVirtual,
	hAuto,
};
new HouseInfo[MAX_HOUSES][hInfo];

enum aInfo {
	aOwner,
	aRadio,
	aUpdate,

#define COLOR_ONE (0)
#define COLOR_TWO (1)
	aColor[2],

#define CUR_MATS (0)
#define MAX_MATS (1)
	aMats,
	aDrugs,
	aMaxMats,
	aMaxDrugs,

	aTuning[MAX_COMPONENT],
	aPaintJob,

	aLimit,

Float:aFuel,
Float:aMileage,
};
new AutoInfo[MAX_VEHICLES][aInfo];

enum bInfo {
	bID,
	bOwned,
	bLocked,
	bOwner[MAX_PLAYER_NAME],
	bExtortion[MAX_PLAYER_NAME],
	bDescription[24],
	bLevel,
	bPrice,
	bSafe,
	bProfit,
	bEnterCost,
	bFrac,
	bProds,
	bMaxProds,
	bPriceProd,
	bInterior,
	bIcon[2],
Float:bEnter[4],
Float:bExit[4],

	bVirtual,
	bPickupEnter,
	bPickupExit,
	bMapIcon,

	bZone,
	bAttack,
	bDefend,
	bOnBattle,
	bZahvatTime,
	bZahvatTimer,
	bZahvatArea,
Float:bzMinX,
Float:bzMinY,
Float:bzMaxX,
Float:bzMaxY,
Text:bZahvatTD,
};
new BizzInfo[MAX_BIZNES][bInfo];

enum brInfo {
	brID,
	brBizID,
Float:brPos[3],
	brPickup,
}
new RefillInfo[MAX_REFILLS][brInfo];


enum gInfo {
	fID,
	gRespect,
Float:gPosX,
Float:gPosY,
Float:gPosZ,
Text3D:gText,
};
new GangInfo[sizeof Gangs][gInfo];

enum fSpawnInfo {
	fSpawnInt[2],
Float:fSpawnPos[4]
}
enum fInfo {
	fBank,
	fRConf[3],
	fBConf[2],
	fName[36],
	fTag [16],
	fColor,
	fSpawn[fSpawnInfo],
};

enum fGateInfo {
	GateID,
	GateRight
};
new FracInfo[MAX_FRAC][fInfo];
new RankInfo[MAX_FRAC][MAX_RANK][36];
new RankNums[MAX_FRAC];
new FracPay[MAX_FRAC];

new FracGate[MAX_FRAC_GATE][fGateInfo];
new FracGateCount;

#define SET_GATE_ACCESS(%0,%1,%2) FracGate[%0][GateRight] += %2 << %1
#define GET_GATE_ACCESS(%0,%1) (FracGate[%0][GateRight] >>> %1 & 1 != 0)

#define zRANK	(0)
#define bRANK	(1)
#define gRANK	(2)
#define bKILLS	(0)
#define bPRICE	(1)


enum e_GmInfo {
	Gm::TaxValue,
	Gm::PritonDrugs,
	Gm::AmbarDrugs,
	Gm::FactoryMetal,
	Gm::FactoryFuel,
	Gm::FactoryProds,
	Gm::EnableReg,
	Gm::isAutoRest,

	Gm::Hostname[36],
	Gm::Password[36],
	Gm::Mode[36],
	Gm::Map[36],
	Gm::Status
}
new Gm::Info[e_GmInfo];


enum pHaul
{
	pCapasity,
	pLoad,
};
new PlayerHaul[NUMBER_OF_TRUCKS][pHaul];


enum pCrime_Enum {
	pVictim		[24],
	pAccused	[24],
	pAccusing	[64],
};
new Pl::Crime[MAX_PLAYERS][pCrime_Enum];


enum Portal::e_potal
{
	Portal::Id,

	Portal::Model[2],
	Portal::Type[2],
	Portal::Inter[2],
	Portal::World[2],

Float:Portal::Portal1[4],
Float:Portal::Portal2[4],

	Portal::Allowed[MAX_FRAC],
	Portal::Pickup[2],
};
new
TOTAL_PORTAL,
Portal::Info[MAX_PORTALS][Portal::e_potal]
;



enum vInfo {
	vID,
	vModel,
Float:vPosX,
Float:vPosY,
Float:vPosZ,
Float:vPosA,
	vColor1,
	vColor2,
	vRespTime,
	vJob,
	cID
};
new VehicleInfo[MAX_VEHICLESex][vInfo];


enum respI
{
	fId,
Float:rMinX,
Float:rMinY,
Float:rMaxX,
Float:rMaxY,
}
new RespCoord[][respI] = {
	{1,1523.4375,-1738.28125,1593.75,-1599.6},
	{2,-1703.1,642.5,-1562.5,742.1},
	{3,78.125,1750.0,388.6,2128.9},
	{4,-2748.0,576.1,-2525.3,712.8},
	{5,1083.9,-2087.8,1291.0,-1988.2},
	{6,1416.0,2722.6,1529.29,2876.9},
	{7,1382.8,-1871.0,1564.4,-1732.4},
	{8,986.3,-394.5,1111.3,-300.7},
	{9,636.7,-1392.5,789.0,-1330.07},
	{10,-1785.1,927.7,-1701.1,1109.3},
	{11,-2111.3,-287.1,-1996.0,-54.6},
	{12,647.2,-479.8,723.6,-422.2},
	{13,-2820.3,-421.875,-2599.6,-199.2},
	{14,2423.8,-1734.375,2544.9,-1599.6},
	{15,1666.0,-1968.75,1833.9,-1814.4},
	{16,804.5,-1135.7,952.6,-1061.4},
	{17,-2202.3,-281.7,-2095.5,-79.9},
	{18,2732.4,-1662.109375,2908.2,-1480.4},
	{19,1009.6,2057.3,1112.4,2212.9},
	{20,-1238.9,-1393.4,-965.2,-870.6}
};


enum camEnum
{
	musicid,
	iteriorid,
	virtworld,
Float:p_pos[4],
Float:c_pos[3],
Float:c_lookAt[3],
}
new EnterPos[][camEnum] = {
	//{{0000}, {0}, {99}, {-1657.5237,1207.6644,13.6719,357.6906},	{-1657.4678,1211.2292,13.6781},		{-1657.5237,1207.6644,13.6719}}
	{{1187}, {0}, {99}, {-1494.7579,985.1379,7.1875,120.9491},		{-1399.0210,976.2402,179.3737},		{-1754.3281, 669.2344, 62.8203}}
	/*{{1185}, {0}, {99}, {-1564.6333,701.9891,7.0391,0.0000},		{-1564.6333,701.8426,146.6249},		{-1700.9147,834.9225,170.3657}},
	{{1183}, {0}, {99}, {2020.4767,1204.7135,10.8203,0.0000},		{2020.4767,1203.1107,59.2244},		{2143.4326,1135.3274,59.3245}},
	{{1183}, {0}, {99}, {-2806.6660,2233.7676,111.5226,284.5099},	{-2807.1660,2234.5759,166.1842},	{-2806.8335,2233.6262,166.1643}},
	{{1097}, {0}, {99}, {465.9904,2503.9668,22.4554,4.0220},		{465.2324,2499.6450,22.7485},		{464.2286,2499.6545,22.7884}},
	{{1185}, {0}, {99}, {2168.6704,2143.6128,10.9593,268.1124},		{2097.0530,2143.8245,37.3217},		{2098.0557,2143.8152,37.3817}},
	{{1183}, {0}, {99}, {1794.9576,1699.7588,6.7283,158.0961},		{1851.6905,1689.8480,27.7645},		{1853.4328,1693.3073,28.7634}}*/
	//		звук				 »грок									 амера								¬ектор камеры
};

enum gunInfo
{
	g_id,
	g_name[15],
	g_ammo,
	g_mats,
}
new GunInfo[][gunInfo] = {
	//	{ 4, "knife", 1, 100 },
	{ 21, "sdpistol", 50, 100 },
	{ 14, "flowers", 1, 25 },
	{ 24, "eagle", 50, 150 },
	{ 29, "mp5", 200, 200 },
	{ 25, "shotgun", 50, 200 },
	//	{ 27, "spas12", 50, 600 },
	{ 30, "ak47", 250, 600 },
	{ 31, "m4", 250, 600 },
	{ 33, "rifle", 50, 600 }
};

enum e_SAInteriors {
	iI,
Float:iX,
Float:iY,
Float:iZ,
Float:iA,
	int_Name[40]
}
new Menu:SAInteriorsMenu;
new SAInteriors[146][e_SAInteriors] = {
	{11, 2003.1178, 1015.1948, 33.008, 351.5789, "Four Dragons' Managerial Suite"},
	{5, 770.8033, -0.7033, 1000.7267, 22.8599, "Ganton Gym"},
	{3, 974.0177, -9.5937, 1001.1484, 22.6045, "Brothel"},
	{3, 961.9308, -51.9071, 1001.1172, 95.5381, "Brothel2"},
	{3, 830.6016, 5.9404, 1004.1797, 125.8149, "Inside Track Betting"},
	{3, 1037.8276, 0.397, 1001.2845, 353.9335, "Blastin' Fools Records"},
	{3, 1212.1489, -28.5388, 1000.9531, 170.5692, "The Big Spread Ranch"},
	{18, 1290.4106, 1.9512, 1001.0201, 179.9419, "Warehouse 1"},
	{1, 1412.1472, -2.2836, 1000.9241, 114.661, "Warehouse 2"},
	{3, 1527.0468, -12.0236, 1002.0971, 350.0013, "B Dup's Apartment"},
	{2, 1523.5098, -47.8211, 1002.2699, 262.7038, "B Dup's Crack Palace"},
	{3, 612.2191, -123.9028, 997.9922, 266.5704, "Wheel Arch Angels"},
	{3, 512.9291, -11.6929, 1001.5653, 198.7669, "OG Loc's House"},
	{3, 418.4666, -80.4595, 1001.8047, 343.2358, "Barber Shop"},
	{3, 386.5259, 173.6381, 1008.3828, 63.7399, "Planning Department"},
	{3, 288.4723, 170.0647, 1007.1794, 22.0477, "Las Venturas Police Department"},
	{3, 206.4627, -137.7076, 1003.0938, 10.9347, "Pro-Laps"},
	{3, -100.2674, -22.9376, 1000.7188, 17.285, "Sex Shop"},
	{3, -201.2236, -43.2465, 1002.2734, 45.8613, "Las Venturas Tattoo parlor"},
	{17, -202.9381, -6.7006, 1002.2734, 204.2693, "Lost San Fierro Tattoo parlor"},
	{17, -25.7220, -187.8216, 1003.5469, 5.0760, "24/7 (version 1)"},
	{5, 454.9853, -107.2548, 999.4376, 309.0195, "Diner 1"},
	{5, 372.5565, -131.3607, 1001.4922, 354.2285, "Pizza Stack"},
	{17, 378.026, -190.5155, 1000.6328, 141.0245, "Rusty Brown's Donuts"},
	{7, 315.244, -140.8858, 999.6016, 7.4226, "Ammu-nation"},
	{5, 225.0306, -9.1838, 1002.218, 85.5322, "Victim"},
	{2, 611.3536, -77.5574, 997.9995, 320.9263, "Loco Low Co"},
	{10, 246.0688, 108.9703, 1003.2188, 0.2922, "San Fierro Police Department"},
	{10, 6.0856, -28.8966, 1003.5494, 5.0365, "24/7 (version 2 - large)"},
	{7, 773.7318, -74.6957, 1000.6542, 5.2304, "Below The Belt Gym (Las Venturas)"},
	{1, 621.4528, -23.7289, 1000.9219, 15.6789, "Transfenders"},
	{1, 445.6003, -6.9823, 1000.7344, 172.2105, "World of Coq"},
	{1, 285.8361, -39.0166, 1001.5156, 0.7529, "Ammu-nation (version 2)"},
	{1, 204.1174, -46.8047, 1001.8047, 357.5777, "SubUrban"},
	{1, 245.2307, 304.7632, 999.1484, 273.4364, "Denise's Bedroom"},
	{3, 290.623, 309.0622, 999.1484, 89.9164, "Helena's Barn"},
	{5, 322.5014, 303.6906, 999.1484, 8.1747, "Barbara's Love nest"},
	{1, -2041.2334, 178.3969, 28.8465, 156.2153, "San Fierro Garage"},
	{1, -1402.6613, 106.3897, 1032.2734, 105.1356, "Oval Stadium"},
	{7, -1403.0116, -250.4526, 1043.5341, 355.8576, "8-Track Stadium"},
	{2, 1204.6689, -13.5429, 1000.9219, 350.0204, "The Pig Pen (strip club 2)"},
	{10, 2016.1156, 1017.1541, 996.875, 88.0055, "Four Dragons"},
	{1, -741.8495, 493.0036, 1371.9766, 71.7782, "Liberty City"},
	{2, 2447.8704, -1704.4509, 1013.5078, 314.5253, "Ryder's house"},
	{1, 2527.0176, -1679.2076, 1015.4986, 260.9709, "Sweet's House"},
	{10, -1129.8909, 1057.5424, 1346.4141, 274.5268, "RC Battlefield"},
	{3, 2496.0549, -1695.1749, 1014.7422, 179.2174, "The Johnson House"},
	{10, 366.0248, -73.3478, 1001.5078, 292.0084, "Burger shot"},
	{1, 2233.9363, 1711.8038, 1011.6312, 184.3891, "Caligula's Casino"},
	{2, 269.6405, 305.9512, 999.1484, 215.6625, "Katie's Lovenest"},
	{2, 414.2987, -18.8044, 1001.8047, 41.4265, "Barber Shop 2 (Reece's)"},
	{2, 1.1853, -3.2387, 999.4284, 87.5718, "Angel \"Pine Trailer\""},
	{18, -30.9875, -89.6806, 1003.5469, 359.8401, "24/7 (version 3)"},
	{18, 161.4048, -94.2416, 1001.8047, 0.7938, "Zip"},
	{3, -2638.8232, 1407.3395, 906.4609, 94.6794, "The Pleasure Domes"},
	{5, 1267.8407, -776.9587, 1091.9063, 231.3418, "Madd Dogg's Mansion"},
	{2, 2536.5322, -1294.8425, 1044.125, 254.9548, "Big Smoke's Crack Palace"},
	{5, 2350.1597, -1181.0658, 1027.9766, 99.1864, "Burning Desire Building"},
	{1, -2158.6731, 642.09, 1052.375, 86.5402, "Wu-Zi Mu's"},
	{10, 419.8936, 2537.1155, 10.0, 67.6537, "Abandoned AC tower"},
	{14, 256.9047, -41.6537, 1002.0234, 85.8774, "Wardrobe/Changing room"},
	{14, 204.1658, -165.7678, 1000.5234, 181.7583, "Didier Sachs"},
	{12, 1133.35, -7.8462, 1000.6797, 165.8482, "Casino (Redsands West)"},
	{14, -1420.4277, 1616.9221, 1052.5313, 159.1255, "Kickstart Stadium"},
	{17, 493.1443, -24.2607, 1000.6797, 356.9864, "Club"},
	{18, 1727.2853, -1642.9451, 20.2254, 172.4193, "Atrium"},
	{16, -202.842, -24.0325, 1002.2734, 252.8154, "Los Santos Tattoo Parlor"},
	{5, 2233.6919, -1112.8107, 1050.8828, 8.6483, "Safe House group 1"},
	{6, 1211.2484, 1049.0234, 359.941, 170.9341, "Safe House group 2"},
	{9, 2319.1272, -1023.9562, 1050.2109, 167.3959, "Safe House group 3"},
	{10, 2261.0977, -1137.8833, 1050.6328, 266.88, "Safe House group 4"},
	{17, -944.2402, 1886.1536, 5.0051, 179.8548, "Sherman Dam"},
	{16, -26.1856, -140.9164, 1003.5469, 2.9087, "24/7 (version 4)"},
	{15, 2217.281, -1150.5349, 1025.7969, 273.7328, "Jefferson Motel"},
	{1, 1.5491, 23.3183, 1199.5938, 359.9054, "Jet Interior"},
	{1, 681.6216, -451.8933, -25.6172, 166.166, "The Welcome Pump"},
	{3, 234.6087, 1187.8195, 1080.2578, 349.4844, "Burglary House X1"},
	{2, 225.5707, 1240.0643, 1082.1406, 96.2852, "Burglary House X2"},
	{1, 224.288, 1289.1907, 1082.1406, 359.868, "Burglary House X3"},
	{5, 239.2819, 1114.1991, 1080.9922, 270.2654, "Burglary House X4"},
	{15, 207.5219, -109.7448, 1005.1328, 358.62, "Binco"},
	{15, 295.1391, 1473.3719, 1080.2578, 352.9526, "4 Burglary houses"},
	{15, -1417.8927, 932.4482, 1041.5313, 0.7013, "Blood Bowl Stadium"},
	{12, 446.3247, 509.9662, 1001.4195, 330.5671, "Budget Inn Motel Room"},
	{0, 2306.3826, -15.2365, 26.7496, 274.49, "Palamino Bank"},
	{0, 2331.8984, 6.7816, 26.5032, 100.2357, "Palamino Diner"},
	{0, 663.0588, -573.6274, 16.3359, 264.9829, "Dillimore Gas Station"},
	{18, -227.5703, 1401.5544, 27.7656, 269.2978, "Lil' Probe Inn"},
	{0, -688.1496, 942.0826, 13.6328, 177.6574, "Torreno's Ranch"},
	{0, -1916.1268, 714.8617, 46.5625, 152.2839, "Zombotech - lobby area"},
	{0, 818.7714, -1102.8689, 25.794, 91.1439, "Crypt in LS cemetery (temple)"},
	{0, 255.2083, -59.6753, 1.5703, 1.4645, "Blueberry Liquor Store"},
	{2, 446.626, 1397.738, 1084.3047, 343.9647, "Pair of Burglary Houses"},
	{5, 227.3922, 1114.6572, 1080.9985, 267.459, "Crack Den"},
	{5, 227.7559, 1114.3844, 1080.9922, 266.2624, "Burglary House X11"},
	{4, 261.1165, 1287.2197, 1080.2578, 178.9149, "Burglary House X12"},
	{4, 291.7626, -80.1306, 1001.5156, 290.2195, "Ammu-nation (version 3)"},
	{4, 449.0172, -88.9894, 999.5547, 89.6608, "Jay's Diner"},
	{4, -27.844, -26.6737, 1003.5573, 184.3118, "24/7 (version 5)"},
	{0, 2135.2004, -2276.2815, 20.6719, 318.59, "Warehouse 3"},
	{4, 306.1966, 307.819, 1003.3047, 203.1354, "Michelle's Love Nest*"},
	{10, 24.3769, 1341.1829, 1084.375, 8.3305, "Burglary House X14"},
	{1, 963.0586, 2159.7563, 1011.0303, 175.313, "Sindacco Abatoir"},
	{0, 2548.4807, 2823.7429, 10.8203, 270.6003, "K.A.C.C. Military Fuels Depot"},
	{0, 215.1515, 1874.0579, 13.1406, 177.5538, "Area 69"},
	{4, 221.6766, 1142.4962, 1082.6094, 184.9618, "Burglary House X13"},
	{12, 2323.7063, -1147.6509, 1050.7101, 206.5352, "Unused Safe House"},
	{6, 344.9984, 307.1824, 999.1557, 193.643, "Millie's Bedroom"},
	{12, 411.9707, -51.9217, 1001.8984, 173.3449, "Barber Shop"},
	{4, -1421.5618, -663.8262, 1059.5569, 170.9341, "Dirtbike Stadium"},
	{6, 773.8887, -47.7698, 1000.5859, 10.7161, "Cobra Gym"},
	{6, 246.6695, 65.8039, 1003.6406, 7.9562, "Los Santos Police Department"},
	{14, -1864.9434, 55.7325, 1055.5276, 85.8541, "Los Santos Airport"},
	{4, -262.1759, 1456.6158, 1084.3672, 82.459, "Burglary House X15"},
	{5, 22.861, 1404.9165, 1084.4297, 349.6158, "Burglary House X16"},
	{5, 140.3679, 1367.8837, 1083.8621, 349.2372, "Burglary House X17"},
	{3, 1494.8589, 1306.48, 1093.2953, 196.065, "Bike School"},
	{14, -1813.213, -58.012, 1058.9641, 335.3199, "Francis International Airport"},
	{16, -1401.067, 1265.3706, 1039.8672, 178.6483, "Vice Stadium"},
	{6, 234.2826, 1065.229, 1084.2101, 4.3864, "Burglary House X18"},
	{6, -68.5145, 1353.8485, 1080.2109, 3.5742, "Burglary House X19"},
	{6, -2240.1028, 136.973, 1035.4141, 269.0954, "Zero's RC Shop"},
	{6, 297.144, -109.8702, 1001.5156, 20.2254, "Ammu-nation (version 4)"},
	{6, 316.5025, -167.6272, 999.5938, 10.3031, "Ammu-nation (version 5)"},
	{15, -285.2511, 1471.197, 1084.375, 85.6547, "Burglary House X20"},
	{6, -26.8339, -55.5846, 1003.5469, 3.9528, "24/7 (version 6)"},
	{6, 442.1295, -52.4782, 999.7167, 177.9394, "Secret Valley Diner"},
	{2, 2182.2017, 1628.5848, 1043.8723, 224.8601, "Rosenberg's Office in Caligulas"},
	{6, 748.4623, 1438.2378, 1102.9531, 0.6069, "Fanny Batter's Whore House"},
	{8, 2807.3604, -1171.7048, 1025.5703, 193.7117, "Colonel Furhberger's"},
	{9, 366.0002, -9.4338, 1001.8516, 160.528, "Cluckin' Bell"},
	{1, 2216.1282, -1076.3052, 1050.4844, 86.428, "The Camel's Toe Safehouse"},
	{1, 2268.5156, 1647.7682, 1084.2344, 99.7331, "Caligula's Roof"},
	{2, 2236.6997, -1078.9478, 1049.0234, 2.5706, "Old Venturas Strip Casino"},
	{3, -2031.1196, -115.8287, 1035.1719, 190.1877, "Driving School"},
	{8, 2365.1089, -1133.0795, 1050.875, 177.3947, "Verdant Bluffs Safehouse"},
	{0, 1168.512, 1360.1145, 10.9293, 196.5933, "Bike School"},
	{9, 315.4544, 976.5972, 1960.8511, 359.6368, "Andromada"},
	{10, 1893.0731, 1017.8958, 31.8828, 86.1044, "Four Dragons' Janitor's Office"},
	{11, 501.9578, -70.5648, 998.7578, 171.5706, "Bar"},
	{8, -42.5267, 1408.23, 1084.4297, 172.068, "Burglary House X21"},
	{11, 2283.3118, 1139.307, 1050.8984, 19.7032, "Willowfield Safehouse"},
	{9, 84.9244, 1324.2983, 1083.8594, 159.5582, "Burglary House X22"},
	{9, 260.7421, 1238.2261, 1084.2578, 84.3084, "Burglary House X23"},
	{0, -1658.1656, 1215.0002, 7.25, 103.9074, "Otto's Autos"},
	{0, -1961.6281, 295.2378, 35.4688, 264.4891, "Wang Cars"}
};

static const MaxPassengers[27] = { // HEX смещени€ макс. кол-ва пассажиров на основной транспорт
	0x10331113, 0x11311131, 0x11331313, 0x80133301,
	0x1381F110, 0x10311103, 0x10001F10, 0x11113311,
	0x13113311, 0x31101100, 0x30001301, 0x11031311,
	0x11111331, 0x10013111, 0x01131100, 0x11111110,
	0x11100031, 0x11130221, 0x33113311, 0x11111101,
	0x33101133, 0x101001F0, 0x03133111, 0xFF11113F,
	0x13330111, 0xFF131111, 0x0000FF3F
};


new Float:l_FactoryCP[][] = {
	{2558.5881,-1295.8517,1044.1250},
	{2556.1011,-1295.8510,1044.1250},
	{2553.7939,-1295.8531,1044.1250},
	{2544.3843,-1295.8563,1044.1250},
	{2541.9963,-1295.8523,1044.1250}
};

new Float:r_FactoryCP[][] = {
	{2542.2380,-1290.9963,1044.1250},
	{2544.4521,-1290.9703,1044.1250},
	{2553.8679,-1291.0043,1044.1250},
	{2556.1863,-1291.0042,1044.1250},
	{2558.4622,-1290.9938,1044.1250}
};




enum e_AntiDm {
	e_AntiDmZoneId, e_AntiDmZone,
	e_AntiDmWorld, Float:e_AntiDmCoord[4]
};
new
TOTAL_ANTIDM_ZONES,
AntiDmInfo[MAX_ANTIDM_ZONES][e_AntiDm]
;


static const fightStyle[][] = {
	{5, "Ѕокс"},
	{6, " унг-фу"},
	{7, "—амбо"},
	{4, "”личном стиле"}
};


enum e_BusRoute {
	stopNext,
Float:stopX,
Float:stopY,
Float:stopZ,
	stopName[18],
}
static const BusRoute[][][e_BusRoute] = {
	{
		{1, 2233.6335,-1145.0454,25.7969, "ќтель Ћ—"},
		{2, -97.8188,-1147.8456,1.5352, "ƒЅ"},
		{3, -1091.4415,-1333.1506,129.3996, "‘ерма"},
		{4, -1851.9949,-568.4989,21.3089, "јэрапорт —‘"},
		{0, -2026.9414,-75.8452,35.3203, "јвтошкола"}
	}, {
		{1, -2026.2756,-75.5938,35.3203, "јвтошкола"},
		{2, -1825.0438,-621.1991,16.4978, "јэрапорт —‘"},
		{3, -1066.8634,-1357.1820,129.9968, "‘ерма"},
		{4, -113.7366,-1150.3976,1.7633, "ƒЅ"},
		{0, 2214.3008,-1139.4200,25.7969, "ќтель Ћ—"}
	}, {
		{1, 2622.3635,2300.7500,10.8203, "ќтель Ћ¬"},
		{2, 2035.5227,1655.9678,10.8203, " алигула"},
		{3, 2040.2583,1009.1813,10.8052, "„етыре ƒракона"},
		{4, -2015.0028,274.7591,32.9499, "јвтосалон —‘"},
		{0, -2038.8948,-63.9849,35.3138, "јвтошкола"}
	}, {
		{1, -2025.6659,-75.7442,35.3203, "јвтошкола"},
		{2, -1994.7224,314.3866,35.1719, "јвтосалон —‘"},
		{3, 2074.9963,997.5345,10.8052, "„етыре ƒракона"},
		{4, 2080.3950,1679.1343,10.8203, " алигула"},
		{0, 2637.7947,2345.4346,10.6719, "ќтель Ћ¬"}
	}
};

new BusRouteCount[] = {5, 5, 5, 5};


#define PARK_GARAGE (1)
#define PARK_HOME (2)
#define PARK_HOME_GARAGE (3)
#define MAX_EXTRA_VEHICLES (5)
enum e_ExtraVehicles {
	evID1,
	evID2,
	evOwner,
	evModel,
	evPark,
	evColor1,
	evColor2,
Float:evSpawnX,
Float:evSpawnY,
Float:evSpawnZ,
Float:evSpawnA,
}
new ExtraVehicles[MAX_PLAYERS][MAX_EXTRA_VEHICLES][e_ExtraVehicles];
new TotalExtraVehicles[MAX_PLAYERS];
new Iterator:ExtraVehicles[MAX_PLAYERS]<MAX_EXTRA_VEHICLES>;
new VehicleInGarage[MAX_PLAYERS][MAX_EXTRA_VEHICLES];
new TotalVehicleInGarage[MAX_PLAYERS];

new PlayerText:Td::AutoSolon;
new Menu:AutoSolonMenu;
new Menu:GarageMenu;
new TempVehicle[MAX_PLAYERS];
new GarageParkPickup[3];

new const ExtraVehicleLimit[] = {2, 4};
new const ASModelCount[] = {12, 9, 21, 29, 8};
new const AClassChar[] = {'A', 'B', 'C', 'D', 'E'};

new const AutoSolon[][][] = {
	{
		// offroad (A)
		{424, 150000},
		{444, 444000},
		{489, 150000},
		{495, 404000},
		{500, 210000},
		{554, 140000},
		{556, 500000},
		{557, 500000},
		{568, 122000},
		{573, 430000},
		{579, 250000},
		{400, 100000},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0}
	}, {
		// moto (B)
		{461, 130000},
		{462, 3000},
		{463, 180000},
		{468, 70000},
		{471, 50000},
		{521, 200000},
		{522, 300000},
		{581, 90000},
		{586, 170000},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0}
	}, {
		// sport (C)
		{402, 400000},
		{411, 700000},
		{429, 550000},
		{451, 625000},
		{477, 477000},
		{480, 353000},
		{494, 700000},
		{496, 270000},
		{502, 700000},
		{503, 700000},
		{506, 520000},
		{541, 510000},
		{558, 420000},
		{559, 580000},
		{560, 560000},
		{562, 310000},
		{565, 240000},
		{587, 340000},
		{589, 262000},
		{602, 360000},
		{603, 470000},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0},
		{0, 0}
	}, {
		// purser (D)
		{401, 35000},
		{404, 25000},
		{405, 150000},
		{409, 500000},
		{410, 35000},
		{412, 80000},
		{413, 70000},
		{418, 60000},
		{419, 90000},
		{421, 100000},
		{423, 200000},
		{426, 97000},
		{494, 150000},
		{436, 40000},
		{439, 63000},
		{455, 87000},
		{458, 45000},
		{466, 55000},
		{467, 250000},
		{474, 65000},
		{475, 57000},
		{479, 6600},
		{482, 111000},
		{483, 220000},
		{491, 95000},
		{492, 84000},
		{504, 250000},
		{507, 44000},
		{516, 61000}
	}
};

enum eStandPos {
Float:pPos[4],
Float:vPos[4],
Float:pCPos[3],
Float:pCLookAt[3],
}
new const StandPos[][eStandPos] = {
	{{561.2763,-1292.7158,17.2482,0.0}, {544.5237,-1289.2005,16.9530,337.7358}, {550.2797,-1283.9201,18.2656}, {547.3525,-1286.6055,17.7969}},
	{{-1958.5961,267.3734,41.0471,272.4041}, {-1948.1573,265.1886,40.6213,43.1284}, {-1953.8283, 265.0975,41.7476}, {-1949.8345, 265.1616, 41.5336}},
	{{-1649.9727,1212.4740,13.6719,133.6049}, {-1659.5625,1211.7045,13.4045,303.2365}, {-1658.6960, 1218.3387, 14.4254}, {-1658.8348, 1214.3636, 14.0017}},
	{{2172.9387,1395.4965,11.0625,0.0}, {2194.0857,1391.7537,10.5558,93.1450}, {2186.0534, 1386.6127, 12.0322}, {2189.0207, 1389.2465, 11.5236}}
};

#define NONE_VEHICLE	(0)
#define HOME_VEHICLE	(1)
#define EXTRA_VEHICLE	(2)

new HGaragePickup[2];
static const Float:HGaragePickupPos[][4] = {
	{620.0793, -119.9805, 998.8491, 176.0786},
	{609.8389, -125.3335, 997.9922, 269.7483}
};


enum e_DefaultBiz {
	bInterior,
	bIcon[2],
Float:bExit[4]
}
new const DefaultBiz[][e_DefaultBiz] = {
	{3, {52, 36}, {293.0706, 310.0464, 999.1484, 88.3541}},
	{1, {52, 6}, {285.9240, -39.8285, 1001.5156, 269.0992}},
	{10, {52, 10}, {364.1878, -73.9688, 1001.5078, 264.0963}},
	{5, {52, 29}, {372.3589, -133.0934, 1001.4922, 4.0632}},
	{9, {52, 14}, {364.8246, -10.8034, 1001.8516, 3.5526}},
	{17, {52, 36}, {-25.8902, -187.6157, 1003.5469, 4.9643}}
};


#include "..\include\r_utils"
#include "..\include\anticheat"
#include "..\include\gate"


new cache_row[512];
#define cache_get_str(%0,%1,%2) cache_get_row(%0,%1,cache_row),sscanf(cache_row,%2)
#define cache_get_int(%0,%1,%2) %2=cache_get_row_int(%0,%1)
#define cache_get_float(%0,%1,%2) %2=cache_get_row_float(%0,%1)


main() {
	print(" ");
	print(">> "#__GamemodeName__" "#__GamemodeVersion__" loaded!");
	print(">>  "#__GamemodeCopyright__"");
	print(" ");
}


public OnGameModeInit() {
	new time;			// AntiDeAMX
	#emit LOAD.S.pri	time
	#emit SYSREQ.C		GetTickCount
	#emit STOR.S.pri	time

	if(GetMaxPlayers() > MAX_PLAYERS) panic(" оличество слотов больше MAX_PLAYERS, старт игрового режима невозможен!");

	if(!LoadConf()) panic("ќтсутствует файл конфигурации, старт игрового режима невозможен!");
	CreateObjects();
	if(!Db::Init()) panic("Ќе удалось подключитс€ к базе данных, старт игрового режима невозможен!");

	Db::Update();

	Iter::Init(JobPlayers);
	Iter::Init(JobVehicles);
	Iter::Init(TeamPlayers);
	Iter::Init(TeamVehicles);
	Iter::Init(ExtraVehicles);
	Iter::Init(inStreamPlayers);
	Iter::Init(inStreamVehicles);
	Iter::Init(vehiclePassengers);

	print(" ");

	LoadGas();
	LoadATM();
	LoadBizz();
	LoadGMInfo();
	LoadSkins();
	LoadRanks();
	LoadGates();
	LoadSpawns();
	LoadHouses();
	LoadHGarages();
	LoadPortals();
	LoadVehicles();
	LoadAntiDmZones();
	LoadFracInfo();
	LoadGangInfo();
	LoadFracVehicles();

	print(" ");

	Veh::Init();
	Td::Init();
	Mnu::Init();
	Obj::Init();
	Pup::Init();
	T3d::Init();
	Area::Init();

	print(" ");

	ShowPlayerMarkers				(2);
	LimitGlobalChatRadius			(T_DIST);
	SetNameTagDrawDistance			(T_DIST);
	EnableStuntBonusForAll			(false );
	LimitPlayerMarkerRadius			(T_DIST);
	DisableInteriorEnterExits		();
	ManualVehicleEngineAndLights	();

	RegisterAlt("/c",		"/close");
	RegisterAlt("/shout",	"/s");
	RegisterAlt("/p",		"/pickup");
	RegisterAlt("/h",		"/hangup");
	RegisterAlt("/a",		"/admin");
	RegisterAlt("/pm",		"/w");
	RegisterAlt("/tp",		"/tplist");
	RegisterAlt("/gl",		"/givelicense");
	RegisterAlt("/sl",		"/showlicenses");
	RegisterAlt("/pas",		"/pasport");
	RegisterAlt("/vopros",	"/вопрос");
	RegisterAlt("/givegun",	"/ggun");

	for(new i; i < MAX_FRAC; i++) {
		FracPay[i] = 0;
		GangOnBattle[i] = INVALID_BIZ_ID;
	}

	ValidText = regex_build("[а-€ј-яa-zA-Z0-9_,!\\.\\?\\-\\+\\(\\)\\ ]+");
	ValidRPName = regex_build("([A-Z]{1,1})[a-z]{2,9}+_([A-Z]{1,1})[a-z]{2,9}");
	//ADBlock = regex_build("(((\\w+):\\/\\/)|(www\\.|\\,|))+(([\\w\\.\\,_-]{2,}(\\.|\\,)[\\w]{2,6})|(([\\d]{1,3}(\\b))(\\s+|)(\\.|\\,|\\s)(\\s+|)[\\d]{1,3}(\\s+|)(\\.|\\,|\\s)(\\s+|)[\\d]{1,3}(\\s+|)(\\.|\\,|\\s)(\\s+|)[\\d]{1,3}))(((\\s+|)(\\:|\\;|\\s)(\\s+|)[\\d\\s]{2,}(\\b))|\\b)(\\/[\\w\\&amp\\;\\%_\\.\\/\\-\\~\\-]*)?");

	new m, s;
	gettime(ghour, m, s);
	FixHour(ghour);
	ghour = shifthour;
	SetWorldTime(ghour);
	SetWeather(1 + random(5));

	SetGameModeText(Gm::Info[Gm::Mode]);
	format(temp, sizeof temp, "mapname %s", Gm::Info[Gm::Map]), SendRconCommand(temp);
	SendRconCommand("weburl "#__SERVER_SITE"");

	if(Gm::Info[Gm::Status] == 1) {
		format(temp, sizeof temp, "hostname %s (private)", Gm::Info[Gm::Hostname]), SendRconCommand(temp);
		format(temp, sizeof temp, "password %s", Gm::Info[Gm::Password]), SendRconCommand(temp);
	} else {
		format(temp, sizeof temp, "hostname %s", Gm::Info[Gm::Hostname]), SendRconCommand(temp);
	}

	serverUpdate = SetTimer(""#Gm::"Thread", SEC_TIMER, true);

	debug("OnGameModeInit() - Ok! Run time: %i (ms)", GetTickCount()-time);

	return 1;
}

public OnGameModeExit() {
	DestroyAllDynamicCPs();
	DestroyAllDynamicAreas();
	DestroyAllDynamicRaceCPs();
	DestroyAllDynamicObjects();
	DestroyAllDynamicPickups();
	DestroyAllDynamicMapIcons();
	DestroyAllDynamic3DTextLabels();

	regex_delete_all();

	for(;;) if(0 >= Db::unprocessed_queries(connDb)) break;
	Db::close(connDb);

	print(" ");
	print(">> "#__GamemodeName__" "#__GamemodeVersion__" unloaded!");
	print(">> "#__GamemodeCopyright__"");
	print(" ");

	return 1;
}

public: GameModeInitExitFunc(mode) {
	Gm::Info[Gm::isAutoRest] = mode;
	SetGameModeText("RESTART");
	SendRconCommand("hostname rebooting...");

	if(mode) SendToAll(COLOR_LIGHTRED, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬се были кикнуты, причина: –естарт сервера");

	foreach(new p : Player) {
		if(Pl::isLogged(p)) {
			DeleteAllAttachedObject(p);
			GameTextForPlayer(p, "~b~] ~w~PECTAPT CEPBEPA ~b~]", 4000, 5);
			Rac::SetPlayerInterior(p, 0);
			Rac::SetPlayerVirtualWorld(p, 0);
			SetPlayerCameraPos(p, 1460.0, -1324.0, 287.2);
			SetPlayerCameraLookAt(p, 1374.5, -1291.1, 239.0);

			Pl::Update(p);
			PlayerLogged{p} = false;
			SetPlayerColor(p, COLOR_GRAD2);
			if(mode) Kick(p);
		}
	}
	KillTimer(serverUpdate);

	switch(mode) {
	case 1: {
			Bl::Clear();
			Checkprop();
			UpdateProp();
			SetTimer("GameModeExitFunc", 1000*60, 0);
		}
	default: {
			UpdateProp();
			SetTimer("GameModeExitFunc", 10000, 0);
		}
	}

	return 1;
}

public: GameModeExitFunc() {
	if(Gm::Info[Gm::isAutoRest]) {
		SendRconCommand("exit");
	} else {
		SendRconCommand("gmx");
	}
	return 1 ;
}

/*public: OnPlayerAFK(playerid, newstate, oldstate) {
	switch(newstate) {
	case 1 : {
			new fracid = Pl::FracID(playerid);
			new biz = GangOnBattle[fracid];
			if(biz != INVALID_BIZ_ID) {
				if(IsPlayerInDynamicArea(playerid, BizzInfo[biz][bZahvatArea])) {
					new attack = BizzInfo[biz][bAttack];
					new defend = BizzInfo[biz][bDefend];
					if(fracid == defend && GangSolderCount[attack] > 0) {
						ZahvatScore[attack] ++;
						BizzInfo[biz][bFrac] = attack;
						GiveGangRespect(attack, ZahvatScore[attack]);
						Gz::StopFlashForAll(BizzInfo[biz][bZone]);
						Gz::HideForAll(BizzInfo[biz][bZone]);
						Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
						format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(attack), ZahvatScore[attack]);
						GameTextForGangs(temp, 6000, 1);
						format(temp, sizeof temp, "[GANG NEWS] %s[%d] захватили территорию бизнеса %s, %s[%d] повержены!",
						GetGangName(attack), ZahvatScore[attack], BizzInfo[biz][bDescription], GetGangName(defend), ZahvatScore[defend]);
						sendToTeam(GetFracColor(attack), temp, Gangs);
					}

					else {
						ZahvatScore[defend] ++;
						GiveGangRespect(defend, ZahvatScore[defend]);
						Gz::StopFlashForAll(BizzInfo[biz][bZone]);
						Gz::HideForAll(BizzInfo[biz][bZone]);
						Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
						format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
						GameTextForGangs(temp, 6000, 1);
						format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию своего бизнеса %s, %s[%d] повержены!",
						GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
						sendToTeam(GetFracColor(defend), temp, Gangs);
					}

					ZahvatKills{attack} = ZahvatKills{defend} = 0;
					ZahvatScore[defend] = ZahvatScore[defend] = 0;

					GangSolderCount[attack] = GangSolderCount[defend] = 0;
					GangOnBattle[attack] = GangOnBattle[defend] = INVALID_BIZ_ID;
					BizzInfo[biz][bAttack] = BizzInfo[biz][bDefend] = 0;
					BizzInfo[biz][bOnBattle] = 0;
					DisableZahvatMapIcon(attack, defend);
					Td::HideForAll(BizzInfo[biz][bZahvatTD]);
					Td::Destroy(BizzInfo[biz][bZahvatTD]);
					DestroyDynamicArea(BizzInfo[biz][bZahvatArea]);
					KillTimer(BizzInfo[biz][bZahvatTimer]);
					UpdateBizz(biz);
					UpdateGangInfo();
				}
			}
		}
	}
	return 1;
}*/

public: onZahvatBizz(biz, attack, defend) {
	if(BizzInfo[biz][bZahvatTime] != 0) {
		BizzInfo[biz][bZahvatTime]--;
		foreach(new p : TeamPlayers[attack]) {
			format(temp, sizeof temp, "~r~%i", BizzInfo[biz][bZahvatTime]);
			Td::SetString(BizzInfo[biz][bZahvatTD], temp), Td::ShowForPlayer(p, BizzInfo[biz][bZahvatTD]);
		}
		foreach(new p : TeamPlayers[defend]) {
			format(temp, sizeof temp, "~r~%i", BizzInfo[biz][bZahvatTime]);
			Td::SetString(BizzInfo[biz][bZahvatTD], temp), Td::ShowForPlayer(p, BizzInfo[biz][bZahvatTD]);
		}
	} else {
		if((GangSolderCount[defend] == 0 && GangSolderCount[attack] > 0) && (!ZahvatKills{attack} && !ZahvatKills{defend})) {
			ZahvatScore[attack] += GangSolderCount[attack];
			GiveGangRespect(attack, ZahvatScore[attack]);

			GangBiznes{attack} ++;
			GangBiznes{defend} --;
			BizzInfo[biz][bFrac] = attack;
			Gz::StopFlashForAll(BizzInfo[biz][bZone]);
			Gz::HideForAll(BizzInfo[biz][bZone]);
			Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
			format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(attack), ZahvatScore[attack]);
			GameTextForGangs(temp, 6000, 1);
			format(temp, sizeof(temp), "[GANG NEWS] %s[%d] вз€ли территорию бизнеса %s без бо€, %s[%d] повержены!",
			GetGangName(attack), ZahvatScore[attack], BizzInfo[biz][bDescription], GetGangName(defend), ZahvatScore[defend]);
			sendToTeam(GetFracColor(attack), temp, Gangs);

		} else if(!ZahvatKills{attack} && !ZahvatKills{defend}) {
			ZahvatScore[defend] += GangSolderCount[defend];
			GiveGangRespect(defend, ZahvatScore[defend]);
			BizzInfo[biz][bFrac] = defend;
			Gz::StopFlashForAll(BizzInfo[biz][bZone]);
			Gz::HideForAll(BizzInfo[biz][bZone]);
			Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
			format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
			GameTextForGangs(temp, 6000, 1);
			format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию бизнеса %s без бо€, %s[%d] повержены!",
			GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
			sendToTeam(GetFracColor(defend), temp, Gangs);

		} else {
			new totalscore = (ZahvatScore[attack] - ZahvatScore[defend]);
			if(totalscore == 0) {
				if(ZahvatKills{attack} < ZahvatKills{defend}) {
					BizzInfo[biz][bFrac] = defend;
					Gz::StopFlashForAll(BizzInfo[biz][bZone]);
					Gz::HideForAll(BizzInfo[biz][bZone]);
					Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
					GiveGangRespect(defend, ZahvatScore[defend]);
					format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
					GameTextForGangs(temp, 6000, 1);
					format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию своего бизнеса %s, %s[%d] повержены!",
					GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
					sendToTeam(GetFracColor(defend), temp, Gangs);

				} else if(ZahvatKills{attack} > ZahvatKills{defend}) {
					GangBiznes{attack} ++;
					GangBiznes{defend} --;
					BizzInfo[biz][bFrac] = attack;
					Gz::StopFlashForAll(BizzInfo[biz][bZone]);
					Gz::HideForAll(BizzInfo[biz][bZone]);
					Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
					format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(attack), ZahvatScore[attack]);
					GameTextForGangs(temp, 6000, 1);
					format(temp, sizeof(temp), "[GANG NEWS] %s[%d] захватили территорию бизнеса %s, %s[%d] повержены!",
					GetGangName(attack), ZahvatScore[attack], BizzInfo[biz][bDescription], GetGangName(defend), ZahvatScore[defend]);
					sendToTeam(GetFracColor(attack), temp, Gangs);

				} else {
					BizzInfo[biz][bFrac] = defend;
					GiveGangRespect(defend, ZahvatScore[defend]);
					Gz::StopFlashForAll(BizzInfo[biz][bZone]);
					Gz::HideForAll(BizzInfo[biz][bZone]);
					Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
					format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
					GameTextForGangs(temp, 6000, 1);
					format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию своего бизнеса %s, %s[%d] повержены!",
					GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
					sendToTeam(GetFracColor(defend), temp, Gangs);
				}

			} else if(totalscore < 0) {
				BizzInfo[biz][bFrac] = defend;
				GiveGangRespect(defend, ZahvatScore[defend]);
				Gz::StopFlashForAll(BizzInfo[biz][bZone]);
				Gz::HideForAll(BizzInfo[biz][bZone]);
				Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
				format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
				GameTextForGangs(temp, 6000, 1);
				format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию своего бизнеса %s, %s[%d] повержены!",
				GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
				sendToTeam(GetFracColor(defend), temp, Gangs);

			} else if(totalscore > 0) {
				GangBiznes{attack} ++;
				GangBiznes{defend} --;
				BizzInfo[biz][bFrac] = attack;
				GiveGangRespect(attack, ZahvatScore[attack]);
				Gz::StopFlashForAll(BizzInfo[biz][bZone]);
				Gz::HideForAll(BizzInfo[biz][bZone]);
				Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
				format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(attack), ZahvatScore[attack]);
				GameTextForGangs(temp, 6000, 1);

				format(temp, sizeof(temp), "[GANG NEWS] %s[%d] захватили территорию бизнеса %s, %s[%d] повержены!",
				GetGangName(attack), ZahvatScore[attack], BizzInfo[biz][bDescription], GetGangName(defend), ZahvatScore[defend]);
				sendToTeam(GetFracColor(attack), temp, Gangs);
			}
		}

		ZahvatKills{attack} = ZahvatKills{defend} = 0;
		ZahvatScore[defend] = ZahvatScore[defend] = 0;

		GangOnBattle[attack] = GangOnBattle[defend] = INVALID_BIZ_ID;
		BizzInfo[biz][bAttack] = BizzInfo[biz][bDefend] = 0;
		BizzInfo[biz][bOnBattle] = 0;
		DisableZahvatMapIcon(attack, defend);
		Td::HideForAll(BizzInfo[biz][bZahvatTD]);
		Td::Destroy(BizzInfo[biz][bZahvatTD]);
		DestroyDynamicArea(BizzInfo[biz][bZahvatArea]);
		KillTimer(BizzInfo[biz][bZahvatTimer]);
		UpdateBizz(biz);
		UpdateGangInfo();
	}
}


stock IsInRespawn(fracid, vehid) {
	for(new i; i < sizeof RespCoord; i++) {
		if(VehicleToKvadrat(vehid, RespCoord[i][rMinX], RespCoord[i][rMinY], RespCoord[i][rMaxX], RespCoord[i][rMaxY]) && fracid == RespCoord[i][fId]) return 1;
	}
	return 0;
}

stock ClearMarriage(playerid) // развод
{
	strmid(Pl::Info[playerid][pMarriedTo], "No-one", 0, strlen("No-one"), 25);
	Pl::Info[playerid][pMarried] = 0;
}

stock UnJail(playerid, type)
{
	Pl::Info[playerid][pJailed] = 0;
	Pl::Info[playerid][pJailTime] = 0;
	SetPlayerSkin(playerid, TempSkin[playerid]);
	switch(type) {
	case 1: {
			Rac::SetPlayerInterior(playerid, 6);
			Rac::SetPlayerVirtualWorld(playerid, 1);
			Rac::SetPlayerFacingAngle(playerid, 180.4);
			Rac::SetPlayerPos(playerid,246.5,67.5,1003.6);
			Send(playerid,COLOR_LIGHTRED,"¬ы были выпушены из тюрьмы!");
		}
	case 2: {
			SetPlayerWorldBounds(playerid, 20000.0000, -20000.0000, 20000.0000, -20000.0000);
			Rac::SetPlayerVirtualWorld(playerid, 0);
			Rac::SetPlayerInterior(playerid, 0);
			Rac::SetPlayerPos(playerid, 1552.9265,-1675.9987,16.1953);
		}
	default:
		{
			Rac::SetPlayerInterior(playerid, 6);
			Rac::SetPlayerVirtualWorld(playerid, 1);
			Rac::SetPlayerFacingAngle(playerid,180.4);
			Rac::SetPlayerPos(playerid,246.5,67.5,1003.6);
			Send(playerid,COLOR_LIGHTRED,"¬ы были выпушены из тюрьмы!");
		}
	}
	Pl::SetSpawnInfo(playerid);
	return 1;
}

stock CrimInRange(Float:radi, playerid, copid) {
	if(Pl::isLogged(playerid) && Pl::isLogged(copid)) {
		GetPlayerPos(copid, posx, posy, posz);
		return (radi >= GetPlayerDistanceFromPoint(playerid, posx, posy, posz));
	}
	return 0;
}

stock IsPlayerInRangeOfPlayer(playerid, Float:radi, targetid) {
	new Float:x, Float:y, Float:z;
	GetPlayerPos(targetid, x, y, z);
	return IsPlayerInRangeOfPoint(playerid, radi, x, y, z);
}

stock IsPlayerInRangeOfObject(playerid, Float:radi, objectid, bool:dynamic=false) {
	new Float:x, Float:y, Float:z;
	if(dynamic) {
		GetDynamicObjectPos(objectid, x, y, z);
	} else {
		GetObjectPos(objectid, x, y, z);
	}
	return IsPlayerInRangeOfPoint(playerid, radi, x, y, z);
}

stock ProxDetector(Float:radi, playerid, const message[], col1=COLOR_FADE1, col2=COLOR_FADE2, col3=COLOR_FADE3, col4=COLOR_FADE4, col5=COLOR_FADE5) {
	new Float:x, Float:y, Float:z, Float:dist;
	new playerint = GetPlayerInterior(playerid);
	new playervirt = GetPlayerVirtualWorld(playerid);
	GetPlayerPos(playerid, x, y, z);
	Send(playerid, col1, message);

	foreach(new i : inStreamPlayers[playerid]) {
		dist = GetPlayerDistanceFromPoint(i, x, y, z);
		if(!BigEar[i]) {
			if(radi >= dist) {
				if(GetPlayerInterior(i) == playerint && GetPlayerVirtualWorld(i) == playervirt) {
					if(dist < (radi/16)) Send(i, col1, message);
					else if(dist < (radi/8)) Send(i, col2, message);
					else if(dist < (radi/6)) Send(i, col3, message);
					else if(dist < (radi/4)) Send(i, col4, message);
					else if(dist < (radi/2)) Send(i, col5, message);
				}
			}
		} else {
			Send(i, col1, message);
		}
	}
}

stock SendToAdmin(color, string[], lvl = 1, log = 0) {
	foreach(new i : AdminPlayers) {
		if(Pl::isAdmin(i, lvl)) {
			Send(i, color, string);
		}
	}
	switch(log) {
	case 0: SendLog(LOG_ANTICHEAT, string);
	case 1: SendLog(LOG_ANTICHEAT, string);
	case 2: SendLog(LOG_REPORT, string);
	case 3: SendLog(LOG_ADMWARN, string);
	case 4: SendLog(LOG_PAYDAY_STATS, string);
	case 5: SendLog(LOG_MYSQL_ERROR, string);
	}
	return 1;
}

stock SendToHelper(color, string[], lvl = 1) {
	foreach(new i : HelperPlayers) if(IsPHelper(i, lvl) && IsAHelperDuty(i)) Send(i, color, string);
	SendLog(LOG_HELPER_CHAT, string);
}

stock SendToLeader(color, string[]) {
	foreach(new i : LeaderPlayers) Send(i, color, string);
	SendLog("leaderchat", string);
}

stock EmptyMessage(playerid, rows) {
	while(rows--) {
		SendClientMessage(playerid, -1, " ");
	}
	return ;
}

stock EmptyMessageToAll(rows) {
	while(rows--) {
		SendToAll(COLOR_WHITE, " ");
	}
}

stock OOCOff(color, const string[]) {
	foreach(new i: Player) {
		if(Pl::isLogged(i)) {
			if(gOoc[i]) {
				Send(i, color, string);
			}
		}
	}
}

stock OOCNews(color, const string[]) {
	foreach(new i: Player) {
		if(Pl::isLogged(i)) {
			if(gNews[i]) {
				Send(i, color, string);
			}
		}
	}
	return ;
}

stock sendToTeam(color, const message[], forteam[] = { -1 }, size = sizeof forteam) {
	if(forteam[0] != -1) {
		for(new j; j < size; j++) {
			foreach(new i: TeamPlayers[forteam[j]]) {
				Send(i, color, message);
			}
		}
	} else {
		for(new j; j < MAX_FRAC; j++) {
			foreach(new i: TeamPlayers[j]) {
				Send(i, color, message);
			}
		}
	}
}

stock sendToFamily(family, color, const string[]) {
	foreach(new i: TeamPlayers[family]) {
		if(gFam[i]) {
			Send(i, color, string);
		}
	}
}

stock sendToFrac(fracid, color, const string[]) {
	foreach(new playerid: TeamPlayers[fracid]) {
		Send(playerid, color, string);
	}
}

stock sendToLog(color, const string[]) {
	foreach(new i: ToglogPlayers) {
		Send(i, color, string);
	}
	return 1;
}

stock SendJobMessage(job, color, const string[]) {
	foreach(new i: JobPlayers[job]) {
		Send(i, color, string);
	}
	return 1;
}

stock SendZahvatMessage(attack, defend, color, const string[]) {
	foreach(new i: TeamPlayers[attack]) Send(i, color, string);
	foreach(new i: TeamPlayers[defend]) Send(i, color, string);
}

stock PlayerPlayMusic(playerid) {
	if(IsPlayerConnected(playerid)) {
		Fixr{playerid} = 5;
		PlayerPlaySound(playerid, 1068, 0.0, 0.0, 0.0);
	}
}

stock PlayerFixRadio(playerid) {
	if(IsPlayerConnected(playerid)) {
		Fixr{playerid} = 1;
		PlayerPlaySound(playerid, 1068, 0.0, 0.0, 0.0);
	}
}

stock playerSpectateUpdate(i) {
	static string[128];
	static targetid, Float:sphealth;

	targetid = Pl::SpecInfo[i][pSpecID];
	if(targetid != INVALID_PLAYER_ID) {
		if(Pl::isLogged(targetid)) {
			Pl::SpecInfo[targetid][pSpecVw]		[0] = GetPlayerVirtualWorld(targetid);
			Pl::SpecInfo[targetid][pSpecInt]	[0] = GetPlayerInterior(targetid);
			Pl::SpecInfo[targetid][pSpecState]	[0] = GetPlayerState(targetid);
			GetPlayerName(targetid, plname, 24);

			if(Pl::isAdmin(i, 1)) {
				GetPlayerHealth(targetid, sphealth);
				format(string, sizeof(string), "~g~%s (ID:%i) ~r~HP:%.1f~n~~w~$:%d ~r~DRUGS:%i WARNS:%i",
				plname, targetid, sphealth, Rac::GetPlayerMoney(targetid), Pl::Info[targetid][pDrugs], Pl::Info[targetid][pWarns]);
				Pt::SetString(i, Pt::Spec[i], string);
			} else {
				format(string, sizeof(string), "~y~%s[%i]", plname, targetid);
				Pt::SetString(i, Pt::Spec[i], string);
			}

			if(Pl::SpecInfo[targetid][pSpecState][0] != Pl::SpecInfo[targetid][pSpecState][1]) {
				Pl::SpecInfo[targetid][pSpecState][1] = Pl::SpecInfo[targetid][pSpecState][0];
				switch(Pl::SpecInfo[targetid][pSpecState][0]) {
				case 2, 3 : {
						PlayerSpectateVehicle(i, GetPlayerVehicleID(targetid), SPECTATE_MODE_NORMAL);
					}
					default : {
						PlayerSpectatePlayer(i, targetid, SPECTATE_MODE_NORMAL);
					}
				}
			}

			if(Pl::SpecInfo[targetid][pSpecInt][0] != Pl::SpecInfo[targetid][pSpecInt][1]) {
				Pl::SpecInfo[targetid][pSpecInt][1] = Pl::SpecInfo[targetid][pSpecInt][0];
				Rac::SetPlayerInterior(i, Pl::SpecInfo[targetid][pSpecInt][0]);
			}

			if(Pl::SpecInfo[targetid][pSpecVw][0] != Pl::SpecInfo[targetid][pSpecVw][1]) {
				Pl::SpecInfo[targetid][pSpecVw][1] = Pl::SpecInfo[targetid][pSpecVw][0];
				Rac::SetPlayerVirtualWorld(i, Pl::SpecInfo[targetid][pSpecVw][0]);
			}
		} else {
			MedicBill[i] = false;
			WatchingTV[i] = false;
			Pt::Hide(i, Pt::Spec[i]);
			Pl::SpecInfo[i][pSpecID] = INVALID_PLAYER_ID;
			Rac::TogglePlayerControllable(i, 1);
			Rac::TogglePlayerSpectating(i, false);
			GameTextForPlayer(i, "~w~                TV~n~~r~                Off", 5000, 6);
			PlayerPlaySound(i, 1145, 0.0, 0.0, 0.0);
			Pl::SetSpawnInfo(i);
			Rac::SpawnPlayer(i);
		}
	}

	targetid = Bl::Info[i][Bl::Observe];
	if(targetid != INVALID_PLAYER_ID) {
		if(IsPlayerStreamedIn(targetid, i)) {
			switch(GetPlayerState(targetid)) {
			case PLAYER_STATE_ONFOOT : {
					GetPlayerPos(targetid, posx, posy, posz);
					Streamer::SetFloatData(STREAMER_TYPE_CP, Bl::Info[i][Bl::Marker], E_STREAMER_X, posx);
					Streamer::SetFloatData(STREAMER_TYPE_CP, Bl::Info[i][Bl::Marker], E_STREAMER_Y, posy);
					Streamer::SetFloatData(STREAMER_TYPE_CP, Bl::Info[i][Bl::Marker], E_STREAMER_Z, posz);
				}
			}
		} else {
			Bl::Info[i][Bl::Observe] = INVALID_PLAYER_ID;
			if(Bl::Info[targetid][Bl::Finder] == i) {
				Bl::Info[targetid][Bl::Finder] = INVALID_PLAYER_ID;
			}
			switch(GetPlayerState(targetid)) {
			case PLAYER_STATE_ONFOOT : {
					DestroyDynamicCP(Bl::Info[i][Bl::Marker]);
				}

			case PLAYER_STATE_DRIVER, PLAYER_STATE_PASSENGER : {
					new vehid = GetPlayerVehicleID(targetid);
					GetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, objective);
					if(objective > 0) {
						new count;
						foreach(new passenger: vehiclePassengers[vehid]) {
							if(Bl::Info[passenger][Bl::Finder] != INVALID_PLAYER_ID) {
								count ++;
							}
						}
						if(!count) {
							SetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, false);
						}
					}
				}
			}
		}
	}

	return 1;
}

stock IsAtBar(playerid) {
	if(Pl::isLogged(playerid)) {
		for(new i; i < sizeof(BarCoord); i ++) {
			if(IsPlayerInRangeOfPoint(playerid, BarCoord[i][0], BarCoord[i][1], BarCoord[i][2], BarCoord[i][3])) return true;
		}
	}
	return false;
}

stock Pl::isAdmin(playerid, lvl) {
	if(Rac::isValidPlayer(playerid)) {
		if(Pl::Info[playerid][pAdmin] >= lvl) {
			if(AdminDuty[playerid] || Pl::Info[playerid][pAdmin] == ADMINISTRATOR) {
				return 1;
			}
		}
	}
	return 0;
}


public OnPlayerConnect(playerid) {
	if(IsPlayerNPC(playerid)) {
		PlayerLogged{playerid} = true;
		return 1;
	}

	static playerIp[MAX_PLAYERS][16];

	new ip[16], currtime = gettime();
	GetPlayerIp(playerid, ip, 16);
	if(slotused{playerid} && strcmp(playerIp[playerid], ip, false) == 0) {
		return Rac::Ban(playerid, "‘луд коннектами");
	}
	if(currtime-timeleft[playerid] < 5) {
		if(strcmp(playerIp[playerid], ip, false) == 0) {
			Send(playerid, COLOR_LIGHTRED, "* ѕерезаходить можно не менее чем через 5 секунд!");
			return Kick(playerid);
		}
	}
	timermc[playerid] = 0;
	slotused{playerid} = true;
	strmid(playerIp[playerid], ip, 0, strlen(ip), 16);

	if(Gm::Info[Gm::isAutoRest]) {
		ShowDialog(playerid, D_NONE, 0, "RESTART", "dialog/srv_restart.txt", "OK","");
		Kick(playerid);
	} else {
		Pl::Init(playerid);
		Bl::Init(playerid);
		Pl::RemoveWorldModel(playerid);

		Pt::Init(playerid);
		ClearCrime(playerid);

		ForceClassSelection(playerid);
		Rac::TogglePlayerSpectating(playerid, true);
		Rac::TogglePlayerSpectating(playerid, false);

		format(dialog, sizeof dialog, "ƒождитесь полной загрузки игры и нажмите ENTER!\n\
		ќсталось секунд: %i", Pl::Info[playerid][pWait]);
		SPD(playerid, D_WAIT, 0, "ѕодождите...", dialog, "ENTER", "");
	}
//----------------------- дл€ свадьбы ------------------------------------------
	MarriageCeremoney[playerid] = 0;
	DivorceOffer[playerid] = INVALID_PLAYER_ID;
	GotProposedBy[playerid] = INVALID_PLAYER_ID;
	ProposedTo[playerid] = INVALID_PLAYER_ID;
	ProposeOffer[playerid] = INVALID_PLAYER_ID; // свадьба
	MarryWitness[playerid] = INVALID_PLAYER_ID; // свидетель
	MarryWitnessOffer[playerid] = INVALID_PLAYER_ID; // свидетель
	sFlood[playerid] = 0;
	Flood[playerid] = 0;
	fishes[playerid] = 0;
	fishkg[playerid][1] = 0;
	fishkg[playerid][2] = 0;
	fishkg[playerid][3] = 0;
	fishkg[playerid][4] = 0;
	fishkg[playerid][5] = 0;
	strmid(strfish[playerid][1], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][2], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][3], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][4], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][5], "ѕусто", 0, strlen("ѕусто"), 255);
	RemoveBuildingForPlayer(playerid, 11371, -2028.1328, -111.2734, 36.1328, 0.25);
	RemoveBuildingForPlayer(playerid, 11372, -2076.4375, -107.9297, 36.9688, 0.25);
	RemoveBuildingForPlayer(playerid, 1497, -2029.0156, -120.0625, 34.2578, 0.25);
	RemoveBuildingForPlayer(playerid, 11015, -2028.1328, -111.2734, 36.1328, 0.25);
	RemoveBuildingForPlayer(playerid, 11014, -2076.4375, -107.9297, 36.9688, 0.25);
	RemoveBuildingForPlayer(playerid, 1532, -2025.8281, -102.4688, 34.2734, 0.25);
	//
	RemoveBuildingForPlayer(playerid, 968, -1526.4375, 481.3828, 6.9063, 0.25);
	RemoveBuildingForPlayer(playerid, 966, -1526.3906, 481.3828, 6.1797, 0.25);
	return 1;
}

public OnPlayerDisconnect(playerid, reason) {
	slotused{playerid} = false;
	timeleft[playerid] = gettime();
	if(!Pl::isLogged(playerid)) return 1;

	foreach(new i: Player) {
		if(Pl::isLogged(i)) {
			if(TaxiAccepted[i] != INVALID_PLAYER_ID) {
				if(TaxiAccepted[i] == playerid) {
					TaxiAccepted[i] = INVALID_PLAYER_ID;
					TaxiCallTime[i] = 0;
					DestroyDynamicCP(checkpoints[i]);
					GameTextForPlayer(i, "~w~Taxi Caller~n~~r~Left the game", 5000, 1);
				}
			} else if(BusAccepted[i] != INVALID_PLAYER_ID) {
				if(BusAccepted[i] == playerid) {
					BusAccepted[i] = INVALID_PLAYER_ID;
					BusCallTime[i] = 0;
					DestroyDynamicCP(checkpoints[i]);
					GameTextForPlayer(i, "~w~Bus Caller~n~~r~Left the game", 5000, 1);
				}
			}
		}
	}

	switch(TransportDuty[playerid]) {
	case 1 : TaxiDrivers --;
	case 2 : BusDrivers  --;
	}

	if(Pl::Info[playerid][pJob] == 6 && OnDuty[playerid]) {
		Mechanics --;
	}

	AFKInfo[playerid][afk_State] = 0;
	AFKInfo[playerid][afk_Time][0] = 0;
	Delete3DTextLabel(AFKInfo[playerid][afk_Text]);

	Pl::Info[playerid][pMuted] = 0;
	Pl::Info[playerid][pMutedTime] = 0;
	if(TransportCost[playerid] > 0 && TransportDriver[playerid] != INVALID_PLAYER_ID) {
		new driver = TransportDriver[playerid];
		if(Pl::isLogged(driver)) {
			TransportMoney[driver] += TransportCost[playerid];
			TransportTime[driver] = 0;
			TransportCost[driver] = 0;
			format(temp, sizeof(temp), "~w~Passenger left~n~~g~Earned $%d", TransportCost[playerid]);
			GameTextForPlayer(driver, temp, 5000, 1);
		}
	}

	if(HireCar[playerid] != INVALID_VEHICLE_ID) {
		ToggleVehicleDoor(HireCar[playerid], true);
	}

	if(gLastCar[playerid] != INVALID_VEHICLE_ID) {
		Iter::Remove(vehiclePassengers[gLastCar[playerid]], playerid);
		if(Bl::Info[playerid][Bl::Finder] != INVALID_PLAYER_ID) {
			GetVehicleParamsEx(gLastCar[playerid], engine, light, alarm, doors, bonnet, boot, objective);
			SetVehicleParamsEx(gLastCar[playerid], engine, light, alarm, doors, bonnet, boot, false);
		}
	}

	if(PlayerObject[playerid] != INVALID_OBJECT_ID) {
		DestroyObject(PlayerObject[playerid]);
	}

	foreach(new i : ExtraVehicles[playerid]) {
		Veh::Destroy(ExtraVehicles[playerid][i][evID2]);
	}

	AshQueue(playerid, 1);
	Del_Of_Iterator(playerid);

	Pl::Update(playerid);
	DeleteAllAttachedObject(playerid);
	PlayerLogged{playerid} = false;

	DestroyDynamicCP(checkpoints[playerid]);
	DestroyDynamicCP(Bl::Info[playerid][Bl::Marker]);
	DestroyDynamicRaceCP(checkpointb[playerid]);
	DestroyDynamicPickup(pickupd[playerid][0]);
	DestroyDynamicMapIcon(pickupd[playerid][1]);

	static rsn[][] = { "ќбрыв св€зи", "¬ышел", " икнут", "unknown"};
	format(temp, sizeof temp, "* %s (ID: %i) сбежал(а) с ..::"#__SERVER_PREFIX""#__SERVER_NAME_LC"::.. [RUS]. (%s)", GetName(playerid), playerid, (0<=reason<=2)?(rsn[reason]):(rsn[3]));
	sendToLog(COLOR_GREY, temp);

	return 1;
}

public OnVehicleSpawn(vehicleid) {
	if(AutoInfo[vehicleid][aOwner] != INVALID_PLAYER_ID) {
		if(AutoInfo[vehicleid][aOwner] > INVALID_PLAYER_ID) {
			new house = AutoInfo[vehicleid][aOwner] / INVALID_PLAYER_ID;
			if(IsValidHouse(house)) {
				if(HouseInfo[house][hAuto] == vehicleid && HouseInfo[house][hvPark] == HOME_VEHICLE) {
					LinkVehicleToInterior(vehicleid, 3);
					SetVehicleVirtualWorld(vehicleid, house);
				}
			}
		} else {
			new slot = GetIdxExtraVehicleFromVehicleID(AutoInfo[vehicleid][aOwner], vehicleid);
			if(slot != -1) {
				new owner = AutoInfo[vehicleid][aOwner];
				if(ExtraVehicles[owner][slot][evPark] == PARK_GARAGE) {
					Veh::Destroy(ExtraVehicles[AutoInfo[vehicleid][aOwner]][slot][evID2]);
				}

				else if((ExtraVehicles[owner][slot][evPark] / Pl::Info[owner][pHouseKey]) == PARK_HOME_GARAGE) {
					LinkVehicleToInterior(vehicleid, 3);
					SetVehicleVirtualWorld(vehicleid, Pl::Info[owner][pHouseKey]);
				}
			}
		}
	}

	Rac::RepairVehicle(vehicleid);
	if(AutoInfo[vehicleid][aFuel] < 1.0) {
		AutoInfo[vehicleid][aFuel] = 10.0;
	}
	if(isEngined{vehicleid}) {
		ToggleVehicleEngine(vehicleid, 0);
	}
	AddTuning(vehicleid);
	return 1;
}

public OnVehicleDeath(vehicleid, killerid) {
	new Float:x, Float:y, Float:z;
	GetVehicleRotation(vehicleid, x, y, z);
	if((y < 90 && y > -90) && gLastCar[killerid] != vehicleid && killerid != INVALID_PLAYER_ID) {
		Rac::Kick(killerid, "”ничтожении тачек читами");
	}
	return 1;
}

public OnPlayerDeath(playerid, killerid, reason) {
	if(playerid == killerid) {
		return Rac::Kick(playerid, "SelfKill");
	} else if(reason != 255) {
		if(reason < 47) {
			return Rac::Kick(playerid, "FakeKill");
		}
	} else {
		killerid = SyncInfo[playerid][sKillerID];
		reason = SyncInfo[playerid][sReasonID];
		SyncInfo[playerid][sKillerID] = INVALID_PLAYER_ID;
		SyncInfo[playerid][sReasonID] = 255;
	}

	if(Pl::isLogged(killerid)) {
		new killername[24], playername[24];
		new killerfrac = Pl::FracID(killerid), playerfrac = Pl::FracID(playerid);
		getname(killerid -> killername,playerid -> playername);

		new Float:x, Float:y, Float:z;
		GetPlayerPos(playerid, x, y, z);
		if(IsPlayerInRangeOfPoint(killerid, 50.0, x, y, z)) {
			if(Rac::GetPlayerState(killerid) == 2 && (reason == WEAPON_UZI || reason == WEAPON_MP5 || reason == WEAPON_TEC9)) {
				format(temp, sizeof(temp),"[античит] * %s(%i) только, что совершил ƒЅ. ∆ертва:(%i)%s", killername, killerid, playerid, playername);
				SendToAdmin(COLOR_NEWS, temp, 1, 1);
			}
		} else if(!IsPlayerStreamedIn(playerid, killerid)) {
			return Rac::Kick(playerid, "FakeKill");
		}

		if(reason == WEAPON_MINIGUN) {
			format(temp, sizeof(temp), "[античит] * %s[%i] только что убил игрока миниганом.", killername, killerid);
			SendToAdmin(COLOR_YELLOW, temp, 1, 1);
		}

		Pl::Info[killerid][pKills]++;
		if(Pl::Info[playerid][pWantedL] > 0) {
			if(IsACop(killerid)) {
				new jtime	= (Pl::Info[playerid][pWantedL]*3*100);
				new jmoney	= (Pl::Info[playerid][pWantedL]*1000);
				if(CrimInRange(30.0, playerid, killerid)) {
					Rac::GivePlayerMoney(killerid, jmoney);
					Rac::GivePlayerMoney(playerid, -jmoney);
					format(temp, sizeof temp, "~w~Running Suspect~r~Killed~n~Bonus~g~$%d", jmoney);
					GameTextForPlayer(killerid, temp, 5000, 1);
					PlayerPlaySound(killerid, 1058, 0.0, 0.0, 0.0);
				}
				ClearCrime(playerid);
				Pl::Info[playerid][pWantedD] ++;
				SuspectKill[playerid] = true;
				Pl::Info[playerid][pJailTime] = jtime;
				format(temp, sizeof temp, "¬ас убил законник с %d уровнем розыска. ¬ы посажены в тюрьму на %d минуты!", Pl::Info[playerid][pWantedL], jtime/60);
				Send(playerid, COLOR_LIGHTRED, temp);
				format(temp, sizeof temp, "¬ы убили нарушител€ с %d уровнем розыска. ќн посажен в тюрьму на %d минуты!", Pl::Info[playerid][pWantedL], jtime/60);
				Send(killerid, COLOR_LIGHTRED, temp);
			}
		}

		// ”важени€ за убийство при захвате бизнеса
		#define InCapture(%0,%1) ((BizzInfo[%0][bAttack]==%1)||(BizzInfo[%0][bDefend]==%1))
		if(GangOnBattle[killerfrac] != INVALID_BIZ_ID && killerfrac != playerfrac) {
			new biz = GangOnBattle[killerfrac];
			if(BizzInfo[biz][bOnBattle] && IsPlayerInDynamicArea(killerid, BizzInfo[biz][bZahvatArea])) {
				if(!InCapture(biz, playerfrac) && InCapture(biz, killerfrac)) {
					GiveGangRespect(killerfrac, -5);
					format(temp, sizeof temp, "[GANG NEWS] %s[%s] завалил %s[%s] (уважение -5)", killername, GetGangName(killerfrac), playername, GetGangName(playerfrac));
					SendZahvatMessage(BizzInfo[biz][bAttack], BizzInfo[biz][bDefend], GetFracColor(killerfrac), temp);
				}

				else if(!InCapture(biz, killerfrac) && InCapture(biz, playerfrac)) {
					ZahvatDeath[playerid] = 1;
					GiveGangRespect(killerfrac, -50);
					format(temp, sizeof temp, "[GANG NEWS] %s[%s] вмешалс€ в захват бизнеса (уважение -50)", killername, GetGangName(killerfrac));
					SendZahvatMessage(BizzInfo[biz][bAttack], BizzInfo[biz][bDefend], GetFracColor(killerfrac), temp);
					sendToFrac(killerfrac, GetFracColor(killerfrac), temp);
				}

				else if(InCapture(biz, killerfrac) && InCapture(biz, playerfrac)) {
					new rep;
					switch(reason) {
					case 0 									: rep = 5;
					case 22, 23 							: rep = 3;
					case 5, 6, 7, 10, 11, 12, 13, 14, 15	: rep = 10;
						default 								: rep = 1;
					}
					ZahvatDeath[playerid] = 1;
					ZahvatKills{killerfrac} ++;
					ZahvatScore[killerfrac] += rep;
					GiveGangRespect(killerfrac, rep);
					format(temp, sizeof temp, "[GANG NEWS] %s[%s] завалил %s[%s] (уважение +%i)", killername, GetGangName(killerfrac), playername, GetGangName(playerfrac), rep);
					SendZahvatMessage(BizzInfo[biz][bAttack], BizzInfo[biz][bDefend], GetFracColor(killerfrac), temp);
				}
			}
		}

		// Ѕлэклист
		if(Bl::Info[playerid][Bl::onFrac][killerfrac]) {
			Bl::Info[playerid][Bl::isKilled] = true;
			Bl::Info[playerid][Bl::Finder] = INVALID_PLAYER_ID;
			Bl::Info[playerid][Bl::Kills][killerfrac] ++;
			if(Bl::Info[playerid][Bl::Kills][killerfrac] >= FracInfo[killerfrac][fBConf][bKILLS]) {
				Bl::Remove(playerid, killerfrac);
				format(temp, sizeof temp, "[BLACK LIST] %s откупилс€ кровью и был вычеркнут из черного списка %s.", playername, FracInfo[killerfrac][fName]);
				sendToFamily(killerfrac, COLOR_AZTECAS, temp);
				format(temp, sizeof temp, "[BLACK LIST] ¬ы откупились кровью и были вычеркнуты из черного списка %s.", FracInfo[killerfrac][fName]);
				Send(playerid, COLOR_AZTECAS, temp);
			} else {
				Bl::Update(playerid, killerfrac);
				format(temp, sizeof temp, "[BLACK LIST] «аплати или терпи, %s помнит о тебе.", FracInfo[killerfrac][fName]);
				Send(playerid, COLOR_AZTECAS, temp);
				format(temp, sizeof temp, "[BLACK LIST] %s завалил %s.  репись братва, в следующий раз терпила даст монету.", killername, playername);
				sendToFamily(killerfrac, COLOR_AZTECAS, temp);
			}
		}
	} else {
		if(!IsPlayerConnected(killerid) && killerid != INVALID_PLAYER_ID) {
			return Rac::Kick(playerid, "Invalid killerid");
		}
	}

	if(Pl::CheckpointStatus[playerid] > 4 && Pl::CheckpointStatus[playerid] < 11) {
		DestroyDynamicCP(checkpoints[playerid]);
		Pl::CheckpointStatus[playerid] = CHECKPOINT_NONE;
	}

	new caller = Mobile[playerid];
	if(Pl::isLogged(caller)) {
		Send(caller, COLOR_GRAD2, "* Ёта лини€ отключина.");
		CellTime[caller] = 0;
		CellTime[playerid] = 0;
		Mobile[caller] = INVALID_PLAYER_ID;
		Mobile[playerid] = INVALID_PLAYER_ID;
		CellTime[playerid] = 0;
	}

	if(OnAir[playerid]) {
		OnAirMax--;
		OnAir[playerid] = false;
	}

	// *** ƒальнобойщик ***
	if(acceptgruz{playerid} != 0) {
		acceptgruz{playerid} = 0;
		DestroyDynamicPickup(pickupd[playerid][0]);
		DestroyDynamicMapIcon(pickupd[playerid][1]);
	}

	Pl::CuffedTime[playerid] = 0;
	Pl::Info[playerid][pLocal] = 0;
	Pl::Info[playerid][pMaskOn] = false;

	DisablePlayerCheckpoint(playerid);
	DisablePlayerCheckpointEx(playerid, FIND_ICON);
	DestroyDynamicRaceCP(checkpointb[playerid]);

	if(GetPVarInt(playerid, "RouteID") != 0xFFFF) {
		SetPVarInt(playerid, "RouteID", 0xFFFF);
		SetPVarInt(playerid, "NextCP", 0);
	}

	MedicBill[playerid] = true;
	Pl::CarInt[playerid] = INVALID_VEHICLE_ID;
	SetPlayerColor(playerid, COLOR_GRAD2);

	return 1;
}

public OnPlayerSpawn(playerid) {
	SetPlayerTeam(playerid, 1);
	if(!Pl::Info[playerid][pReg]) {
		Pl::setCamPos(playerid, Pl::Info[playerid][pCamPos], playerid+99);

	} else if(!Pl::isLogged(playerid)) {
		Send(playerid, COLOR_LIGHTRED, "* »звините но этот сервере требует залогинитс€ перед тем как войти в игру. (Kicked) **");
		Kick(playerid);

	} else {
		SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
		if(SuspectKill[playerid]) {
			SuspectKill[playerid] = false;
			Jailed(playerid, Pl::Info[playerid][pJailTime], Pl::Info[playerid][pJailed]);
			SetCameraBehindPlayer(playerid);

		} else if(Pl::Info[playerid][pJailed] > 0) {
			if(Pl::Info[playerid][pJailed] != 2) Jailed(playerid, Pl::Info[playerid][pJailTime]);
			else Jailed(playerid, Pl::Info[playerid][pJailTime], Pl::Info[playerid][pJailed]);
			Send(playerid, COLOR_LIGHTRED, "* ¬ы ещЄ не отсидели свой тюремный срок.");
			SetCameraBehindPlayer(playerid);

		} else if(IsValidHouse(Pl::Info[playerid][pHouseKey]) && !SpawnChange[playerid]) {
			EnterHouse(playerid, Pl::Info[playerid][pHouseKey]);
		} else {
			new fracid = Pl::FracID(playerid);
			if(IsValidFrac(fracid)) {
				Rac::SetPlayerInterior(playerid, FracInfo[fracid][fSpawn][fSpawnInt][0]);
				Rac::SetPlayerVirtualWorld(playerid, FracInfo[fracid][fSpawn][fSpawnInt][1]);
				Rac::SetPlayerPos(playerid,
				FracInfo[fracid][fSpawn][fSpawnPos][0],
				FracInfo[fracid][fSpawn][fSpawnPos][1],
				FracInfo[fracid][fSpawn][fSpawnPos][2]
				);
				Rac::SetPlayerFacingAngle(playerid, FracInfo[fracid][fSpawn][fSpawnPos][3]);
				SetCameraBehindPlayer(playerid);

			} else {
			    new sprand = random(4);
				switch(sprand)
				{
				    case 1:
				    {
						Rac::SetPlayerInterior(playerid, SpawnInfo[1][spInt]);
						Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[1][spVirt]);
						Rac::SetPlayerPos(playerid, SpawnInfo[1][spX], SpawnInfo[1][spY], SpawnInfo[1][spZ]);
						Rac::SetPlayerFacingAngle(playerid, SpawnInfo[1][spA]);
						SetCameraBehindPlayer(playerid);
				    }
				    case 2:
				    {
						Rac::SetPlayerInterior(playerid, SpawnInfo[2][spInt]);
						Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[2][spVirt]);
						Rac::SetPlayerPos(playerid, SpawnInfo[2][spX], SpawnInfo[2][spY], SpawnInfo[2][spZ]);
						Rac::SetPlayerFacingAngle(playerid, SpawnInfo[2][spA]);
						SetCameraBehindPlayer(playerid);
				    }
				    case 3:
				    {
	   					Rac::SetPlayerInterior(playerid, SpawnInfo[3][spInt]);
						Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[3][spVirt]);
						Rac::SetPlayerPos(playerid, SpawnInfo[3][spX], SpawnInfo[3][spY], SpawnInfo[3][spZ]);
						Rac::SetPlayerFacingAngle(playerid, SpawnInfo[3][spA]);
						SetCameraBehindPlayer(playerid);
				    }
				    default:
				    {
	   					Rac::SetPlayerInterior(playerid, SpawnInfo[4][spInt]);
						Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[4][spVirt]);
						Rac::SetPlayerPos(playerid, SpawnInfo[4][spX], SpawnInfo[4][spY], SpawnInfo[4][spZ]);
						Rac::SetPlayerFacingAngle(playerid, SpawnInfo[4][spA]);
						SetCameraBehindPlayer(playerid);
				    }
				}
				/*new i = Pl::Info[playerid][pOrigin];
				if(1 <= i < sizeof SpawnInfo) {
					Rac::SetPlayerInterior(playerid, SpawnInfo[i][spInt]);
					Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[i][spVirt]);
					Rac::SetPlayerPos(playerid, SpawnInfo[i][spX], SpawnInfo[i][spY], SpawnInfo[i][spZ]);
					Rac::SetPlayerFacingAngle(playerid, SpawnInfo[i][spA]);
					SetCameraBehindPlayer(playerid);
				} else {
					Rac::SetPlayerInterior(playerid, SpawnInfo[1][spInt]);
					Rac::SetPlayerVirtualWorld(playerid, SpawnInfo[1][spVirt]);
					Rac::SetPlayerPos(playerid, SpawnInfo[1][spX], SpawnInfo[1][spY], SpawnInfo[1][spZ]);
					Rac::SetPlayerFacingAngle(playerid, SpawnInfo[1][spA]);
					SetCameraBehindPlayer(playerid);
				}*/
				
			}
		}
		if(MedicBill[playerid] && !Pl::Info[playerid][pJailed] && !SuspectKill[playerid]) {
			MedicBill[playerid] = false;
			Pl::Info[playerid][pDeaths]++;
			new cut = Pl::Info[playerid][pLevel]*deathcost;
			GiveFracMoney(4, cut);
			Rac::GivePlayerMoney(playerid, -cut);
			Rac::SetPlayerHealth(playerid, 100.0);
			format(temp, sizeof(temp), "*ƒоктор: € вз€л с вас $%i за лечение, при€тной игры.", cut);
			Send(playerid, COLOR_CYAN, temp);
		}

		Pl::SetFracColor(playerid);
		SetPlayerWeapons(playerid);
		PlayerFixRadio(playerid);
		SetPlayerFightingStyle(playerid, Pl::Info[playerid][pFightstyle]);
	}
	PreloadAnimlib(playerid);
	SetPlayerSkillLevel(playerid, 0, 0);
	SetPlayerSkillLevel(playerid, 6, 0);
	SetPlayerSkillLevel(playerid, 5, 0);
	SetPlayerSkillLevel(playerid, 4, 0);
	SetPlayerScore(playerid, Pl::Info[playerid][pLevel]);
	return 1;
}
//---------------------------------------------------------------------------
public OnPlayerEnterCheckpoint(playerid) {
	if(!Pl::isLogged(playerid)) return 0;

	new string[128];
	new Veh = GetPlayerVehicleID(playerid);
	if(TaxiCallTime[playerid] > 0 && TaxiAccepted[playerid] != INVALID_PLAYER_ID) {
		TaxiAccepted[playerid] = INVALID_PLAYER_ID;
		GameTextForPlayer(playerid, "~w~Reached destination", 5000, 1);
		TaxiCallTime[playerid] = 0;
		DisablePlayerCheckpoint(playerid);

	} else if(BusCallTime[playerid] > 0 && BusAccepted[playerid] != INVALID_PLAYER_ID) {
		BusAccepted[playerid] = INVALID_PLAYER_ID;
		GameTextForPlayer(playerid, "~w~Reached destination", 5000, 1);
		BusCallTime[playerid] = 0;
		DestroyDynamicCP(checkpoints[playerid]);

	} else if(CP[playerid] == 1) {
		if(IsPlayerInAnyVehicle(playerid)) {
			new moneys, level;
			if(Pl::Info[playerid][pSkill][4] < 401) level = ++Pl::Info[playerid][pSkill][4];

			switch(level) {
			case 50 : Send(playerid, COLOR_YELLOW, "* ¬аш скил угонщика машин увеличен до 2 уровн€ теперь вы можете продовать больше машин.");
			case 100 : Send(playerid, COLOR_YELLOW, "* ¬аш скил угонщика машин увеличен до 3 уровн€ теперь вы можете продовать больше машин.");
			case 200 : Send(playerid, COLOR_YELLOW, "* ¬аш скил угонщика машин увеличен до 4 уровн€ теперь вы можете продовать больше машин.");
			case 400 : Send(playerid, COLOR_YELLOW, "* ¬аш скил угонщика машин увеличен до 5 уровн€ теперь вы можете продовать больше машин.");
			}

			if(0 <= level <= 50) {
				new rand = random(sizeof(SELLCAR1)); moneys = SELLCAR1[rand];
				format(string, sizeof(string), "¬ы продали автомобиль за $%d, вы можете продать следующий через - 20 минут.", SELLCAR1[rand]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Pl::Info[playerid][pCarTime] = 1200;

			} else if(51 <= level <= 100) {
				new rand = random(sizeof(SELLCAR2)); moneys = SELLCAR2[rand];
				format(string, sizeof(string), "¬ы продали автомобиль за $%d, вы можете продать следующий через - 18 минут.", SELLCAR2[rand]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Pl::Info[playerid][pCarTime] = 1080;

			} else if(101 <= level <= 200) {
				new rand = random(sizeof(SELLCAR3)); moneys = SELLCAR3[rand];
				format(string, sizeof(string), "¬ы продали автомобиль за $%d, вы можете продать следующий через - 16 минут.", SELLCAR3[rand]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Pl::Info[playerid][pCarTime] = 960;

			} else if(201 <= level <= 400) {
				new rand = random(sizeof(SELLCAR4)); moneys = SELLCAR4[rand];
				format(string, sizeof(string), "¬ы продали автомобиль за $%d, вы можете продать следующий через - 14 минут.", moneys);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Pl::Info[playerid][pCarTime] = 840;

			} else if(level >= 401) {
				moneys = 6000;
				format(string, sizeof(string), "¬ы продали автомобиль за $%d, вы можете продать следующий через - 12 минут.", moneys);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Pl::Info[playerid][pCarTime] = 720;
			}
			format(string, sizeof(string), "~g~+$%i~n~~y~Sold the car", moneys);
			GameTextForPlayer(playerid, string, 7000, 1);
			CP[playerid] = 0;
			Rac::GivePlayerMoney(playerid, moneys);
			DestroyDynamicCP(checkpoints[playerid]);
			SetVehicleToRespawn(Veh);

		} else {
			GameTextForPlayer(playerid, "Not in a car", 5000, 1);
		}
	} else if(CP[playerid] == 5) {
		CP[playerid] = 0;
		DestroyDynamicCP(checkpoints[playerid]);
		GameTextForPlayer(playerid, "~y~At the Missions Checkpoint", 2500, 1);

	} else {
		switch (Pl::CheckpointStatus[playerid]) {
		case CHECKPOINT_HOME : {
				PlayerPlaySound(playerid, 1058, 0.0, 0.0, 0.0);
				DestroyDynamicCP(checkpoints[playerid]);
				Pl::CheckpointStatus[playerid] = CHECKPOINT_NONE;
				GameTextForPlayer(playerid, "~w~You are~n~~y~Home", 5000, 1);
			}
		}
	}

	return 1;
}

public OnPlayerEnterDynamicCP(playerid, checkpointid) {
	if(!Pl::isLogged(playerid)) return 0;

	//new string[144];
	//new Veh = GetPlayerVehicleID(playerid);

	if(FactorySklad == checkpointid && OnJob[playerid] == 1) {
		if(IsPlayerAttachedObjectSlotUsed(playerid, 1)) {
			KG[playerid][0] =  0;
			KG[playerid][1] += 1;
			Gm::Info[Gm::FactoryProds] += 1;
			ApplyAnimation(playerid,"CARRY","putdwn",4.1,0,1,1,0,1);
			RemovePlayerAttachedObject(playerid,1);
			Send(playerid, COLOR_YELLOW, "ѕродукт доставлен на склад");
			UpdateFactory();
		}
	} else if(IsFactoryCP(playerid, 1)) {
		if(OnJob[playerid] == 1) {
			if(KG[playerid][0]) {
				StartJob[playerid] = 1;
				ClearAnimations(playerid);
				Rac::SetPlayerFacingAngle(playerid, 0.0);
				GetPlayerPos(playerid, posx, posy, posz);
				PlayerObject[playerid] = CreateObject(960, posx, posy+1, posz+0.3,0.00000000,0.00000000,0.00000000);
				ApplyAnimation(playerid,"INT_SHOP","shop_cashier",4.1,1,0,0,1,11000); // WEAPON_csawlo
				SetPlayerAttachedObject(playerid, 1, 18635, 14, 0.264531, 0.121060, 0.022172, 279.757507, 164.484985, 184.886245); // ƒаем молоток
				SetPlayerAttachedObject(playerid, 2, 18644, 13, 0.334366, 0.015833, -0.035214, 294.913085, 188.347946, 235.000213); // ƒаем отвертку
				SetTimerEx("OnPlayerEndJob", 8000+(random(3)*1000), false, "ii", playerid, 1);
			} else {
				Send(playerid, COLOR_GREY, "¬озьмите металл раздаточного стола");
			}
		}
	} else if(IsFactoryCP(playerid, 2)) {
		if(OnJob[playerid] == 1) {
			if(KG[playerid][0]) {
				StartJob[playerid] = 1;
				ClearAnimations(playerid);
				Rac::SetPlayerFacingAngle(playerid, 180.0);
				GetPlayerPos(playerid, posx, posy, posz);
				PlayerObject[playerid] = CreateObject(1957, posx, posy-0.67, posz+0.01,0.00000000,0.00000000,0.00000000);
				ApplyAnimation(playerid,"INT_SHOP","shop_cashier",4.1,1,0,0,1,11000); // WEAPON_csawlo
				SetPlayerAttachedObject(playerid, 1, 18635, 14, 0.264531, 0.121060, 0.022172, 279.757507, 164.484985, 184.886245); // ƒаем молоток
				SetPlayerAttachedObject(playerid, 2, 18644, 13, 0.334366, 0.015833, -0.035214, 294.913085, 188.347946, 235.000213); // ƒаем отвертку
				SetTimerEx("OnPlayerEndJob", 8000+(random(3)*1000), false, "ii", playerid, 1);
			} else {
				Send(playerid, COLOR_GREY, "¬озьмите металл раздаточного стола");
			}
		}
	}

	else
	if(TaxiCallTime[playerid] > 0 && TaxiAccepted[playerid] != INVALID_PLAYER_ID) {
		TaxiAccepted[playerid] = INVALID_PLAYER_ID;
		TaxiCallTime[playerid] = 0;
		GameTextForPlayer(playerid, "~w~Reached destination", 5000, 1);
		DestroyDynamicCP(checkpoints[playerid]);

	} else if(BusCallTime[playerid] > 0 && BusAccepted[playerid] != INVALID_PLAYER_ID) {
		BusAccepted[playerid] =INVALID_PLAYER_ID;
		GameTextForPlayer(playerid, "~w~Reached destination", 5000, 1);
		BusCallTime[playerid] = 0;
		DestroyDynamicCP(checkpoints[playerid]);

	} else {
		switch(Pl::CheckpointStatus[playerid]) {
		case CHECKPOINT_HOME: {
				PlayerPlaySound(playerid, 1058, 0.0, 0.0, 0.0);
				DestroyDynamicCP(checkpoints[playerid]);
				Pl::CheckpointStatus[playerid] = CHECKPOINT_NONE;
				GameTextForPlayer(playerid, "~w~You are~n~~y~Home", 5000, 1);
			}
		}
	}
	return 1;
}

public OnPlayerEnterDynamicRaceCP(playerid, checkpointid) {
	if(!Pl::isLogged(playerid)) return 0;

	new string[144];

	switch(GetPlayerState(playerid)) {
	case PLAYER_STATE_DRIVER : {
			new Veh = GetPlayerVehicleID(playerid);
			switch(Pl::Info[playerid][pJob]) {
			case JOB_BUSMAN : {
					if(checkpointb[playerid] == checkpointid && GetPVarInt(playerid, "RouteID") != 0xFFFF) {
						if(IsABusCar(Veh)) {
							new next = GetPVarInt(playerid, "NextCP");
							new route = GetPVarInt(playerid, "RouteID");

							if(++next < BusRouteCount[route]) {
								DestroyDynamicRaceCP(checkpointb[playerid]);
								if(strcmp(BusRoute[route][next-1][stopName], "NULL", false) != 0) {
									SetVehicleVelocity(Veh, 0.0, 0.0, 0.0);
									PlayerPlaySound(playerid, 1057, 0.0, 0.0, 0.0);
									format(string, sizeof(string),  "** %s, следующи€ остановка - %s.", BusRoute[route][next-1][stopName], BusRoute[route][BusRoute[route][next - 1][stopNext]][stopName]);
									ProxDetector(30.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
								}
								if((next + 1) >= BusRouteCount[route]) {
									checkpointb[playerid] = CreateDynamicRaceCP(
									1,
									BusRoute[route][next][stopX],
									BusRoute[route][next][stopY],
									BusRoute[route][next][stopZ],
									0, 0, 0, 4.0, 0, 0, playerid, 99999.0
									);
								} else {
									if(BusRoute[route][next][stopNext] != 0) {
										checkpointb[playerid] = CreateDynamicRaceCP(
										1,
										BusRoute[route][next][stopX],
										BusRoute[route][next][stopY],
										BusRoute[route][next][stopZ],
										0, 0, 0, 4.0, 0, 0, playerid, 99999.0
										);
									} else {
										checkpointb[playerid] = CreateDynamicRaceCP(
										0,
										BusRoute[route][next][stopX],
										BusRoute[route][next][stopY],
										BusRoute[route][next][stopZ],
										BusRoute[route][next + 1][stopX],
										BusRoute[route][next + 1][stopY],
										BusRoute[route][next + 1][stopZ],
										4.0, 0, 0, playerid, 99999.0
										);
									}
								}
								SetPVarInt(playerid, "NextCP", next);
							} else {
								BusDrivers --;
								TransportDuty[playerid] = 0;
								TransportValue[playerid] = 0;
								DestroyDynamicRaceCP(checkpointb[playerid]);
								DestroyDynamic3DTextLabel(AttachText[Veh]);
								SetVehicleVelocity(Veh, 0.0, 0.0, 0.0);
								PlayerPlaySound(playerid, 1057, 0.0, 0.0, 0.0);
								format(string, sizeof(string),  "** %s, конечна€ остановка.", BusRoute[route][next-1][stopName]);
								ProxDetector(30.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

								new Float:health;
								GetVehicleHealth(Veh, health);
								new cost = floatround((health*5.0));
								format(string, sizeof(string),  "* ћаршрут закончен! ¬ы заработали $%i", cost);
								Send(playerid, COLOR_YELLOW, string);
								format(string, sizeof(string),  "~g~+$%i", cost);
								GameTextForPlayer(playerid, string, 7000, 1);
								Rac::GivePlayerMoney(playerid, cost);

								SetPVarInt(playerid, "RouteID", 0xFFFF);
								DeletePVar(playerid, "NextCP");

							}
						}
					}
				}
			}
		}
	}
	return 1;
}

public OnPlayerEnterDynamicArea(playerid, areaid) {
	if(!Pl::isLogged(playerid)) return 0;

	new fracid = Pl::FracID(playerid);
	if(areaid == Area::ASH) {
		AshQueue(playerid, 0);
	}

	else if(areaid == Area::jailField) {
	}

	else if(GangOnBattle[fracid] != INVALID_BIZ_ID) {
		if(BizzInfo[GangOnBattle[fracid]][bZahvatArea] == areaid) {
			GangSolderCount[fracid] ++;
			Pl::SetFracColor(playerid);
		}
	}

	else {
		for(new i; i < TOTAL_ANTIDM_ZONES; i++) {
			if(AntiDmInfo[i][e_AntiDmZone] == areaid) {
				InAntiDmZone{playerid} = true;
				return 1;
			}
		}
	}
	return 1;
}

public OnPlayerLeaveDynamicArea(playerid, areaid) {
	if(!Pl::isLogged(playerid)) return 0;

	new fracid = Pl::FracID(playerid);

	if(areaid == Area::ASH) {
		AshQueue(playerid, 1);
	}

	else if(areaid == Area::Shamal) {
		Pl::CarInt[playerid] = INVALID_PLAYER_ID;
	}

	else if(areaid == Area::jailField) {
		if(Pl::Info[playerid][pJailed] == 1) {
			format(temp, sizeof temp, "* {FF6347}%s[ID: %d] {CDFFFF}подозрение на побег из тюрьмы. {C2A2DA}(оставшийс€ срок: %d секунд).", GetName(playerid), playerid, Pl::Info[playerid][pJailTime]);
			SendToAdmin(COLOR_CHEATS, temp, 1, 1);
		}
	}

	else if(GangOnBattle[fracid] != INVALID_BIZ_ID) {
		if(!ZahvatDeath[playerid]) {
			new biz = GangOnBattle[fracid];
			if(BizzInfo[biz][bZahvatArea] == areaid) {
				new attack = BizzInfo[biz][bAttack];
				new defend = BizzInfo[biz][bDefend];
				if(fracid == defend && GangSolderCount[attack] > 0) {
					ZahvatScore[attack] ++;
					BizzInfo[biz][bFrac] = attack;
					GiveGangRespect(attack, ZahvatScore[attack]);
					Gz::StopFlashForAll(BizzInfo[biz][bZone]);
					Gz::HideForAll(BizzInfo[biz][bZone]);
					Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
					format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(attack), ZahvatScore[attack]);
					GameTextForGangs(temp, 6000, 1);
					format(temp, sizeof temp, "[GANG NEWS] %s[%d] захватили территорию бизнеса %s, %s[%d] повержены!",
					GetGangName(attack), ZahvatScore[attack], BizzInfo[biz][bDescription], GetGangName(defend), ZahvatScore[defend]);
					sendToTeam(GetFracColor(attack), temp, Gangs);
				}

				else {
					ZahvatScore[defend] ++;
					GiveGangRespect(defend, ZahvatScore[defend]);
					Gz::StopFlashForAll(BizzInfo[biz][bZone]);
					Gz::HideForAll(BizzInfo[biz][bZone]);
					Gz::ShowForAll(BizzInfo[biz][bZone], GetFracColor(BizzInfo[biz][bFrac]));
					format(temp, sizeof(temp), "~r~%s~g~~n~RESPECT~r~+%d", GetGangName(defend), ZahvatScore[defend]);
					GameTextForGangs(temp, 6000, 1);
					format(temp, sizeof(temp), "[GANG NEWS] %s[%d] удержала территорию своего бизнеса %s, %s[%d] повержены!",
					GetGangName(defend), ZahvatScore[defend], BizzInfo[biz][bDescription], GetGangName(attack), ZahvatScore[attack]);
					sendToTeam(GetFracColor(defend), temp, Gangs);
				}

				ZahvatKills{attack} = ZahvatKills{defend} = 0;
				ZahvatScore[defend] = ZahvatScore[defend] = 0;
				GangSolderCount[attack] = GangSolderCount[defend] = 0;
				GangOnBattle[attack] = GangOnBattle[defend] = INVALID_BIZ_ID;
				BizzInfo[biz][bAttack] = BizzInfo[biz][bDefend] = 0;
				BizzInfo[biz][bOnBattle] = 0;
				DisableZahvatMapIcon(attack, defend);
				Td::HideForAll(BizzInfo[biz][bZahvatTD]);
				Td::Destroy(BizzInfo[biz][bZahvatTD]);
				DestroyDynamicArea(BizzInfo[biz][bZahvatArea]);
				KillTimer(BizzInfo[biz][bZahvatTimer]);
				UpdateBizz(biz);
				UpdateGangInfo();
			}
		} else {
			if(GangSolderCount[fracid] != 0) GangSolderCount[fracid] --;
			ZahvatDeath[playerid] = 0;
		}
	}

	else {
		for(new i; i < TOTAL_ANTIDM_ZONES; i++) {
			if(AntiDmInfo[i][e_AntiDmZone] == areaid) {
				if(AntiDmInfo[i][e_AntiDmZoneId] == 11 && OnJob[playerid] == 1) {
					if(IsPlayerAttachedObjectSlotUsed(playerid,1)) RemovePlayerAttachedObject(playerid,1);
					if(IsPlayerAttachedObjectSlotUsed(playerid,2)) RemovePlayerAttachedObject(playerid,2);
					if(PlayerObject[playerid] != INVALID_OBJECT_ID) DestroyObject(PlayerObject[playerid]);
					KG[playerid][0] = 0;
					KG[playerid][1] = 0;
					OnJob[playerid] = 0;
					StartJob[playerid] = 0;
					SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
					Send(playerid, -1, "¬ы покинули завод, вы ничего не заработали.");
				}
				InAntiDmZone{playerid} = false;
				return 1;
			}
		}
	}
	return 1;
}

stock AshQueue(playerid, reason) {
	switch(reason) {
	case 0 : {
			if(!Iter::Contains(AshQueue, playerid)) {
				if(!TakingLesson[playerid]) {
					Iter::Add(AshQueue, playerid);
					GetPlayerName(playerid, plname, 24);
					scf(string_ah, temp, "%i.%s\n", Iter::Count(AshQueue), plname);
					UpdateDynamic3DTextLabelText(ah_text, 0x42aaffFF, string_ah);
					Send(playerid, COLOR_WHITE,"* ¬ы зан€ли место в очереди.");
				}
			}
		}

	case 1 : {
			if(Iter::Contains(AshQueue, playerid)) {
				new pddp;
				Iter::Remove(AshQueue, playerid);
				format(string_ah,sizeof(string_ah),">> ќчередь допущенных к практической части экзамена: <<\n");
				foreach(new i : AshQueue) {
					pddp++;
					GetPlayerName(i, plname, 24);
					scf(string_ah, temp, "%i.%s\n", pddp, plname);
				}
				UpdateDynamic3DTextLabelText(ah_text, 0x42aaffFF, string_ah);
				Send(playerid, COLOR_WHITE, "* ¬ы покинули очередь.");
			}
		}
	}
	return 1;
}

public: OnPlayerGatePickUp(playerid, gateid, pickupid) {
	for(new i, fracid = Pl::FracID(playerid); i < FracGateCount; i++) {
		if(FracGate[i][GateID] == gateid) {
			if(GET_GATE_ACCESS(gateid, fracid) == true) {
				if(GateOpen(gateid)) {
					PlayerPlaySound(playerid, 1058, 0, 0, 0);
					SetTimerEx("GateClose", 1000 * 7, false, "i", gateid);
				}
			}
			return 1;
		}
	}
	return 1;
}

public OnPlayerPickUpDynamicPickup(playerid, pickupid) {
	if(PickupInfo[playerid][pOld] == pickupid) {
		return 1;
	} else if(PickupInfo[playerid][pDelay]) {
		PickupInfo[playerid][pOld] = pickupid;
		return GetPlayerPos(playerid, PickupInfo[playerid][pOldPos][0], PickupInfo[playerid][pOldPos][1], PickupInfo[playerid][pOldPos][2]);
	} else {
		PickupInfo[playerid][pOld] = pickupid;
		GetPlayerPos(playerid, PickupInfo[playerid][pOldPos][0], PickupInfo[playerid][pOldPos][1], PickupInfo[playerid][pOldPos][2]);
	}

	if(GetPlayerDistanceFromPickup(playerid, pickupid) > 18.0) {
		return Rac::Kick(playerid, "SendPic");
	}

	switch(GetPlayerState(playerid)) {
	case PLAYER_STATE_ONFOOT : {
			if(pickupid == helpp[0] || pickupid == helpp[1] || pickupid == helpp[2]) {
				ShowDialog(playerid, D_REF, DIALOG_STYLE_LIST, "{33CCFF}—правка.", "dialog/ref/main.txt", "SELECT", "CANCEL");
			}
			else if(pickupid == respuk[0])
			{
				Rac::SetPlayerPos(playerid, 2242.7327,-1162.6306,29.4159);
				SetPlayerFacingAngle(playerid, 182.8724);
				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 12);
				//SetCameraBehindPlayer(playerid);
			}
			else if(pickupid == respuk[1])
			{
				Rac::SetPlayerPos(playerid, 2242.7209,-1167.3309,29.4159);
				SetPlayerFacingAngle(playerid, 179.8435);
				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 12);
				//SetCameraBehindPlayer(playerid);
			}
			else if(pickupid == respuk[2])
			{
				Rac::SetPlayerPos(playerid, 2242.9802,-1173.1643,29.4159);
				SetPlayerFacingAngle(playerid, 179.8435);
				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 12);
				//SetCameraBehindPlayer(playerid);
			}
			else if(pickupid == respuk[3])
			{
				Rac::SetPlayerPos(playerid, 2242.9656,-1178.6349,29.4159);
				SetPlayerFacingAngle(playerid, 179.8435);
				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 12);
				//SetCameraBehindPlayer(playerid);
			}
			else if(pickupid == healash || pickupid == healcnn || pickupid == healfbi) {
				Rac::SetPlayerHealth(playerid, 100.0);
			}

			else if(pickupid == Parashut) {
				if(!Rac::CheckPlayerWeapon(playerid, 46)) {
					Rac::GivePlayerWeapon(playerid, 46, 1);
				}
			}

			else if(pickupid == saveTuning) {
				if(!IsValidHouse(Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				if(HouseInfo[Pl::Info[playerid][pHouseKey]][hvModel] == 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет домашней машины!");
				SPD(playerid, D_TUNING, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Tuning", "«арегистрировать тюнинг\n”далить тюнинг", "SELECT", "CANCEL");
			}

			else if(pickupid == givepasport) {
				if(!Pl::Info[playerid][pPasport][0]) {
					SPD(playerid, D_GIVE_PASS, 1, "{ffcf00}ѕаспортный стол", "”кажите ваш возраст", "¬вод", "ќтмена");
				} else {
					Send(playerid, COLOR_GREY, "* ” ¬ас уже есть паспорт!");
				}
			}

			else if(pickupid == ammozakona[0]) {
				if(!IsACop(playerid)) return Send(playerid,COLOR_GREY,"* ¬ы не законник!");
				if(Pl::Info[playerid][pLic][3] <= 0) return Send(playerid,COLOR_WHITE,"ѕродавец: я не могу продать вам оружие без лицензии!");
				ShowMenuForPlayer(Ammu2Menu,playerid);
				Rac::TogglePlayerControllable(playerid, 0);
			}

			else if(pickupid == ammozakona[1]) {
				if(Pl::FracID(playerid) != 2) return Send(playerid,COLOR_GREY,"* ƒл€ вас нет комплекта одежды!");
				if(Pl::Info[playerid][pRank] < 3) return Send(playerid,COLOR_GREY,"* “олько с 3-го ранга!");
				SPD(playerid, D_MASK+1, DIALOG_STYLE_LIST, "—кины скрытности","японец\n оронос\nЅаллас\n√ражданский\n¬ернуть свой","¬џЅќ–","ќ“ћ≈Ќј");
			}

			else if(pickupid == ammozakona[2]) {
				if(Pl::FracID(playerid) != 3) return Send(playerid,COLOR_GREY,"* ƒл€ вас нет комплекта одежды!");
				Container::At(Pl::FracID(playerid), Container::First, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(ClothesMenu, playerid);
				Rac::TogglePlayerControllable(playerid, 0);
			}

			else if(pickupid == ammozakona[3]) {
				if(!IsACop(playerid)) return Send(playerid,COLOR_GREY,"* ¬ы не законник!");
				SPD(playerid, D_ARMOUR, DIALOG_STYLE_MSGBOX, "ќдеть бронежилет?", "¬ам приедетьс€ заплатить $500", "ќƒ≈“№","ќ“ћ≈Ќј");
			}

			else if(buy[0] <= pickupid <= buy[1]) {
				Rac::TogglePlayerControllable(playerid, false);
				ShowMenuForPlayer(BuyMenu, playerid);
			}

			else if(pickupid == proba) {
				ShowCantina(playerid);
			}

			else if(pickupid == fire_ext) {
				if(Pl::FracID(playerid) == TEAM_GOV) {
					if(Rac::GetPlayerAmmo(playerid, 42) == 0) {
						Rac::GivePlayerWeapon(playerid, 42, 500);
					}
				}
			}

			else if(pickupid == mak[0] || pickupid == mak[1]) {
				Rac::TogglePlayerControllable(playerid,0);
				ShowMenuForPlayer(BurgerMenu, playerid);
			}

			else if(pickupid == boj) {
				SPD(playerid, 2222, DIALOG_STYLE_LIST,"¬ыберите стиль бо€. —тоимость 100.000",
				"Ѕќ —\n ”Ќ√-‘”\n—јћЅќ\n”Ћ»„Ќџ…","¬ыбрать","ќтмена");
			}

			else if(pickupid == Piza) {
				Rac::TogglePlayerControllable(playerid,0);
				ShowMenuForPlayer(PizaMenu, playerid);
			}

			else if(pickupid == weapon1 || pickupid == weapon2 || pickupid == weapon3 || pickupid == weapon4) {
				if(Pl::Info[playerid][pLic][3] <= 0) return Send(playerid,COLOR_WHITE,"ѕродавец: я не могу продать вам оружие без лицензии!");
				ShowMenuForPlayer(ammonac,playerid);
				Rac::TogglePlayerControllable(playerid, 0);
			}

			else if(pickupid == testpdd) {
				if(Pl::Info[playerid][pLic][0]) return Send(playerid,COLOR_GREY,"* ” ¬ас уже есть права!");
				if(Pl::Info[playerid][pTest] == 999) return Send(playerid,COLOR_GREY,"* ¬ы уже сдали теорию!");
				SetPVarInt(playerid, "SelectedItem", 1);
				return ShowDialog(playerid, D_PDDTEST, 1, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": TEST PDD", "dialog/pddtest/pdd_test_1.txt", "ќтвет", "ќтмена");
			}

			else if(pickupid == prolaps[0] || pickupid == prolaps[1]) {
				if(GetPlayerInterior(playerid) == 3) {
					Rac::SetPlayerPos(playerid, 215.3485, -133.1142, 1003.5078);
					Rac::SetPlayerFacingAngle(playerid, 92.2598);
					SetPlayerCameraPos(playerid, 210.4674, -131.8238, 1004.2631);
					SetPlayerCameraLookAt(playerid, 214.3328, -132.8457, 1004.1403);
					Rac::SetPlayerVirtualWorld(playerid, ((99 * 7) + playerid));
				} else {
					Rac::SetPlayerPos(playerid, 224.6642, -11.5788, 1002.2109);
					Rac::SetPlayerFacingAngle(playerid, 359.9657);
					SetPlayerCameraPos(playerid, 222.6168, -6.3763, 1002.4910);
					SetPlayerCameraLookAt(playerid, 224.0792, -10.0924, 1002.7197);
					Rac::SetPlayerVirtualWorld(playerid, ((99 * 7) + playerid));
				}
				Container::At(Pl::FracID(playerid), Container::First, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(ClothesMenu, playerid);
				Rac::TogglePlayerControllable(playerid, 0);
			}

			else if(pickupid == Bank[0]) {
				ShowDialog(playerid, D_BANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": BANK", "dialog/bankmenu.txt", "SELECT","CENCEL");
			}

			else if(pickupid == Bank[1]) {
				ShowFracBank(playerid);
			}

			else if(FactoryPickup[0] <= pickupid <= FactoryPickup[1]) {
				if(OnJob[playerid] == 1 && !KG[playerid][0]) {
					if(Gm::Info[Gm::FactoryMetal] > 1 && Gm::Info[Gm::FactoryFuel] > 5) {
						KG[playerid][0] = 1;
						Gm::Info[Gm::FactoryMetal] -= 1;
						Gm::Info[Gm::FactoryFuel] -= 5;
						GameTextForPlayer(playerid, "~b~ +1kg", 2000, 1);
					} else {
						GameTextForPlayer(playerid, "~r~no metall or benzin", 2000, 1);
					}
				}
			}

			else if(pickupid == FactoryPickup[2]) {
				if(OnJob[playerid] == 1) {
					SPD(playerid, D_FACTORY_JOB+1, 0, "{ffcf00}ѕроизводственный цех"," ¬ы действительно желаете закончить рабочий день?" ,"ƒа", "Ќет");
				} else {
					SPD(playerid, D_FACTORY_JOB, 0, "{ffcf00}ѕроизводственный цех"," ¬ы действительно желаете начать рабочий день?" ,"ƒа", "Ќет");
				}
			}

			else if(ATMp[0] <= pickupid <= ATMp[1]) {
				ShowDialog(playerid, D_ATM, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM.", "dialog/atmmenu.txt", "SELECT","CENCEL");
			}

			else if(pickupid == HGaragePickup[0]) {
				/*new Float:x, Float:y;
				new local = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
				GetXYInFrontOfPoint(x, y, HouseInfo[local][hgIntPos][3], 1.5);
				Rac::SetPlayerPos(playerid, HouseInfo[local][hgIntPos][0] + x, HouseInfo[local][hgIntPos][1] + y, HouseInfo[local][hgIntPos][2]);
				SetPlayerFacingAngle(playerid, HouseInfo[local][hgIntPos][3]);
				Rac::SetPlayerInterior(playerid, HouseInfo[local][hInt]);
				Rac::SetPlayerVirtualWorld(playerid, HouseInfo[local][hVirtual]);
				SetCameraBehindPlayer(playerid);*/

				EnterHouse(playerid, Pl::Info[playerid][pLocal] - OFFSET_HOUSE);
			}

			else if(pickupid == HGaragePickup[1]) {
				/*new Float:x, Float:y;
				new local = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
				if(HouseInfo[local][hgStreetPos][3] <= 0.0) return Send(playerid, COLOR_GREY, "* »спользуйте команду /editgarstreet дл€ установки выезда из гаража");
				GetXYInFrontOfPoint(x, y, HouseInfo[local][hgStreetPos][3], 1.5);
				Rac::SetPlayerPos(playerid, HouseInfo[local][hgStreetPos][0] + x, HouseInfo[local][hgStreetPos][1] + y, HouseInfo[local][hgStreetPos][2]);
				SetPlayerFacingAngle(playerid, HouseInfo[local][hgStreetPos][3]);
				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 0);
				SetCameraBehindPlayer(playerid);
				Pl::Info[playerid][pLocal] = 0;*/
			}

			else if(pickupid == EstateAgency) {
				ShowDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Estate Agency", "dialog/estate-agency-help.txt", "ENTER", "");
			}

			else {
				if(!PickupHndlr::Portal(playerid, pickupid)) {
					if(!PickupHndlr::Job(playerid, pickupid)) {
						if(!PickupHndlr::Bizz(playerid, pickupid)) {
							if(!PickupHndlr::Houses(playerid, pickupid)) {}
						}
					}
				}
			}
		}

	case PLAYER_STATE_DRIVER : {
			if(pickupid == GarageParkPickup[0] || pickupid == GarageParkPickup[1] || pickupid == GarageParkPickup[2]) {
				new veh = GetPlayerVehicleID(playerid);
				new slot = GetIdxExtraVehicleFromVehicleID(playerid, veh);
				if(slot == -1) return Send(playerid, COLOR_GREY, "* Ётот транспорт нельз€ сдать в гараж!");
				Veh::Destroy(ExtraVehicles[playerid][slot][evID2]);
				ExtraVehicles[playerid][slot][evPark] = PARK_GARAGE;
				AddExtraVehicleToGarage(playerid, slot);
				UpdateExtraVehicle(playerid, slot);
				Send(playerid, COLOR_GREY, "* “ранспорт был сдан в гараж!");
			}

			else if(pickupid == barn[0]) {
				if(Pl::FracID(playerid) == TEAM_FARMERS) {
					new vehid = GetPlayerVehicleID(playerid);
					if(GetVehicleModel(vehid) == 532) {
						SPD(playerid, D_BARN, 0, "јмбар", "–азгрузить мак?", "OK", "CANCEL");
					} else {
						SPD(playerid, D_BARN+2, 1, "јмбар", "¬з€ть мак:", "OK", "CANCEL");
					}
				}
			}

			else if(pickupid == barn[1]) {
				if(Pl::FracID(playerid) == TEAM_FARMERS) {
					SPD(playerid, D_BARN+1, 0, "ѕритон", "ѕродать мак?", "OK", "CANCEL");
				}
			}

			else if(pickupd[playerid][0] == pickupid) {
				if(acceptgruz{playerid}) {
					new veh = GetPlayerVehicleID(playerid);
					if(IsATruckCar(veh) && Rac::GetPlayerState(playerid) == 2) {
						new trailer = GetVehicleTrailer(veh);
						if(trailer) {
							acceptgruz{playerid} = 0;
							DestroyDynamicPickup(pickupd[playerid][0]);
							DestroyDynamicMapIcon(pickupd[playerid][1]);

							new rnd = (1000 + (random(7)*1000));
							Rac::GivePlayerMoney(playerid, rnd);
							SetVehicleToRespawn(trailer);

							format(temp, sizeof(temp),"* √руз доставлен. «аработано %d$", rnd);
							Send(playerid,COLOR_YELLOW, temp);
							format(temp, sizeof(temp),"~g~+$%i", rnd);
							GameTextForPlayer(playerid, temp, 5000, 1);
						} else {
							DestroyDynamicPickup(pickupd[playerid][0]);
							DestroyDynamicMapIcon(pickupd[playerid][1]);
							Send(playerid,COLOR_YELLOW, "* ¬ы приехали без груза!");
						}
					}
				} else {
					acceptgruz{playerid} = 0;
					DestroyDynamicPickup(pickupd[playerid][0]);
					DestroyDynamicMapIcon(pickupd[playerid][1]);
				}
			}

			else {
				if(!PickupHndlr::Gas(playerid, pickupid)) {
					if(!PickupHndlr::Portal(playerid, pickupid)) {}
				}
			}
		}
	}

	return 1;
}


stock PickupHndlr::Gas(playerid, pickupid) {
	foreach(new i : Refills) {
		if(pickupid == RefillInfo[i][brPickup]) {
			new veh = GetPlayerVehicleID(playerid);
			switch(GetVehicleType(GetVehicleModel(veh))) {
			case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
					SetPVarInt(playerid, "SelectGas", i);
					SetVehicleVelocity(veh, 0, 0, 0);
					ShowRefillDialog(playerid, GetIndexFromBizID(RefillInfo[i][brBizID]));
				}
				default : Send(playerid,COLOR_GREY,"* «аправка непредназначена дл€ вашего транспорта!");
			}
			return 1;
		}
	}
	return 0;
}

stock PickupHndlr::Portal(playerid, pickupid) {
	for(new i; i < TOTAL_PORTAL; ++i) {
		if(Portal::Info[i][Portal::Pickup][0] == pickupid) {
			if(EditMode[playerid]) {
				SetPVarInt(playerid, "selectTeleport", i);
				format(dialog, sizeof dialog, "Telepot є%i | | ѕикап є1", Portal::Info[i][Portal::Id]);
				SPD(playerid,TP_EDIT,2,dialog,"ѕерый пикап\n¬торой пикап\nќткрыть/«акрыть\n”далить","¬ыбор","¬ыход");
				return 1;
			}

			if(Portal::Info[i][Portal::Portal2][0] != 0.0) {
				if(!Portal::Info[i][Portal::Allowed][Pl::FracID(playerid)]) {
					switch(CallLocalFunction("onPlayerPortal", "iii", playerid, Portal::Info[i][Portal::Id], 1)) {
					case -1 : {
							return 1;
						}
					case 0 : {
							return GameTextForPlayer(playerid, "~r~Closed", 1000, 1);
						}
					}
				}

				new Float:x,Float:y;
				if(Portal::Info[i][Portal::Type][1] != 14) {
					GetXYInFrontOfPoint(x, y, Portal::Info[i][Portal::Portal2][3], 1.5);
					Rac::SetPlayerPos(playerid,Portal::Info[i][Portal::Portal2][0]+x,Portal::Info[i][Portal::Portal2][1]+y,Portal::Info[i][Portal::Portal2][2]);
					Rac::SetPlayerFacingAngle(playerid, Portal::Info[i][Portal::Portal2][3]);
				} else {
					new veh = GetPlayerVehicleID(playerid);
					GetXYInFrontOfPoint(x, y, Portal::Info[i][Portal::Portal2][3], vehicleSize(veh)+2.0);
					Rac::SetVehiclePos(veh, Portal::Info[i][Portal::Portal2][0]+x,Portal::Info[i][Portal::Portal2][1]+y,Portal::Info[i][Portal::Portal2][2]);
					SetVehicleZAngle(veh, Portal::Info[i][Portal::Portal2][3]);
					LinkVehicleToInterior(veh, Portal::Info[i][Portal::Inter][1]);
					SetVehicleVirtualWorld(veh, Portal::Info[i][Portal::World][1]);
				}
				Rac::SetPlayerInterior(playerid, Portal::Info[i][Portal::Inter][1]);
				Rac::SetPlayerVirtualWorld(playerid, Portal::Info[i][Portal::World][1]);
				SetCameraBehindPlayer(playerid);

				return 1;
			}
		}

		else if(Portal::Info[i][Portal::Pickup][1] == pickupid) {
			if(EditMode[playerid]) {
				SetPVarInt(playerid, "selectTeleport", i);
				format(dialog, sizeof dialog, "Telepot є%i | ѕикап є2 ", Portal::Info[i][Portal::Id]);
				SPD(playerid,TP_EDIT,2,dialog,"ѕерый пикап\n¬торой пикап\nќткрыть/«акрыть\n”далить","¬ыбор","¬ыход");
				return 1;
			}

			if(!Portal::Info[i][Portal::Allowed][Pl::FracID(playerid)]) {
				switch(CallLocalFunction("onPlayerPortal", "iii", playerid, Portal::Info[i][Portal::Id], 2)) {
				case -1 : {
						return 1;
					}
				case 0 : {
						return GameTextForPlayer(playerid, "~r~Closed", 1000, 1);
					}
				}
			}

			new Float:x,Float:y;
			if(Portal::Info[i][Portal::Type][0] != 14) {
				GetXYInFrontOfPoint(x, y, Portal::Info[i][Portal::Portal1][3], 1.5);
				Rac::SetPlayerPos(playerid,Portal::Info[i][Portal::Portal1][0]+x,Portal::Info[i][Portal::Portal1][1]+y,Portal::Info[i][Portal::Portal1][2]);
				Rac::SetPlayerFacingAngle(playerid, Portal::Info[i][Portal::Portal1][3]);
			} else {
				new veh = GetPlayerVehicleID(playerid);
				GetXYInFrontOfPoint(x, y, Portal::Info[i][Portal::Portal1][3], vehicleSize(veh)+2.0);
				Rac::SetVehiclePos(veh, Portal::Info[i][Portal::Portal1][0]+x,Portal::Info[i][Portal::Portal1][1]+y,Portal::Info[i][Portal::Portal1][2]);
				SetVehicleZAngle(veh, Portal::Info[i][Portal::Portal1][3]);
				LinkVehicleToInterior(veh, Portal::Info[i][Portal::Inter][0]);
				SetVehicleVirtualWorld(veh, Portal::Info[i][Portal::World][0]);
			}
			Rac::SetPlayerInterior(playerid, Portal::Info[i][Portal::Inter][0]);
			Rac::SetPlayerVirtualWorld(playerid, Portal::Info[i][Portal::World][0]);
			SetCameraBehindPlayer(playerid);

			return 1;
		}
	}

	return 0;
}

stock PickupHndlr::Job(playerid, pickupid)
{
	new i = interpolationSearch2D(JobsInfo, pickupid, jP);
	if(i != -1)
	{
	    if(Pl::Info[playerid][pMedKarta] == 0) return Send(playerid, COLOR_GREY, "* ” вас нету мед.карты!");
		if(Pl::Info[playerid][pPasport][0] != 0)
		{
			if(Pl::Info[playerid][pJob] != 0)
			{
				Send(playerid, COLOR_GREY, "* ” ¬ас уже есть работа! /quitjob - уволитс€ (если выполнен контракт)");
			}
			else
			{
				GettingJob[playerid] = JobsInfo[i][jID];
				format(src, sizeof(src), "{ffffff}¬ы хотите устроитс€ на работу.\nЧ ƒолжность: {ff0000}%s\n{ffffff}Ч —рок контракта: {ff0000}5 часов\n\n\
				{ffffff}¬ы не уволитесь пока не выполните контракт!\n¬ы согласны?", JobsInfo[i][jName]);
				SPD(playerid, D_JOB, 0, "“рудоустройство", src, "ƒа", "Ќет");
			}
		}
		else
		{
			Send(playerid, COLOR_GREY, "* ” ¬ас нет паспорта! ѕолучить его можно в мэрии.");
		}
		return 1;
	}
	return 0;
}


stock PickupHndlr::Bizz(playerid, pickupid) {
	foreach(new i : Biznes) {
		if(BizzInfo[i][bPickupEnter] == pickupid) {
			if(BizzInfo[i][bOwned]) {
				format(dialog, sizeof dialog,
				"Ќазвание: %s\n\
				ѕлата за вход: $%i\n\n\
				¬ладелец: %s\n\
				 оманьон: %s\n\
				 рыша: %s\n\
				Level: %i\n\
				ID бизнеса: %i",
				BizzInfo[i][bDescription], BizzInfo[i][bEnterCost], BizzInfo[i][bOwner], BizzInfo[i][bExtortion],
				GetGangName(BizzInfo[i][bFrac]), BizzInfo[i][bLevel], BizzInfo[i][bID]);
				SPD(playerid, D_EN_BIZ, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Business Info", dialog, "ENTER", "CANCEL");
			} else {
				format(dialog, sizeof dialog,
				"Ќазвание: %s\n\n\
				Ѕ»«Ќ≈— ѕ–ќƒј≈“—я\n\
				÷ена: $%i\n\
				Level: %i\n\
				ID бизнеса: %i\n\
				¬ведите /buybiz дл€ покупки!",
				BizzInfo[i][bDescription], BizzInfo[i][bPrice], BizzInfo[i][bLevel], BizzInfo[i][bID]);
				SPD(playerid, D_EN_BIZ, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Business Info", dialog, "OK", "CANCEL");
			}
			SetPVarInt(playerid, "PlayerBizz", i);
			return 1;
		}

		else if(BizzInfo[i][bPickupExit] == pickupid) {
			SetPVarInt(playerid, "PlayerBizz", i);
			SPD(playerid, D_EX_BIZ, 0, "EXIT", "¬ы хотите выйти?", "OK", "CANCEL");
			return 1;
		}
	}
	return 0;
}

stock PickupHndlr::Houses(playerid, pickupid) {
	foreach(new i : Houses) {
		if(HouseInfo[i][hPickup] == pickupid) {
			switch(HouseInfo[i][hOwned]) {
			case 0 : {
					format(dialog, sizeof dialog,
					"ƒќћ ѕ–ќƒј≈“—я!\n\
					ќписание: %s\n\
					÷ена: $%i\n\
					Level: %i\n\
					ID дома: %i\n\
					¬ведите /buyhouse, чтобы купить дом.",
					HouseInfo[i][hDescription], HouseInfo[i][hPrice], HouseInfo[i][hLevel], i);
				}

			case 1 : {
					switch(HouseInfo[i][hRent][0]) {
					case 0 : {
							format(dialog, sizeof dialog,
							"¬ладелец: %s\n\
							Level: %i\n\
							ID дома: %i",
							HouseInfo[i][hOwner],  HouseInfo[i][hLevel], i);
						}
					case 1 : {
							format(dialog, sizeof dialog,
							"¬ладелец: %s\n\
							—тоимость аренды: $%i\n\
							Level: %i\n\
							ID дома: %i\n\
							¬ведите /rentroom, чтобы посилитьс€ тут.",
							HouseInfo[i][hOwner], HouseInfo[i][hRent][1], HouseInfo[i][hLevel], i);
						}
					}
				}
			}
			SetPVarInt(playerid, "PlayerHouse", i);
			SPD(playerid, D_EN_HOUSE, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": »нформаци€ о доме.", dialog, "ENTER", "CANCEL");
			return 1;
		}

		else if(HouseInfo[i][hgPickupInt] == pickupid) {
			new Float:x, Float:y;
			GetXYInFrontOfPoint(x, y, HGaragePickupPos[0][3], 2.0);
			Rac::SetPlayerPos(playerid, HGaragePickupPos[0][0] + x, HGaragePickupPos[0][1] + y, HGaragePickupPos[0][2]);
			SetPlayerFacingAngle(playerid, HGaragePickupPos[0][3]);
			Rac::SetPlayerInterior(playerid, 3);
			Rac::SetPlayerVirtualWorld(playerid, HouseInfo[i][hVirtual]);
			SetCameraBehindPlayer(playerid);
			return 1;
		}

		else if(HouseInfo[i][hgPickupStreet] == pickupid) {
			/*if(Pl::Info[playerid][pHouseKey] != HouseInfo[i][hID]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет ключей!");
			new Float:x, Float:y;
			Pl::Info[playerid][pLocal] = OFFSET_HOUSE + i;
			GetXYInFrontOfPoint(x, y, HGaragePickupPos[1][3], 2.0);
			Rac::SetPlayerPos(playerid, HGaragePickupPos[1][0] + x, HGaragePickupPos[1][1] + y, HGaragePickupPos[1][2]);
			SetPlayerFacingAngle(playerid, HGaragePickupPos[1][3]);
			Rac::SetPlayerInterior(playerid, 3);
			Rac::SetPlayerVirtualWorld(playerid, HouseInfo[i][hVirtual]);
			SetCameraBehindPlayer(playerid);*/
			return 1;
		}
	}
	return 0;
}

public: onPlayerPortal(playerid, portalid, pickupid) {
	switch(portalid) {
	case 11 : {
			if(Pl::FracID(playerid) == 11) {
				return 1;
			}
		}
	case 12 : {
			switch(pickupid) {
			case 1 : {
					if(!TakingLesson[playerid]) {
						Send(playerid, COLOR_WHITE, "* ƒождитесь начала экзамена!");
						return -1;
					} else {
						return 1;
					}
				}
			case 2 : {
					return 1;
				}
			}
		}
	}
	return 0;
}

public OnPlayerSelectedMenuRow(playerid, row) {
	new Menu:current = GetPlayerMenu(playerid);
	if(current == ammonac)
	{
		switch(row)
		{
			case 0: ShowMenuForPlayer(degun, playerid);
			case 1: ShowMenuForPlayer(sdgun, playerid);
			case 2: ShowMenuForPlayer(shotgun, playerid);
			case 3: ShowMenuForPlayer(mp5gun, playerid);
			case 4: ShowMenuForPlayer(m4a1gun, playerid);
			case 5: ShowMenuForPlayer(ak47gun, playerid);
			case 6: ShowMenuForPlayer(rifflegun, playerid);
			case 7: ShowMenuForPlayer(ammonac2, playerid);
		}
	}
	if(current == degun)
	{
		switch(row)
		{
			case 0:
			{
				if(4250 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(degun, playerid);
				Rac::GivePlayerMoney(playerid, -4250);
			    Rac::GivePlayerWeapon(playerid, 24, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Desert Eagle(50 патронов) за 4250$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 4250);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(8000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(degun, playerid);
				Rac::GivePlayerMoney(playerid, -8000);
			    Rac::GivePlayerWeapon(playerid, 24, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Desert Eagle(200 патронов) за 8000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 8000);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(15500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(degun, playerid);
				Rac::GivePlayerMoney(playerid, -15500);
			    Rac::GivePlayerWeapon(playerid, 24, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Desert Eagle(500 патронов) за 15500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 15500);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == sdgun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(sdgun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 23, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие SD Pistol(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(sdgun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 23, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие SD Pistol(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(sdgun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 23, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие SD Pistol(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == shotgun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(shotgun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 25, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Shotgun(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(shotgun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 25, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Shotgun(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(shotgun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 25, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Shotgun(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == mp5gun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(mp5gun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 29, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие MP5(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(mp5gun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 29, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие MP5(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(mp5gun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 29, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие MP5(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == m4a1gun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(m4a1gun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 31, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие M4A1(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(m4a1gun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 31, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие M4A1(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(m4a1gun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 31, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие M4A1(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == ak47gun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ak47gun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 30, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие AK47(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ak47gun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 30, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие AK47(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ak47gun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 30, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие AK47(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == rifflegun)
	{
		switch(row)
		{
			case 0:
			{
				if(1750 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(rifflegun, playerid);
				Rac::GivePlayerMoney(playerid, -1750);
			    Rac::GivePlayerWeapon(playerid, 33, 50);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Riffle(50 патронов) за 1750$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 1750);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(5500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(rifflegun, playerid);
				Rac::GivePlayerMoney(playerid, -5500);
			    Rac::GivePlayerWeapon(playerid, 33, 200);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Riffle(200 патронов) за 5500$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 5500);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(13000 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(rifflegun, playerid);
				Rac::GivePlayerMoney(playerid, -13000);
			    Rac::GivePlayerWeapon(playerid, 33, 500);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Riffle(500 патронов) за 13000$");
			    ShowMenuForPlayer(ammonac, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 13000);
				BizzInfo[_bidx][bProds]--;
			}
			case 3: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == ammonac2)
	{
		switch(row)
		{
			case 0:
			{
				if(300 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -300);
			    Rac::GivePlayerWeapon(playerid, 6, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Shovel за 300$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 300);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(400 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -400);
			    Rac::GivePlayerWeapon(playerid, 2, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Golfclub за 400$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 400);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(100 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -100);
			    Rac::GivePlayerWeapon(playerid, 7, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Poolcue за 100$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 100);
				BizzInfo[_bidx][bProds]--;
			}
			case 3:
			{
				if(600 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -600);
			    Rac::GivePlayerWeapon(playerid, 15, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Cane за 600$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 600);
				BizzInfo[_bidx][bProds]--;
			}
			case 4:
			{
				if(200 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -200);
			    Rac::GivePlayerWeapon(playerid, 14, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Flowers за 200$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 200);
				BizzInfo[_bidx][bProds]--;
			}
			case 5:
			{
				if(300 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -300);
			    Rac::GivePlayerWeapon(playerid, 3, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Nightstick за 300$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 300);
				BizzInfo[_bidx][bProds]--;
			}
			case 6:
			{
				if(700 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac2, playerid);
				Rac::GivePlayerMoney(playerid, -700);
			    Rac::GivePlayerWeapon(playerid, 5, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Baseball Bat за 700$");
			    ShowMenuForPlayer(ammonac2, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 700);
				BizzInfo[_bidx][bProds]--;
			}
			case 7: ShowMenuForPlayer(ammonac3, playerid);
			case 8: ShowMenuForPlayer(ammonac, playerid);
		}
	}
	if(current == ammonac3)
	{
		switch(row)
		{
			case 0:
			{
				if(400 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac3, playerid);
				Rac::GivePlayerMoney(playerid, -400);
			    Rac::GivePlayerWeapon(playerid, 10, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Purple Dildo за 400$");
			    ShowMenuForPlayer(ammonac3, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 400);
				BizzInfo[_bidx][bProds]--;
			}
			case 1:
			{
				if(700 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac3, playerid);
				Rac::GivePlayerMoney(playerid, -700);
			    Rac::GivePlayerWeapon(playerid, 11, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие White Dildo за 700$");
			    ShowMenuForPlayer(ammonac3, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 700);
				BizzInfo[_bidx][bProds]--;
			}
			case 2:
			{
				if(500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac3, playerid);
				Rac::GivePlayerMoney(playerid, -500);
			    Rac::GivePlayerWeapon(playerid, 12, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Long White Didlo за 500$");
			    ShowMenuForPlayer(ammonac3, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 500);
				BizzInfo[_bidx][bProds]--;
			}
			case 3:
			{
				if(500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac3, playerid);
				Rac::GivePlayerMoney(playerid, -500);
			    Rac::GivePlayerWeapon(playerid, 13, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие White didlo 2 за 500$");
			    ShowMenuForPlayer(ammonac3, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 500);
				BizzInfo[_bidx][bProds]--;
			}
			case 4:
			{
				if(500 > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!"),ShowMenuForPlayer(ammonac3, playerid);
				Rac::GivePlayerMoney(playerid, -500);
			    Rac::GivePlayerWeapon(playerid, 46, 1);
			    Send(playerid,COLOR_GREEN,"¬ы купили оружие Parachute за 500$");
			    ShowMenuForPlayer(ammonac3, playerid);
				new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(_bidx, 500);
				BizzInfo[_bidx][bProds]--;
			}
			case 5: ShowMenuForPlayer(ammonac2, playerid);
		}
	}
	//
	if(current == GarageMenu) {
		switch(row) {
		case 0: {
				new slot = GetPVarInt(playerid, "SelectedCar"); slot ++;
				if(slot >= TotalVehicleInGarage[playerid]) slot = 0;
				SetPVarInt(playerid, "SelectedCar", slot);
				Veh::Destroy(TempVehicle[playerid]);
				TempVehicle[playerid] = Veh::Create(
				ExtraVehicles[playerid][VehicleInGarage[playerid][slot]][evModel],
				616.0352,-124.1155,997.7648,90.1765,
				ExtraVehicles[playerid][VehicleInGarage[playerid][slot]][evColor1],
				ExtraVehicles[playerid][VehicleInGarage[playerid][slot]][evColor2],
				600
				);
				LinkVehicleToInterior(TempVehicle[playerid], 3);
				SetVehicleVirtualWorld(TempVehicle[playerid], playerid + Pl::Info[playerid][pLocal]);
				ShowMenuForPlayer(GarageMenu, playerid);
			}

		case 1 : {
				Veh::Destroy(TempVehicle[playerid]);
				new bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				new slot = VehicleInGarage[playerid][GetPVarInt(playerid, "SelectedCar")];
				SetPVarInt(playerid, "SelectedCar", -1);

				switch(BizzInfo[bidx][bID]) {
				case Bizz_GarageLS : {
						static const Float:exitPos[][4] = {
							{814.8283,-1551.4712,13.3243,359.5168},
							{836.8582,-1551.6245,13.3071,0.1846}
						};
						new rnd = random(sizeof exitPos);
						Rac::SetPlayerPos(playerid, exitPos[rnd][0], exitPos[rnd][1], exitPos[rnd][2] + 2.0);
						ExtraVehicles[playerid][slot][evID2] = Veh::Create(
						ExtraVehicles[playerid][slot][evModel],
						exitPos[rnd][0], exitPos[rnd][1], exitPos[rnd][2], exitPos[rnd][3],
						ExtraVehicles[playerid][slot][evColor1],
						ExtraVehicles[playerid][slot][evColor2],
						INFINITY
						);
						AutoInfo[ExtraVehicles[playerid][slot][evID2]][aOwner] = playerid;
					}

				case Bizz_GarageLV : {
						static const Float:_exitPos[][4] = {
							{1631.6438,963.5118,10.5859,270.5770},
							{1631.4854,959.2862,10.5494,268.9856}
						};
						new rnd = random(sizeof _exitPos);
						Rac::SetPlayerPos(playerid, _exitPos[rnd][0], _exitPos[rnd][1], _exitPos[rnd][2] + 2.0);
						ExtraVehicles[playerid][slot][evID2] = Veh::Create(
						ExtraVehicles[playerid][slot][evModel],
						_exitPos[rnd][0], _exitPos[rnd][1], _exitPos[rnd][2], _exitPos[rnd][3],
						ExtraVehicles[playerid][slot][evColor1],
						ExtraVehicles[playerid][slot][evColor2],
						INFINITY
						);
						AutoInfo[ExtraVehicles[playerid][slot][evID2]][aOwner] = playerid;
					}

				case Bizz_GarageSF : {
						static const Float:__exitPos[][4] = {
							{-2429.4846,515.1774,29.6367,214.6334},
							{-2425.7083,518.3276,29.7009,222.1388}
						};
						new rnd = random(sizeof __exitPos);
						Rac::SetPlayerPos(playerid, __exitPos[rnd][0], __exitPos[rnd][1], __exitPos[rnd][2] + 2.0);
						ExtraVehicles[playerid][slot][evID2] = Veh::Create(
						ExtraVehicles[playerid][slot][evModel],
						__exitPos[rnd][0], __exitPos[rnd][1], __exitPos[rnd][2], __exitPos[rnd][3],
						ExtraVehicles[playerid][slot][evColor1],
						ExtraVehicles[playerid][slot][evColor2],
						INFINITY
						);
						AutoInfo[ExtraVehicles[playerid][slot][evID2]][aOwner] = playerid;
					}
				}
				SetVehicleNumber(ExtraVehicles[playerid][slot][evID2]);
				ToggleVehicleDoor(ExtraVehicles[playerid][slot][evID2], false);

				Rac::SetPlayerInterior(playerid, 0);
				Rac::SetPlayerVirtualWorld(playerid, 0);
				Rac::PutPlayerInVehicle(playerid, ExtraVehicles[playerid][slot][evID2], 0);
				Rac::TogglePlayerControllable(playerid, true);
				RemoveExtraVehicleFromGarage(playerid, slot);
			}

		case 2 : {
				Veh::Destroy(TempVehicle[playerid]);
				SetPVarInt(playerid, "SelectedCar", -1);
				Pt::Hide(playerid, Td::AutoSolon);
				Rac::TogglePlayerControllable(playerid, true);
				ExitBiz(playerid, Pl::Info[playerid][pLocal] - OFFSET_BIZZ);
			}
		}
	}

	else if(current == AutoSolonMenu) {
		switch(row) {
		case 0: {
				new idx = GetPVarInt(playerid, "SelectedCar"); idx ++;
				new vclass = GetPVarInt(playerid, "VehicleClass");
				if(idx >= ASModelCount[vclass]) idx = 0;
				SetPVarInt(playerid, "SelectedCar", idx);
				Veh::Destroy(TempVehicle[playerid]);
				TempVehicle[playerid] = Veh::Create(AutoSolon[vclass][idx][0], StandPos[vclass][vPos][0], StandPos[vclass][vPos][1], StandPos[vclass][vPos][2], StandPos[vclass][vPos][3], -1, -1, 600);
				Rac::SetPlayerPos(playerid, StandPos[vclass][pPos][0], StandPos[vclass][pPos][1], StandPos[vclass][pPos][2]);
				SetPlayerCameraPos(playerid, StandPos[vclass][pCPos][0], StandPos[vclass][pCPos][1], StandPos[vclass][pCPos][2]);
				SetPlayerCameraLookAt(playerid, StandPos[vclass][pCLookAt][0], StandPos[vclass][pCLookAt][1], StandPos[vclass][pCLookAt][2]);
				SetVehicleVirtualWorld(TempVehicle[playerid], playerid + Pl::Info[playerid][pLocal]);

				format(temp, sizeof temp, "~g~ID:~w~ %i~n~~g~MODEL: ~w~%s ~n~~g~PRICE: ~w~$%i ~n~~g~MAX SPEED: ~w~%i KM/H ~n~~g~CLASS: ~w~%c ~n~~g~in availability: ~w~yes",
				AutoSolon[vclass][idx][0], VehicleNames[AutoSolon[vclass][idx][0] - 400], AutoSolon[vclass][idx][1],
				floatround(MaxVehicleSpeed[AutoSolon[vclass][idx][0] - 400]) - 35, AClassChar[vclass]);
				Pt::SetString(playerid, Td::AutoSolon, temp);
				ShowMenuForPlayer(AutoSolonMenu, playerid);
			}
		case 1: {
				new idx = GetPVarInt(playerid, "SelectedCar"); idx --;
				new vclass = GetPVarInt(playerid, "VehicleClass");
				if(idx < 0) idx = ASModelCount[vclass] - 1;
				SetPVarInt(playerid, "SelectedCar", idx);
				Veh::Destroy(TempVehicle[playerid]);
				TempVehicle[playerid] = Veh::Create(AutoSolon[vclass][idx][0], StandPos[vclass][vPos][0], StandPos[vclass][vPos][1], StandPos[vclass][vPos][2], StandPos[vclass][vPos][3], -1, -1, 600);
				Rac::SetPlayerPos(playerid, StandPos[vclass][pPos][0], StandPos[vclass][pPos][1], StandPos[vclass][pPos][2]);
				SetPlayerCameraPos(playerid, StandPos[vclass][pCPos][0], StandPos[vclass][pCPos][1], StandPos[vclass][pCPos][2]);
				SetPlayerCameraLookAt(playerid, StandPos[vclass][pCLookAt][0], StandPos[vclass][pCLookAt][1], StandPos[vclass][pCLookAt][2]);
				SetVehicleVirtualWorld(TempVehicle[playerid], playerid + Pl::Info[playerid][pLocal]);

				format(temp, sizeof temp, "~g~ID:~w~ %i~n~~g~MODEL: ~w~%s ~n~~g~PRICE: ~w~$%i ~n~~g~MAX SPEED: ~w~%i KM/H ~n~~g~CLASS: ~w~%c ~n~~g~in availability: ~w~yes",
				AutoSolon[vclass][idx][0], VehicleNames[AutoSolon[vclass][idx][0] - 400], AutoSolon[vclass][idx][1],
				floatround(MaxVehicleSpeed[AutoSolon[vclass][idx][0] - 400]) - 35, AClassChar[vclass]);
				Pt::SetString(playerid, Td::AutoSolon, temp);
				ShowMenuForPlayer(AutoSolonMenu, playerid);
			}
		case 2 : {
				new idx = GetPVarInt(playerid, "SelectedCar");
				new vclass = GetPVarInt(playerid, "VehicleClass");
				if(Rac::GetPlayerMoney(playerid) >= AutoSolon[vclass][idx][1]) {
					SetPVarInt(playerid, "SelectedCar", -1);
					DeletePVar(playerid, "VehicleClass");
					Veh::Destroy(TempVehicle[playerid]);
					Pt::Hide(playerid, Td::AutoSolon);

					new biz = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
					AddExtraVehicle(playerid, AutoSolon[vclass][idx][0], 0, 0, 0, 0, random(125), random(125), PARK_GARAGE, 0);
					GiveBizzProfit(biz, PERCENT(AutoSolon[vclass][idx][1], 20));
					BizzInfo[biz][bProds] --;
					Rac::GivePlayerMoney(playerid, -AutoSolon[vclass][idx][1]);
					Rac::TogglePlayerControllable(playerid, true);
					ExitBiz(playerid, biz);

					format(temp, sizeof temp, "~r~-$%i", AutoSolon[vclass][idx][1]);
					GameTextForPlayer(playerid, temp, 1000, 1);
					format(temp, sizeof temp, "* ¬ы купили личный транспорт %s, стоимостью: $%i", VehicleNames[AutoSolon[vclass][idx][0] - 400], AutoSolon[vclass][idx][1]);
					Send(playerid, COLOR_LIGHTBLUE, temp);
					Send(playerid, COLOR_LIGHTBLUE, "* “ранспорт был доставлен в ближайший гараж!");
				} else {
					ShowMenuForPlayer(AutoSolonMenu, playerid);
					Send(playerid, COLOR_GREY, "* ” ¬ас не хватает средств!");
				}
			}

		case 3 : {
				SetPVarInt(playerid, "SelectedCar", -1);
				DeletePVar(playerid, "VehicleClass");
				Veh::Destroy(TempVehicle[playerid]);
				Pt::Hide(playerid, Td::AutoSolon);
				Rac::TogglePlayerControllable(playerid, true);
				ExitBiz(playerid, Pl::Info[playerid][pLocal] - OFFSET_BIZZ);
			}
		}
	}

	else if(current == IntMenu) {
		switch(row) {
		case 0: {
				new idx = GetPVarInt(playerid, "SelectedItem"); idx ++;
				if(idx >= sizeof(HouseInt)) idx = 0;
				SetPVarInt(playerid, "SelectedItem", idx);
				Rac::SetPlayerPos(playerid, HouseInt[idx][intX], HouseInt[idx][intY], HouseInt[idx][intZ]);
				Rac::SetPlayerInterior(playerid, HouseInt[idx][intH]);
				Rac::SetPlayerVirtualWorld(playerid, 999);
				SetPlayerCameraPos(playerid, HouseInt[idx][intX], HouseInt[idx][intY], HouseInt[idx][intZ]);
				SetPlayerCameraLookAt(playerid, HouseInt[idx][intX] - 100.0, HouseInt[idx][intY] - 100.0, HouseInt[idx][intZ] - 100.0);
				SetCameraBehindPlayer(playerid);
				format(temp, sizeof temp, "~n~~n~~n~~n~~n~~n~~n~~n~~g~price: ~w~$%i", HouseInt[idx][intPrice]);
				GameTextForPlayer(playerid, temp, 5000, 6);
				ShowMenuForPlayer(IntMenu, playerid);
			}

		case 1: {
				new idx = GetPVarInt(playerid, "SelectedItem"); idx --;
				if(idx < 0) idx = sizeof(HouseInt)-1;
				SetPVarInt(playerid, "SelectedItem", idx);
				Rac::SetPlayerPos(playerid, HouseInt[idx][intX], HouseInt[idx][intY], HouseInt[idx][intZ]);
				Rac::SetPlayerInterior(playerid, HouseInt[idx][intH]);
				Rac::SetPlayerVirtualWorld(playerid, 999);
				SetPlayerCameraPos(playerid, HouseInt[idx][intX], HouseInt[idx][intY], HouseInt[idx][intZ]);
				SetPlayerCameraLookAt(playerid, HouseInt[idx][intX] - 100.0, HouseInt[idx][intY] - 100.0, HouseInt[idx][intZ] - 100.0);
				SetCameraBehindPlayer(playerid);
				format(temp, sizeof(temp), "~n~~n~~n~~n~~n~~n~~n~~n~~g~price: ~w~$%i", HouseInt[idx][intPrice]);
				GameTextForPlayer(playerid, temp, 5000, 6);
				ShowMenuForPlayer(IntMenu, playerid);
			}

		case 2: {
				new idx = GetPVarInt(playerid, "SelectedItem");
				format(dialog, sizeof dialog, "÷ена интерьера:\t$%i\n¬ы точно хотите купить этот интерьер?", HouseInt[idx][intPrice]);
				SPD(playerid, D_HMENU+11, 0, "[House Menu] > »нтерьер", dialog,  "ƒј", "Ќ≈“");
			}

		case 3 : {
				SetPVarInt(playerid, "SelectedItem", -1);
				Rac::SpawnPlayer(playerid);
			}
		}
	}

	else if(current == SAInteriorsMenu) {
		switch(row) {
		case 0 : {
				new i = GetPVarInt(playerid, "SelectedItem"); i ++;
				if(i >= sizeof(SAInteriors)) i = 0;

				Rac::SetPlayerPos(playerid, SAInteriors[i][iX], SAInteriors[i][iY], SAInteriors[i][iZ]);
				SetPlayerFacingAngle(playerid, SAInteriors[i][iA]);
				Rac::SetPlayerInterior(playerid, SAInteriors[i][iI]);
				Rac::SetPlayerVirtualWorld(playerid, 100+playerid);
				SetPVarInt(playerid, "SelectedItem",i);
				format(temp, sizeof temp, "~n~~n~~n~~n~~n~~n~~n~~n~~g~%s(id:%i)", SAInteriors[i][int_Name], i);
				GameTextForPlayer(playerid, temp, 5000, 6);
				ShowMenuForPlayer(SAInteriorsMenu, playerid);
			}

		case 1 : {
				new i = GetPVarInt(playerid, "SelectedItem"); i --;
				if(i < 0) i = sizeof(SAInteriors)-1;

				Rac::SetPlayerPos(playerid, SAInteriors[i][iX], SAInteriors[i][iY], SAInteriors[i][iZ]);
				SetPlayerFacingAngle(playerid, SAInteriors[i][iA]);
				Rac::SetPlayerInterior(playerid, SAInteriors[i][iI]);
				Rac::SetPlayerVirtualWorld(playerid, 100+playerid);
				format(temp, sizeof temp, "~n~~n~~n~~n~~n~~n~~n~~n~~g~%s(id:%i)", SAInteriors[i][int_Name], i);
				GameTextForPlayer(playerid, temp, 5000, 6);
				SetPVarInt(playerid, "SelectedItem",i);
				ShowMenuForPlayer(SAInteriorsMenu, playerid);
			}

		case 2 : {
				Pl::SetSpawnInfo(playerid);
				Rac::SpawnPlayer(playerid);
			}
		}
	}

	//===================== ѕролапс ================================
	else if(current == ClothesMenu) {
		switch(row) {
		case 0 : {
				Container::At(Pl::FracID(playerid), Container::Next, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(ClothesMenu, playerid);
			}

		case 1 : {
				Container::At(Pl::FracID(playerid), Container::Previous, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(ClothesMenu, playerid);
			}

		case 2 : {
				if(Pl::Info[playerid][pLocal] != 0) {
					Rac::SetPlayerVirtualWorld(playerid, BizzInfo[Pl::Info[playerid][pLocal] - OFFSET_BIZZ][bVirtual]);
				}
				Pl::Info[playerid][pChar] = ChosenSkin[playerid];
				Pl::SetSpawnInfo(playerid);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ChosenSkin[playerid] = 0;
				SelectCharPlace[playerid] = 0;
				Rac::TogglePlayerControllable(playerid, 1);
				SetCameraBehindPlayer(playerid);
			}

		case 3 : {
				if(Pl::Info[playerid][pLocal] != 0) {
					Rac::SetPlayerVirtualWorld(playerid, BizzInfo[Pl::Info[playerid][pLocal] - OFFSET_BIZZ][bVirtual]);
				}
				SetCameraBehindPlayer(playerid);
				SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
				Rac::TogglePlayerControllable(playerid, 1);
			}
		}
	}

	else if(current == SkinMenu) {
		switch(row) {
		case 0 : {
				Container::At(99+Pl::Info[playerid][pSex], Container::Next, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(SkinMenu, playerid);
			}

		case 1 : {
				Container::At(99+Pl::Info[playerid][pSex], Container::Previous, SelectCharPlace[playerid], ChosenSkin[playerid]);
				SetPlayerSkin(playerid, ChosenSkin[playerid]);
				ShowMenuForPlayer(SkinMenu, playerid);
			}

		case 2 : {
				ChosenSkin[playerid] = 0;
				SelectCharPlace[playerid] = 0;
				MedicBill[playerid] = false;
				PlayerLogged{playerid} = true;
				Pl::Info[playerid][pReg] = 1;
				Pl::Info[playerid][pLevel] = START_LEVEL;
				//Pl::Info[playerid][pLic][0] = 1;
				//Pl::Info[playerid][pLic][3] = 1;
				//Pl::Info[playerid][pLic][1] = 1;
				//Pl::Info[playerid][pLic][2] = 1;
				Pl::Info[playerid][pChar] = GetPlayerSkin(playerid);

				GivePlayerBankMoney(playerid, 10000);
				Rac::GivePlayerMoney(playerid, START_MONEY);
				Rac::TogglePlayerControllable(playerid, 1);
				Pl::Update(playerid);

				format(temp, sizeof temp, "* %s (ID: %i) прокралс€(ась) на ..::"#__SERVER_PREFIX""#__SERVER_NAME_LC"::.. [RUS]", GetName(playerid), playerid);
				sendToLog(COLOR_GREY, temp);

				Pl::SetSpawnInfo(playerid);
				Rac::SpawnPlayer(playerid);

				Send(playerid, COLOR_LIGHTGREEN, "ƒобро пожаловать на ..::"#__SERVER_PREFIX""#__SERVER_NAME_LC"::.. [RUS]");
				ShowDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "WELCOME", "dialog/welcome.txt", "OK", "");
			}
		}
	}

	else if(current == PizaMenu) {
		new Float:health;
		GetPlayerHealth(playerid, health);
		if(Rac::GetPlayerMoney(playerid) >= PizzaInfo[row][bPrice]) {
			if(health < 100.0) {
				new biz = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(biz, PizzaInfo[row][bPrice]);
				BizzInfo[biz][bProds] --;
				Rac::GivePlayerHealth(playerid, PizzaInfo[row][bHP], 100.0);
				Rac::GivePlayerMoney(playerid, -PizzaInfo[row][bPrice]);

				GetPlayerName(playerid, plname, 24);
				format(temp, sizeof temp, "* %s купил(а) %s.", plname, PizzaInfo[row][bDescription]);
				ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
				format(temp, sizeof temp, "~g~+%.1f HP", PizzaInfo[row][bHP]);
				GameTextForPlayer(playerid, temp, 5000, 1);
				format(temp, sizeof temp, "* %.1f", health);
				Send(playerid, COLOR_PURPLE, temp);

				Rac::TogglePlayerControllable(playerid, false);
				ShowMenuForPlayer(Menu:PizaMenu, playerid);
			} else {
				Send(playerid, COLOR_PURPLE, "* ¬ы сыты!");
				Rac::TogglePlayerControllable(playerid, true);
			}
		} else {
			Send(playerid, COLOR_PURPLE, "* ” ¬ас нет столько денег!");
			Rac::TogglePlayerControllable(playerid, true);
		}
	}

	else if(current == BurgerMenu) {
		new Float:health;
		GetPlayerHealth(playerid, health);
		if(Rac::GetPlayerMoney(playerid) >= BurgerInfo[row][bPrice]) {
			if(health < 100.0) {
				new biz = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
				GiveBizzProfit(biz, BurgerInfo[row][bPrice]);
				BizzInfo[biz][bProds] --;
				Rac::GivePlayerHealth(playerid, BurgerInfo[row][bHP], 100.0);
				GetPlayerName(playerid, plname, 24);
				format(temp, sizeof temp, "* %s купил(а) %s.", plname, BurgerInfo[row][bDescription]);
				Rac::GivePlayerMoney(playerid, -BurgerInfo[row][bPrice]);
				ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
				format(temp, sizeof temp, "~g~+%.1f HP", BurgerInfo[row][bHP]);
				GameTextForPlayer(playerid, temp, 5000, 1);
				format(temp, sizeof temp, "* %.1f", health);
				Send(playerid, COLOR_PURPLE, temp);
				Rac::TogglePlayerControllable(playerid,0);
				ShowMenuForPlayer(BurgerMenu, playerid);
			} else {
				Send(playerid, COLOR_PURPLE, "* ¬ы сыты!");
				Rac::TogglePlayerControllable(playerid,1);
			}
		} else {
			Send(playerid, COLOR_PURPLE, "* ” ¬ас нет столько денег!");
			Rac::TogglePlayerControllable(playerid,1);
		}
	}

	else if(current == BarMenu) {
		new Float:health;
		GetPlayerHealth(playerid, health);
		if(Rac::GetPlayerMoney(playerid) >= DrinkInfo[row][dPrice]) {
			if(strcmp(DrinkInfo[row][dName], "Cigarette", true) == 0) {
				SetPlayerSpecialAction(playerid, SPECIAL_ACTION_SMOKE_CIGGY);
				Rac::TogglePlayerControllable(playerid,1);

			} else if(health < 160.0) {
				Rac::GivePlayerHealth(playerid, DrinkInfo[row][dHP], 160.0);
				Rac::GivePlayerMoney(playerid, -DrinkInfo[row][dPrice]);

				if(GetPlayerDrunkLevel(playerid) < 20000 && DrinkInfo[row][dDrunk]) {
					SetPlayerDrunkLevel(playerid,GetPlayerDrunkLevel(playerid)+1000);
					Pl::Drunk[playerid] += DrinkInfo[row][dDrunk];
				}

				switch(row) {
				case 0..3   : SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DRINK_SPRUNK);
				case 4..7   : SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DRINK_BEER);
				case 8..10  : SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DRINK_WINE);
					default		: SetPlayerSpecialAction(playerid, SPECIAL_ACTION_DRINK_SPRUNK);
				}

				GetPlayerName(playerid, plname, 24);
				format(temp, sizeof temp, "* %s выпил(а) %s.", plname, DrinkInfo[row][dName]);
				ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

				format(temp, sizeof temp, "~g~+%.1f HP", DrinkInfo[row][dHP]);
				GameTextForPlayer(playerid, temp, 5000, 1);

				format(temp, sizeof temp, "* %.1f", health);
				Send(playerid, COLOR_PURPLE, temp);

				Rac::TogglePlayerControllable(playerid,0);
				ShowMenuForPlayer(BarMenu, playerid);
			} else {
				Send(playerid, COLOR_PURPLE, "* Ѕармен отказываетс€ вам наливать!");
				Rac::TogglePlayerControllable(playerid,1);
			}
		} else {
			Send(playerid, COLOR_PURPLE, "* ” ¬ас нет столько денег!");
			Rac::TogglePlayerControllable(playerid,1);
		}
	}

	else if(current == HitmanMenu) {
		if(Rac::GetPlayerMoney(playerid) >= HitmanAmmo[row][gPrice]) {
			if(Pl::Info[playerid][pRank] >= HitmanAmmo[row][gRank]) {
				Rac::GivePlayerMoney(playerid, -HitmanAmmo[row][gPrice]);
				Rac::GivePlayerWeapon(playerid, HitmanAmmo[row][gID], HitmanAmmo[row][gAmmo]);
				format(src, sizeof(src), "~r~-$%i", HitmanAmmo[row][gPrice]);
				GameTextForPlayer(playerid, src, 3000, 1);
				Rac::TogglePlayerControllable(playerid, 0);
				ShowMenuForPlayer(HitmanMenu, playerid);
			} else {
				Send(playerid, COLOR_GREY, "* ¬ам не подходит это оружие!");
				Rac::TogglePlayerControllable(playerid, 1);
			}
		} else {
			Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
			Rac::TogglePlayerControllable(playerid, 1);
		}
	}

	else if(current == Ammu1Menu) {
		new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
		if(Rac::GetPlayerMoney(playerid) >= Ammu1Info[row][gPrice]) {
			Rac::GivePlayerMoney(playerid, -Ammu1Info[row][gPrice]);
			GiveBizzProfit(_bidx, Ammu1Info[row][gPrice]);
			BizzInfo[_bidx][bProds]--;
			Rac::GivePlayerWeapon(playerid, Ammu1Info[row][gID], Ammu1Info[row][gAmmo]);
			GetPlayerName(playerid, plname, 24);
			format(temp, sizeof temp, "* %s купил(а) %s.", plname, Ammu1Info[row][gName]);
			ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			format(temp, sizeof temp, "~r~-$%i", Ammu1Info[row][gPrice]);
			GameTextForPlayer(playerid, temp, 3000, 1);
			Rac::TogglePlayerControllable(playerid,0);
			ShowMenuForPlayer(Ammu1Menu, playerid);
		} else {
			Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
			Rac::TogglePlayerControllable(playerid, 1);
		}
	}

	else if(current == Ammu2Menu) {
		new _bidx = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
		if(Rac::GetPlayerMoney(playerid) >= Ammu2Info[row][gPrice]) {
			Rac::GivePlayerMoney(playerid, -Ammu2Info[row][gPrice]);
			if(0 <= _bidx < sizeof(BizzInfo)) {
				GiveBizzProfit(_bidx, Ammu2Info[row][gPrice]);
				BizzInfo[_bidx][bProds]--;
			}
			Rac::GivePlayerWeapon(playerid, Ammu2Info[row][gID], Ammu2Info[row][gAmmo]);
			GetPlayerName(playerid, plname, 24);
			format(temp, sizeof temp, "* %s купил(а) %s.", plname, Ammu2Info[row][gName]);
			ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			format(temp, sizeof temp, "~r~-$%i", Ammu2Info[row][gPrice]);
			GameTextForPlayer(playerid, temp, 3000, 1);
			Rac::TogglePlayerControllable(playerid,0);
			ShowMenuForPlayer(Ammu2Menu, playerid);
		} else {
			Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
			Rac::TogglePlayerControllable(playerid, 1);
		}
	}

	else if(current == BuyMenu)
	{
		new biz = Pl::Info[playerid][pLocal] - OFFSET_BIZZ;
		switch(row)
		{
		case 0 :
		{
				if(Rac::GetPlayerMoney(playerid) >= TelephonePrice) {
					new randphone = rndNum(100000,899999);
					Pl::Info[playerid][pNumber] = randphone;
					format(temp, sizeof(temp), "~r~-$%d", TelephonePrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					Rac::GivePlayerMoney(playerid, -TelephonePrice);
					GiveBizzProfit(biz, TelephonePrice);
					BizzInfo[biz][bProds]--;
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					format(temp, sizeof(temp), "¬ы купили телефон, номер: %d", randphone);
					Send(playerid, COLOR_GRAD4, temp);
					Send(playerid, COLOR_GRAD5, "* ¬ы можете посмотреть свой номер, прописав /stats");
				}
			}

		case 1 : {
				new __bidx = GetIndexFromBizID(Bizz_Lottery);
				if(Rac::GetPlayerMoney(playerid) >= ScrathCardPrice) {
					Rac::GivePlayerMoney(playerid, -ScrathCardPrice);
					GiveBizzProfit(biz, PERCENT(ScrathCardPrice,10));
					GiveBizzProfit(__bidx, ScrathCardPrice - PERCENT(ScrathCardPrice,10));
					format(temp, sizeof(temp), "~r~-$%d", ScrathCardPrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					new prize;
					new randcard1 = random(10);
					new randcard2 = random(10);
					new randcard3 = random(10);

					temp[0] = '\0';
					if(randcard1 >= 5) {
						strcat(temp, "~b~] ");
						randcard1 = 1;
					} else if(randcard1 <= 4 && randcard1 >= 2) {
						strcat(temp, "~g~] ");
						randcard1 = 2;
					} else if(randcard1 < 2) {
						strcat(temp, "~y~] ");
						randcard1 = 3;
					}

					if(randcard2 >= 5) {
						strcat(temp, "~b~] ");
						randcard2 = 1;
					} else if(randcard2 <= 4 && randcard2 >= 2) {
						strcat(temp, "~g~] ");
						randcard2 = 2;
					} else if(randcard2 < 2) {
						strcat(temp, "~y~] ");
						randcard2 = 3;
					}

					if(randcard3 >= 5) {
						strcat(temp, "~b~] ");
						randcard3 = 1;
					} else if(randcard3 <= 4 && randcard3 >= 2) {
						strcat(temp, "~g~] ");
						randcard3 = 2;
					} else if(randcard3 < 2) {
						strcat(temp, "~y~] ");
						randcard3 = 3;
					}

					if(randcard1 == randcard2 && randcard1 == randcard3) {
						if(randcard1 > 5) prize = 2500;
						if(randcard1 <= 4 && randcard1 >= 2) prize = 1500;
						if(randcard1 < 2) prize = 500;
						Rac::GivePlayerMoney(playerid, prize);
						BizzInfo[bidx][bSafe] -= prize;
						format(temp, sizeof(temp), "%s~n~~n~~w~~g~$%i", temp, prize);
					} else {
						strcat(temp, "~n~~n~~w~~r~$0");
					}
					GameTextForPlayer(playerid, temp, 3000, 3);
				}
			}

		case 2 : {
				if(Rac::GetPlayerMoney(playerid) >= PhoneBookPrice) {
					Rac::GivePlayerMoney(playerid, -PhoneBookPrice);
					GiveBizzProfit(biz, PhoneBookPrice);
					BizzInfo[biz][bProds]--;
					format(temp, sizeof(temp), "~r~-$%d", PhoneBookPrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					Pl::Info[playerid][pPhoneBook] = 1;
					format(temp, sizeof(temp), "¬ы купили телефонную книгу. “еперь можете узнать номер телефона любого игрока!");
					Send(playerid, COLOR_GRAD4, temp);
					Send(playerid, COLOR_WHITE, "»спользуйте: /number [id/name].");
				}
			}

		case 3 : {
				if(Rac::GetPlayerMoney(playerid) >= DicePrice) {
					gDice[playerid] = true;
					Rac::GivePlayerMoney(playerid, -DicePrice);
					GiveBizzProfit(biz, DicePrice);
					BizzInfo[biz][bProds]--;
					format(temp, sizeof(temp), "~r~-$%d", DicePrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					format(temp, sizeof(temp), "¬ы купили кубики.");
					Send(playerid, COLOR_GRAD4, temp);
					Send(playerid, COLOR_WHITE, "»спользуйте: /dice");
				}
			}

		case 4 : {
				if(Rac::GetPlayerMoney(playerid) >= CarKeyPrice) {
					if(gLastCar[playerid] != INVALID_VEHICLE_ID) {
						Rac::GivePlayerMoney(playerid, -CarKeyPrice);
						GiveBizzProfit(biz, CarKeyPrice);
						BizzInfo[biz][bProds]--;
						format(temp, sizeof(temp), "~r~-$%d", CarKeyPrice);
						GameTextForPlayer(playerid, temp, 5000, 1);
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						HireCar[playerid] = gLastCar[playerid];
						format(temp, sizeof(temp), "¬ы купили ключи дл€ тачки.");
						Send(playerid, COLOR_GRAD4, temp);
					}
					else Send(playerid, COLOR_WHITE, "” ¬ас нет транспортного средства!");
				}
			}

		case 5 : {
				if(Rac::GetPlayerMoney(playerid) >= CandomPrice) {
					Condom[playerid] ++;
					GiveBizzProfit(biz, CandomPrice);
					BizzInfo[biz][bProds]--;
					Rac::GivePlayerMoney(playerid, -CandomPrice);
					format(temp, sizeof(temp), "~r~-$%d", CandomPrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					format(temp, sizeof(temp), "¬ы купили гандон!");
					Send(playerid, COLOR_GRAD4, temp);
				}
			}

		case 6 : {
				if(Rac::GetPlayerMoney(playerid) >= CDPlayerPrice) {
					Pl::Info[playerid][pCDPlayer] = 1;
					Rac::GivePlayerMoney(playerid, -CDPlayerPrice);
					GiveBizzProfit(biz, CDPlayerPrice);
					BizzInfo[biz][bProds]--;
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					format(temp, sizeof(temp), "~r~-$%d", CDPlayerPrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					format(temp, sizeof(temp), "* %s купил(а) CD-Player.", GetName(playerid));
					ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
					Send(playerid, COLOR_WHITE, "»спользуйте: /music");
				}
			}
		case 7 : {
				if(Rac::GetPlayerMoney(playerid) >= GPSPrice)
				{
					Pl::Info[playerid][pGPS] = 1;
					Rac::GivePlayerMoney(playerid, -GPSPrice);
					GiveBizzProfit(biz, GPSPrice);
					BizzInfo[biz][bProds]--;
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					format(temp, sizeof(temp), "~r~-$%d", GPSPrice);
					GameTextForPlayer(playerid, temp, 5000, 1);
					format(temp, sizeof(temp), "* %s купил(а) GPS.", GetName(playerid));
					ProxDetector(10.0, playerid, temp, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
					Send(playerid, COLOR_WHITE, "»спользуйте: /gps");
				}
			}
		}
		ShowMenuForPlayer(BuyMenu, playerid);
		Rac::TogglePlayerControllable(playerid, 0);
	}
	return 1;
}

public OnPlayerExitedMenu(playerid) {
	new Menu:current = GetPlayerMenu(playerid);
	if(current == IntMenu) {
		ShowMenuForPlayer(IntMenu, playerid);
	}

	else if(current == SkinMenu) {
		ShowMenuForPlayer(SkinMenu, playerid);
	}

	else if(current == ClothesMenu) {
		ShowMenuForPlayer(ClothesMenu, playerid);
	}

	else if(current == AutoSolonMenu) {
		ShowMenuForPlayer(AutoSolonMenu, playerid);
	}

	else if(current == GarageMenu) {
		ShowMenuForPlayer(GarageMenu, playerid);
	}

	else {
		Rac::TogglePlayerControllable(playerid, 1);
	}
	return 1;
}

public OnPlayerEnterVehicle(playerid, vehicleid, ispassenger) {
	if(gCarLock{vehicleid} && !ispassenger) return Rac::Kick(playerid, "NOP SetVehicleParams");

	if(GetVehicleModel(vehicleid) == 519 && ispassenger) {
		Pl::CarInt[playerid] = vehicleid;
		Rac::SetPlayerPos(playerid, 1.8050,23.2547,1199.5938);
		Rac::SetPlayerVirtualWorld(playerid, vehicleid);
		Rac::SetPlayerFacingAngle(playerid, 0);
		Rac::SetPlayerInterior(playerid, 1);
		SetCameraBehindPlayer(playerid);
	}
	return 1;
}

public OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid) {
	//	Rac::TogglePlayerControllable(playerid, false);
	//	SetTimerEx(""#Rac::"TogglePlayerControllable", 2000, false, "ii", playerid, 1);
	new Float:x, Float:y, Float:z;
	GetPlayerPos(playerid, x, y, z);
	Streamer::UpdateEx(playerid, x, y, z, GetPlayerVirtualWorld(playerid), newinteriorid);
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate) {
	if((newstate == 2 && oldstate == 2) || (newstate == 3 && oldstate == 2) || (newstate == 2 && oldstate == 3)) {
		return Rac::Kick(playerid, "AutoDrive");
	}
    if(newstate == PLAYER_STATE_PASSENGER)
    {
        if(GetPlayerWeapon(playerid) != 29 && GetPlayerWeapon(playerid) != 30 && GetPlayerWeapon(playerid) != 31) SetPlayerArmedWeapon(playerid,0);
    }
	if(Pl::isLogged(playerid)) {
		new fracid = Pl::FracID(playerid), vehid = GetPlayerVehicleID(playerid), oldvehid = gLastCar[playerid];

		switch(newstate) {
		case PLAYER_STATE_ONFOOT : {
				Pt::Hide(playerid, Pt::Fuel[playerid]);
				Pt::Hide(playerid, Pt::Spec[playerid]);
				Pt::Hide(playerid, Pt::Status[playerid]);
				Pt::SetString(playerid, Pt::Name[playerid], "_");

				if(oldvehid != INVALID_VEHICLE_ID) {
					if(TransportDuty[playerid] > 0) {
						if(TransportDuty[playerid] == 1) TaxiDrivers -= 1;
						else if(TransportDuty[playerid] == 2) BusDrivers -= 1;
						MG2[playerid] = 0;
						TransportDuty[playerid] = 0;
						TransportValue[playerid] = 0;
						TransportMoney[playerid] = 0;
						DestroyDynamicRaceCP(checkpointb[playerid]);
						DestroyDynamic3DTextLabel(AttachText[oldvehid]);
						Rac::GivePlayerMoney(playerid, TransportMoney[playerid]);
						Send(playerid, COLOR_LIGHTBLUE, "* ¬ы теперь не на дежурстве!");
					}

					Iter::Remove(vehiclePassengers[oldvehid], playerid);

					GetVehicleParamsEx(oldvehid, engine, light, alarm, doors, bonnet, boot, objective);
					if(objective > 0) {
						new count;
						foreach(new i: vehiclePassengers[oldvehid]) {
							if(Bl::Info[i][Bl::Finder] != INVALID_PLAYER_ID) {
								count ++;
							}
						}
						if(!count) {
							SetVehicleParamsEx(oldvehid, engine, light, alarm, doors, bonnet, boot, false);
						}
					}
				}

				new driver = TransportDriver[playerid];
				if(TransportCost[playerid] > 0 && driver != INVALID_PLAYER_ID) {
					if(IsPlayerConnected(driver)) {
						TransportMoney[driver] += TransportCost[playerid];
						TransportTime[driver] = 0;
						TransportCost[driver] = 0;
						format(src, sizeof(src), "~w~The ride cost~n~~r~$%d",TransportCost[playerid]);
						GameTextForPlayer(playerid, src, 5000, 1);
						format(src, sizeof(src), "~w~Passenger left the car~n~~g~Earned $%d",TransportCost[playerid]);
						GameTextForPlayer(driver, src, 5000, 1);
						Rac::GivePlayerMoney(playerid, -TransportCost[playerid]);
						TransportCost[playerid] = 0;
						TransportTime[playerid] = 0;
						TransportDriver[playerid] = INVALID_PLAYER_ID;
					}
				}

				if(Bl::Info[playerid][Bl::Finder] != INVALID_PLAYER_ID) {
					GetPlayerPos(playerid, posx, posy, posz);
					Bl::Info[Bl::Info[playerid][Bl::Finder]][Bl::Marker] = CreateDynamicCP(posx, posy, posz, 1.6, -1, -1, Bl::Info[playerid][Bl::Finder], 200.0);
					foreach(new i: inStreamPlayers[playerid]) {
						if(Bl::Info[i][Bl::Observe] == playerid){
							Bl::Info[i][Bl::Marker] = CreateDynamicCP(posx, posy, posz, 1.6, -1, -1, i, 200.0);
						}
					}
				}
			}

		case PLAYER_STATE_DRIVER : {
				new seatid = GetPlayerVehicleSeat(playerid);
				new model = GetVehicleModel(vehid);
				if(seatid != 128) {
					if(!seatid) {
						if(!(400 <= model <= 611) || MaxPassengers[model - 400 >>> 3] >>> ((model - 400 & 7) << 2) & 0xF == 15) {
							return Rac::Kick(playerid, "Crasher");
						}
					} else {
						return Rac::Kick(playerid, "Crasher");
					}
				}

				new vehtype = GetVehicleType(model);
				switch(vehtype) {
				case VEHICLE_TYPE_BOAT : {
						if(Pl::Info[playerid][pLic][2] < 1) {
							Send(playerid, COLOR_GREY, "* ” ¬ас нет лицензии на водный транспорт!");
							return Rac::RemovePlayerFromVehicle(playerid);
						}
					}

				case VEHICLE_TYPE_AIRPLANE, VEHICLE_TYPE_HELICOPTER : {
						if(Pl::Info[playerid][pLic][1] < 1) {
							if(!TakingLesson[playerid]) {
								Send(playerid, COLOR_GREY, "* ” ¬ас нет лицензии на воздушный транспорт!");
								return Rac::RemovePlayerFromVehicle(playerid);
							}
						}
					}

				case VEHICLE_TYPE_AUTO : {
						if(Pl::Info[playerid][pLic][0] < 1)
						{
							if(!TakingLesson[playerid])
							{
								if(Pl::Info[playerid][pWantedL] < 6)
								{
									Pl::Info[playerid][pWantedL] += 1;
									SetPlayerCriminal(playerid, 999, "≈зда без прав");
								}
								Send(playerid, COLOR_GREY, "* ” ¬ас нет лицензии на легковой транспорт!");
								return Rac::RemovePlayerFromVehicle(playerid);
							}
						}
					}
				}

				new fc_frac, fc_rank;
				if(Fc::GetInfo(vehid, "fr", fc_frac, fc_rank)) {
					if(fc_frac == 11) {
						if(TakingLesson[playerid]) {
						} else {
							if(fc_frac == fracid) {
								if(fc_rank > Pl::Info[playerid][pRank]) {
									format(src, sizeof(src), "* Ётот транспорт доступен с ранга %s[%i]", RankInfo[fc_frac][fc_rank], fc_rank);
									Send(playerid, COLOR_GREY, src);
									return Rac::RemovePlayerFromVehicle(playerid);
								}
							} else {
								format(src, sizeof(src), "* “ранспорт зареверзирован (%s)", FracInfo[fc_frac][fName]);
								Send(playerid,COLOR_GREY, src);
								return Rac::RemovePlayerFromVehicle(playerid);
							}
						}
					} else if(fc_frac == fracid) {
						if(fc_rank > Pl::Info[playerid][pRank]) {
							format(src, sizeof(src), "* Ётот транспорт доступен с ранга %s[%i]", RankInfo[fc_frac][fc_rank], fc_rank);
							Send(playerid, COLOR_GREY, src);
							return Rac::RemovePlayerFromVehicle(playerid);
						}
					} else {
						format(src, sizeof(src), "* “ранспорт зареверзирован (%s)", FracInfo[fc_frac][fName]);
						Send(playerid,COLOR_GREY, src);
						return Rac::RemovePlayerFromVehicle(playerid);
					}
				}

				new vehjob;
				if(GetVehDescription(vehid, "j", vehjob)) {
					if(vehjob) {
						if(Pl::Info[playerid][pJob] != vehjob && !EditMode[playerid]) {
							static const jnames[][] = {
								"-", "-", "-", "-", "-", "-",
								"ћеханики", "-", "-",
								"јвтобусники",
								"ƒальнобойщики"
							};
							format(src, sizeof(src), "* “ранспорт зареверзирован (%s)", jnames[vehjob]);
							Send(playerid, COLOR_GREY, src);
							return Rac::RemovePlayerFromVehicle(playerid);
						} else {
							switch(vehjob) {
							case JOB_MECHANIC : {
									Send(playerid, COLOR_YELLOW, "»спользуйте /at чтобы вз€ть на буксир автомобиль, и /dt чтобы отцепить его.");
								}
							}
						}
					}
				}

				if(IsACompTruck(vehid)) {
					if(HireCar[playerid] == vehid) {
						Send(playerid, COLOR_GREEN, "* ¬ы можете доставл€ть продукты в бизнесы");
						Send(playerid, COLOR_GREEN, "*  оманды доставки /buyprods /sellprods");
					} else {
						format(src, sizeof(src),"—тоимость: $%i\n¬ы хотите арендовать грузовик?", HireCost(vehid));
						SPD(playerid, D_RENTCAR, 0, "ƒоставка продуктов", src, "ƒј", "Ќ≈“");
						Rac::TogglePlayerControllable(playerid, 0);
					}
				}

				if(AutoInfo[vehid][aFuel] < 16.0) {
					PlayerPlaySound(playerid, 1085, 0.0, 0.0, 0.0);
					format(src, sizeof(src), "~w~Benzin: ~r~%.1fL", AutoInfo[vehid][aFuel]);
					if(AutoInfo[vehid][aFuel] < 1.0) GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~w~HET АEHИЕHA", 5000, 5);
				} else {
					format(src, sizeof(src), "~w~Benzin: ~b~%.1fL", AutoInfo[vehid][aFuel]);
				}
				Pt::SetString(playerid, Pt::Fuel[playerid], src);

				if(Rac::GetVehicleHealth(vehid) < 450.0) {
					PlayerPlaySound(playerid, 1085, 0.0, 0.0, 0.0);
					GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~w~CЗOMAHO", 7000, 5);
				}

				if(!isEngined{vehid}) {
					switch(vehtype) {
					case VEHICLE_TYPE_VELLO : {
							GetVehicleParamsEx(vehid,engine,light,alarm,doors,bonnet,boot,objective);
							SetVehicleParamsEx(vehid, 1, 0, 0, 0, 0, 0, objective);
						}
					case VEHICLE_TYPE_AIRPLANE, VEHICLE_TYPE_BOAT, VEHICLE_TYPE_HELICOPTER : {
							GetVehicleParamsEx(vehid,engine,light,alarm,doors,bonnet,boot,objective);
							SetVehicleParamsEx(vehid,true,light,alarm,doors,bonnet,boot,objective);
						}
					case VEHICLE_TYPE_AUTO, VEHICLE_TYPE_BIKE : {
							Send(playerid, COLOR_FADE1, "* Ќажмите ALT, чтобы завести двигатель!");
						}
					}
				}

				switch(fc_frac) {
				case TEAM_RIFA : {
						if(model == 482) {
							format(src, sizeof(src), "* ћатериалы: %i/%i", AutoInfo[vehid][aMats], AutoInfo[vehid][aMaxMats]);
							Send(playerid, COLOR_GREEN, src);
							Send(playerid, COLOR_GREEN, "*  оманды доставки /buymats /sellmats");
						}
					}

				case TEAM_FARMERS : {
						switch(vehtype) {
						case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
								format(src, sizeof(src), "* ћак: %i/%i", AutoInfo[vehid][aDrugs], AutoInfo[vehid][aMaxDrugs]);
								Send(playerid, COLOR_GREEN, src);
							}
						}
					}
				}

				switch(vehtype) {
				case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
						Pt::Show(playerid, Pt::Fuel[playerid]);
						Pt::Show(playerid, Pt::Status[playerid]);
						for(new i; i < 3; Pt::Show(playerid, Pt::Speed[playerid][i]), i++) {}
					}

				case VEHICLE_TYPE_BOAT : {
						Pt::Show(playerid, Pt::Status[playerid]);
						for(new i; i < 3; Pt::Show(playerid, Pt::Speed[playerid][i]), i++) {}
					}

				case VEHICLE_TYPE_AIRPLANE, VEHICLE_TYPE_HELICOPTER : {
						for(new i; i < 3; Pt::Show(playerid, Pt::Speed[playerid][i]), i++) {}
					}
				}
				Pt::Show(playerid, Pt::Name[playerid]);
				Iter::Add(vehiclePassengers[vehid], playerid);
				gLastCar[playerid] = vehid;

				if(Bl::Info[playerid][Bl::Finder] != INVALID_PLAYER_ID) {
					DestroyDynamicCP(Bl::Info[Bl::Info[playerid][Bl::Finder]][Bl::Marker]);
					foreach(new i: inStreamPlayers[playerid]) {
						if(Bl::Info[i][Bl::Observe] == playerid){
							DestroyDynamicCP(Bl::Info[i][Bl::Marker]);
						}
					}
					GetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, objective);
					if(objective < 1) {
						SetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, true);
					}
				}
			}

		case PLAYER_STATE_PASSENGER : {
				foreach(new driver : vehiclePassengers[vehid]) {
					if(TransportDuty[driver] && Rac::GetPlayerState(driver) == 2) {
						if(TransportValue[driver] > Rac::GetPlayerMoney(playerid)) {
							format(temp, sizeof temp, "¬ы нуждаетесь $%i дл€ того чтобы сесть.", TransportValue[driver]);
							Send(playerid, COLOR_LIGHTBLUE, temp);
							Rac::RemovePlayerFromVehicle(playerid);
						} else {
							switch(TransportDuty[driver]) {
							case 1 : {
									TransportTime[driver] = 1;
									TransportTime[playerid] = 1;
									TransportCost[playerid] = TransportValue[driver];
									TransportCost[driver] = TransportValue[driver];
									TransportDriver[playerid] = driver;

									format(temp, sizeof temp, " ¬ы заплатили $%i “аксисту.", TransportValue[driver]);
									Send(playerid, COLOR_LIGHTBLUE, temp);
									format(temp, sizeof temp, " ѕассажир %s вошел в ваше “акси.", GetName(playerid));
									Send(driver, COLOR_LIGHTBLUE, temp);
								}

							case 2 : {
									format(temp, sizeof temp, " ¬ы заплатили $%d водителю автобуса.", TransportValue[driver]);
									Send(playerid, COLOR_LIGHTBLUE, temp);
									format(temp, sizeof temp, " ѕассажир %s вошел в ваш автобус.", GetName(playerid));
									Send(driver, COLOR_LIGHTBLUE, temp);
								}
							}
							Rac::GivePlayerMoney(playerid, -TransportValue[driver]);
							TransportMoney[driver] += TransportValue[driver];
						}
					}
				}

				Iter::Add(vehiclePassengers[vehid], playerid);
				gLastCar[playerid] = vehid;

				if(Bl::Info[playerid][Bl::Finder] != INVALID_PLAYER_ID) {
					DestroyDynamicCP(Bl::Info[Bl::Info[playerid][Bl::Finder]][Bl::Marker]);
					foreach(new i: inStreamPlayers[playerid]) {
						if(Bl::Info[i][Bl::Observe] == playerid){
							DestroyDynamicCP(Bl::Info[i][Bl::Marker]);
						}
					}
					GetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, objective);
					if(objective < 1) {
						SetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, true);
					}
				}
			}
		}

		if(oldstate == PLAYER_STATE_DRIVER && newstate != PLAYER_STATE_DRIVER) {
			for(new i; i < 3; Pt::Hide(playerid, Pt::Speed[playerid][i]), i++) {}
		}
	}

	return 1;
}

stock HireCost(carid) {
	if(1 <= carid <= MAX_VEHICLES) {
		new model = GetVehicleModel(carid);

		switch(model) {
		case 414 : return 1000;
		case 440 : return 900;
		case 456 : return 1500;
		case 499 : return 1100;
		}
		return ModelCost(model);
	}
	return 5000;
}

stock ModelCost(model) {
	for(new i; i < 4; i++) {
		for(new j; j < ASModelCount[i]; j++) {
			if(model == AutoSolon[i][j][1]) {
				return AutoSolon[i][j][1];
			}
		}
	}
	return 50000;
}

stock ToggleVehicleDoor(carid, bool:toggle) {
	if(1 <= carid <= MAX_VEHICLES) {
		gCarLock{carid} = !toggle;
		GetVehicleParamsEx(carid, engine, light, alarm, doors , bonnet, boot, objective);
		SetVehicleParamsEx(carid, engine, light, alarm, gCarLock{carid}, bonnet, boot, objective);
		foreach(new i: Player) SetVehicleParamsForPlayer(carid, i, 0, gCarLock{carid});
	}
	return 1;
}

public OnPlayerRequestClass(playerid, classid) {
	if(Pl::isLogged(playerid)) {
		Pl::SetSpawnInfo(playerid);
		Rac::SpawnPlayer(playerid);
	} else {
		new pos = random(sizeof EnterPos);
		Pl::Info[playerid][pCamPos] = pos;
		SetSpawnInfo(playerid, 1, 1, EnterPos[pos][p_pos][0], EnterPos[pos][p_pos][1], EnterPos[pos][p_pos][2], EnterPos[pos][p_pos][3],0,0,0,0,0,0);
		PlayerPlaySound(playerid, EnterPos[pos][musicid], 0.0, 0.0, 0.0);
		Rac::SpawnPlayer(playerid);
	}

	return 1;
}

public OnPlayerRequestSpawn(playerid) return 0;

stock SetPlayerCriminal(playerid, declare, reason[])
{
	if(Pl::isLogged(playerid))
	{
		new turned[24], turner[24];
		GetPlayerName(playerid, turned, sizeof(turned));
		if(Pl::isLogged(declare))
		{
			GetPlayerName(declare, turner, sizeof(turner));
		}
		else
		{
			strmid(turner, "*Ќеизвестно", 0, 38, sizeof turner);
		}
		WantedTime[playerid] = 180;
		Pl::SetWantedLevel(playerid, Pl::Info[playerid][pWantedL]);
		strmid(Pl::Crime[playerid][pVictim], turner, 0, strlen(turner), 255);
		strmid(Pl::Crime[playerid][pAccusing], reason, 0, strlen(reason), 255);
		strmid(Pl::Crime[playerid][pAccused], turner, 0, strlen(turner), 255);
		format(src, sizeof(src), "* ¬ы совершили преступление! ( %s ); ќбвинитель: %s",reason,turner);
		Send(playerid, COLOR_LIGHTRED, src);
		if(Pl::Info[playerid][pWantedL] > 0)
		{
			format(src, sizeof(src), "* ¬аш уровень розыска: %i", Pl::Info[playerid][pWantedL]);
			Send(playerid, COLOR_YELLOW, src);
			if(IsPlayerConnected(ReturnUser(turner)))
			{
				format(src, sizeof(src), "%s(раци€):ѕ–≈—“”ѕЋ≈Ќ»≈! %s. ќбвин€емый: %s", turner, reason, turned);
				sendToFrac(1, COLOR_RADIO, src);
			}
		}
		Pl::Info[playerid][pCrimes] += 1;
	}
	return 1;
}

stock SetPlayerFree(playerid, declare, reason[]) {
	if(Pl::isLogged(playerid)) {
		ClearCrime(playerid);
		format(src, sizeof(src), "*SMS: %s, поскольку ¬ы %s, ¬ы больше не преступник. ќтправитель: "#__SERVER_PREFIX""#__SERVER_NAME_LC"(555)", GetName(declare), reason);
		Send(playerid, COLOR_YELLOW, src);
		format(src, sizeof(src), "Ў“јЅ -  ¬ј–“»–ј: ќфицер %s посадил на нары", GetName(playerid));
		sendToFrac(1, COLOR_DBLUE, src);
	}
}

stock Update(i) {
	SetPlayerScore(i, Pl::Info[i][pLevel]);

	if(Wait{i} > 0) Wait{i}--;
	if(JobWaitTime[i] > 0) JobWaitTime[i]--;
	if(Pl::Info[i][pReport] > 0) Pl::Info[i][pReport]--;

	if(++Pl::Info[i][pUpdate] >= (60*4)) {
		Pl::Info[i][pUpdate] = 0;

		if(Pl::Drunk[i] > 0) {
			Pl::Drunk[i] = 0;
			Pl::DrunkTime[i] = 0;
			SetPlayerDrunkLevel(i, 0);
			GameTextForPlayer(i, "~p~Drunk effect~n~~w~Gone", 4500, 1);
		}

		if(Pl::Info[i][pPayDay] < 9) Pl::Info[i][pPayDay]++;

		switch(STDPlayer[i]) {
		case 1 : {
				Rac::GivePlayerHealth(i, -5.0);
				Send(i, COLOR_LIGHTBLUE, "* ѕотер€но 4 здоровь€.");
			}

		case 2 : {
				Rac::GivePlayerHealth(i, -12.0);
				Send(i, COLOR_LIGHTBLUE, "* ѕотер€но 8 здоровь€.");
			}

		case 3 : {
				Rac::GivePlayerHealth(i, -20.0);
				Send(i, COLOR_LIGHTBLUE, "* ѕотер€но 12 здоровь€.");
			}
		}

		if(Rac::GetPlayerMoney(i) < 0) {
			if(!MoneyMessage[i]) {
				MoneyMessage[i] = true;
				format(temp, sizeof(temp), "* ” ¬ас задолжность штату, вы должны отдать сумму: $%d или с€дете в тюрьму!", Rac::GetPlayerMoney(i));
				Send(i, COLOR_LIGHTRED, temp);
			}
		} else if(Pl::Info[i][pBank] < 0) {
			if(!MoneyMessage[i]) {
				MoneyMessage[i] = true;
				format(temp, sizeof(temp), "* ” ¬ас задолжность банку, вы должны отдать сумму: $%d или с€дете в тюрьму!", Pl::Info[i][pBank]);
				Send(i, COLOR_LIGHTRED, temp);
			}
		} else {
			MoneyMessage[i] = true;
		}

		Pl::Update(i);
		Td::ShowForPlayer(i, Copyright);
		Td::ShowForPlayer(i, Logo[0]);
		Td::ShowForPlayer(i, Time);
	}

	if(Fixr{i} > 0) {
		if(--Fixr{i} == 0) {
			Fixr{i} = 0;
			PlayerPlaySound(i, 1069, 0.0, 0.0, 0.0);
		}
	}

	if(AnimClear[i] > 0) {
		if(--AnimClear[i] == 0) {
			ApplyAnimation(i,"PED","facgum",4.1,0,1,1,1,1);
		}
	}

	if(useknock[i] > 0) {
		if(--useknock[i] == 29) {
			ApplyAnimation(i,"CARRY","crry_prtial",4.0,0,0,0,0,0);
		}
	}

	if(Pl::NetStats[i] != INVALID_PLAYER_ID) {
		if(Pl::isLogged(Pl::NetStats[i])) {
			GetPlayerNetworkStats(i, dialog, sizeof dialog);
			SPD(i, D_NETSTAT, 0, "Player stat", dialog, "OK", "");

		} else if(Pl::NetStats[i] == 999)	{
			GetNetworkStats(dialog, sizeof dialog);
			SPD(i, D_NETSTAT, 0, "Server stat", dialog, "OK", "");

		} else if(Pl::NetStats[i] == 1000) {
			Db::stat(dialog, connDb);
			SPD(i, D_NETSTAT, 0, "Mysql stat", dialog, "OK", "");

		} else {
			Pl::NetStats[i] = INVALID_PLAYER_ID;
		}
	}

	if(++Pl::Info[i][pHunger] >= 60) {
		Pl::Info[i][pHunger] = 0;
		if(Rac::GetPlayerHealth(i) > 5.0) {
			Rac::GivePlayerHealth(i, -1.0);
		}
	}

	if(NameChange{i} > 0) {
		if(--NameChange{i} == 0) {
			ChangeName(i);
		}
	}

	if(Fell[i] > 0) {
		if(--Fell[i] <= 0) {
			Rac::TogglePlayerControllable(i, 1);
			ApplyAnimation(i,"PED","getup",4.1,0,1,1,1,1);
		}
	}

	if(DrugIntoxic[i] > 0) {
		switch(--DrugIntoxic[i]) {
		case 0 			: SetPlayerWeather(i, 1);
		case 1..60		: SetPlayerWeather(i, 184);
		case 61..120	: SetPlayerWeather(i, 149);
		case 121..180	: SetPlayerWeather(i, 555);
		case 181..240	: SetPlayerWeather(i, 190);
			default			: SetPlayerWeather(i, 190);
		}
	}

	if(WantedTime[i] > 0 && Pl::Info[i][pWantedL] > 0) {
		if(--WantedTime[i] == 0) {
			Pl::SetWantedLevel(i, Pl::Info[i][pWantedL]-1);
			if(Pl::Info[i][pWantedL] > 0) WantedTime[i] = 180;
			format(temp, sizeof(temp),"* ѕонижение уровн€ розыска, осталось звезд: %i!", Pl::Info[i][pWantedL]);
			Send(i, COLOR_LIGHTBLUE, temp);
		}
	}

	if(CellTime[i] > 0) {
		if(++CellTime[i] == cchargetime && Pl::isLogged(Mobile[i])) {
			CellTime[i] = 1;
			if(Mobile[Mobile[i]] == i) {
				if(Rac::GetPlayerMoney(i) >= callcost) {
					Rac::GivePlayerMoney(i, -callcost);
					format(temp, sizeof(temp), "~r~-$%i", callcost);
					GameTextForPlayer(i, temp, 1000, 1);
				} else {
					CellTime[i] = 0;
					Mobile[i] = INVALID_PLAYER_ID;
					if(Mobile[Mobile[i]] == i) {
						CellTime[Mobile[i]] = 0;
						Mobile[Mobile[i]] = INVALID_PLAYER_ID;
						Send(Mobile[i], COLOR_GRAD2, "јбонент положил трубку.");
						SetPlayerSpecialAction(Mobile[i],SPECIAL_ACTION_STOPUSECELLPHONE);
					}
					Send(i, COLOR_YELLOW, "* ” ¬ас кончались деньги!");
					SetPlayerSpecialAction(i,SPECIAL_ACTION_STOPUSECELLPHONE);
				}
			}
		}
		if(Mobile[Mobile[i]] == INVALID_PLAYER_ID && CellTime[i] == 5) {
			GetPlayerName(Mobile[i], plname, 24);
			format(temp, sizeof(temp), "* %s's звонит телефон", plname);
			ProxDetector(30.0, Mobile[i], temp, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
		}
	}
	if(TransportTime[i] > 0) {
		if(TransportTime[i] >= 40) {
			TransportTime[i] = 1;
			if(TransportDriver[i] != INVALID_PLAYER_ID) {
				if(Pl::isLogged(TransportDriver[i])) {
					if(Rac::GetPlayerMoney(i) >= TransportCost[i]) {
						TransportCost[i] += TransportValue[TransportDriver[i]];
						TransportCost[TransportDriver[i]] = TransportCost[i];
					}
				}
			}
		}
		TransportTime[i]++;
		if(Rac::GetPlayerMoney(i) >= TransportCost[i]) {
			format(temp, sizeof(temp), "~n~~n~~n~~n~~n~~n~~n~~g~cost: ~w~$%i/%i", TransportCost[i], TransportTime[i]);
			GameTextForPlayer(i, temp, 1000, 5);
			GameTextForPlayer(TransportDriver[i], temp, 1000, 5);
		} else {
			format(temp, sizeof(temp), "~n~~n~~n~~n~~n~~n~~r~Out Of Money!~n~~g~cost: ~w~$%i/%i", TransportCost[i], TransportTime[i]);
			GameTextForPlayer(i, temp, 1000, 5);
			GameTextForPlayer(TransportDriver[i], temp, 1000, 5);
		}
	}

	if(Pl::Info[i][pMutedTime] != 0) {
		if(--Pl::Info[i][pMutedTime] <= 0 && Pl::Info[i][pMuted] > 0) {
			Pl::Info[i][pMuted] = 0;
			Pl::Info[i][pMutedTime] = 0;
			format(temp, sizeof(temp),""#__SERVER_PREFIX""#__SERVER_NAME_LC": %s выплюнул(а) тр€пку изо рта!", GetName(i));
			SendToAll(COLOR_GREY, temp);
		}
	}

	if(UsedFind[i] != 0) UsedFind[i] --;

	if(PlayerTazeTime[i] >= 1) {
		if(++PlayerTazeTime[i] == 15) {
			PlayerTazeTime[i] = 0;
		} else {
			GetPlayerFacingAngle(i, angle);
			Rac::SetPlayerFacingAngle(i, angle + 90);
		}
	}

	if(Pl::Drunk[i] >= 5) {
		if(++Pl::DrunkTime[i] == 8) {
			Pl::DrunkTime[i] = 0;
			if(!IsPlayerInAnyVehicle(i)) ApplyAnimation(i,"PED", "WALK_DRUNK",4.0,0,1,0,0,0);
		}
	}

	if(Pl::Stoned[i] >= 2) {
		if(++Pl::Stoned[i] == 10) Pl::Stoned[i] = 0;
	}

	if(Pl::Info[i][pCarTime] > 0) {
		if(Pl::Info[i][pCarTime] <= 0) Pl::Info[i][pCarTime] = 0;
		else Pl::Info[i][pCarTime] -= 1;
	}

	if(FindTime[i] > 0) {
		format(temp, sizeof(temp), "%i", FindTime[i]);
		GameTextForPlayer(i, temp, 1500, 6);
		if(--FindTime[i] == 0) {
			DisablePlayerCheckpointEx(i, FIND_ICON);
			PlayerPlaySound(i, 1056, 0.0, 0.0, 0.0);
			GameTextForPlayer(i, "~r~RedMarker gone", 2500, 1);
		}
	}

	if(TaxiCallTime[i] > 0 || BusCallTime[i] > 0) {
		if(TaxiAccepted[i] != INVALID_PLAYER_ID) {
			if(IsPlayerConnected(TaxiAccepted[i])) {
				GetPlayerPos(TaxiAccepted[i], posx, posy, posz);
				DestroyDynamicCP(checkpoints[i]);
				checkpoints[i] = CreateDynamicCP(posx, posy, posz, 5.0, -1, -1, i, 99999.9);
			}
		}
		else if(BusAccepted[i] != INVALID_PLAYER_ID) {
			if(IsPlayerConnected(BusAccepted[i])) {
				GetPlayerPos(BusAccepted[i], posx, posy, posz);
				DestroyDynamicCP(checkpoints[i]);
				checkpoints[i] = CreateDynamicCP(posx, posy, posz, 5.0,-1,-1,i,99999.9);
			}
		}
	}

	if(MedicCallTime[i][1] > 0) {
		if(MedicCallTime[i][1] == 300) {
			MedicCallTime[i][0] = INVALID_PLAYER_ID;
			MedicCallTime[i][1] = 0;
			DestroyDynamicMapIcon(pickupd[i][1]);
			PlayerPlaySound(i, 1056, 0.0, 0.0, 0.0);
			GameTextForPlayer(i, "~r~RedMarker gone", 2500, 1);
		} else {
			if(IsPlayerConnected(MedicCallTime[i][0])) {
				format(temp, sizeof temp, "%d", 300 - MedicCallTime[i][1]);
				GameTextForPlayer(i, temp, 1500, 6);
				MedicCallTime[i][1] ++;
			} else {
				MedicCallTime[i][1] = 300;
				format(temp, sizeof temp, "*  лиент %s, вышел из игры.", GetName(MedicCallTime[i][0]));
				Send(i, COLOR_AZTECAS, temp);
			}
		}
	}

	if(MechanicCallTime[i][1] > 0) {
		if(MechanicCallTime[i][1] == 300) {
			MechanicCallTime[i][0] = INVALID_PLAYER_ID;
			MechanicCallTime[i][1] = 0;
			DestroyDynamicMapIcon(pickupd[i][1]);
			PlayerPlaySound(i, 1056, 0.0, 0.0, 0.0);
			GameTextForPlayer(i, "~r~RedMarker gone", 2500, 1);
		} else {
			if(IsPlayerConnected(MechanicCallTime[i][0])) {
				format(temp, sizeof(temp), "%d", 300 - MechanicCallTime[i][1]);
				GameTextForPlayer(i, temp, 1500, 6);
				MechanicCallTime[i][1] ++;
			} else {
				MechanicCallTime[i][1] = 300;
				format(temp, sizeof temp, "*  лиент %s, вышел из игры.", GetName(MechanicCallTime[i][0]));
				Send(i, COLOR_AZTECAS, temp);
			}
		}
	}

	if(Pl::CuffedTime[i] > 0) {
		if(--Pl::CuffedTime[i] == 0) {
			Pl::CuffedTime[i] = 0;
			RemovePlayerAttachedObject(i, 0);
			SetPlayerSpecialAction(i, SPECIAL_ACTION_NONE);
		}
	}
	return 1;
}

public: Fillup(playerid, amount, price, sec) {
	if(sec > 0) {
		format(temp, sizeof temp, "~g~%i~n~~b~Please wait...", sec);
		GameTextForPlayer(playerid, temp, 600, 5);
		SetTimerEx("Fillup", 300, false, "iiii", playerid, amount, price, --sec);
	} else {
		new gas = GetPVarInt(playerid, "SelectGas");
		if(gas != 0xFFFF) {
			new bidx = GetIndexFromBizID(RefillInfo[gas][brBizID]);
			if(BizzInfo[bidx][bProds] <= 0) {
				GameTextForPlayer(playerid, "~r~Out of stock", 5000, 1);
			} else {
				BizzInfo[bidx][bProds] -= floatround(amount / 10);
				GiveBizzProfit(bidx, price);
				new veh = GetPlayerVehicleID(playerid);
				AutoInfo[veh][aFuel] += float(amount);
				updateBenzinTD(playerid, veh);
				format(temp, sizeof temp,"* ћашина заправлена, с вас: $%i.", price);
				Send(playerid, COLOR_LIGHTBLUE, temp);
				Rac::GivePlayerMoney(playerid, -price);
			}
			SetPVarInt(playerid, "SelectGas", 0xFFFF);
		}
		Rac::TogglePlayerControllable(playerid, true);
	}
}

stock SetPlayerWeapons(playerid) {
	if(Pl::isLogged(playerid)) {
		Rac::ResetPlayerWeapons(playerid);
		if(!Pl::Info[playerid][pJailed]) {
			switch(Pl::FracID(playerid)) {
			case 1..3 : {
					Rac::GivePlayerWeapon(playerid, 3, 1);
				}

			case 5 : {
					Rac::GivePlayerWeapon(playerid, 2, 1);
					Rac::GivePlayerWeapon(playerid, 22, 30);
				}
			case 6 : {
					Rac::GivePlayerWeapon(playerid, 8, 1);
					Rac::GivePlayerWeapon(playerid, 22, 30);
				}

			case 9 : {
					Rac::GivePlayerWeapon(playerid, 43, 25);
				}

			case 10 : {
					Rac::GivePlayerWeapon(playerid, 3, 1);
					Rac::GivePlayerWeapon(playerid, 41, 1000);
				}

			case 11 : {
					Rac::GivePlayerWeapon(playerid, 3, 1);
					Rac::GivePlayerWeapon(playerid, 41, 1000);
				}

			case 12..19 : {
					Rac::GivePlayerWeapon(playerid, 5, 1);
					Rac::GivePlayerWeapon(playerid, 22, 30);
				}

			case 20 : {
					Rac::GivePlayerWeapon(playerid, 6, 1);
					Rac::GivePlayerWeapon(playerid, 22, 30);
				}
			}
		}
	}
	return 1;
}

stock PrintBizInfo(playerid, bizid) {
	new i = GetIndexFromBizID(bizid);
	if(i != -1) {
		format(dialog, sizeof dialog, "%s\n\n{ffffff}----------------------------------------------------------\n", BizzInfo[i][bDescription]);
		scf(dialog, src, "{ffa500}¬ладелец: {ffffff}%s\n",BizzInfo[i][bOwner]);
		scf(dialog, src, "{ffa500} омпоньон: {AA3333}%s\n",BizzInfo[i][bExtortion]);
		scf(dialog, src, "{ffa500} рыша: {%h}%s\n", rgb<GetFracColor(BizzInfo[i][bFrac])>, GetGangName(BizzInfo[i][bFrac]));
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		scf(dialog, src, "{ffa500}—татус: %s\n", BizzInfo[i][bLocked]?("{AA3333}[закрыт]"):("{33AA33}[открыт]"));
		scf(dialog, src, "{ffa500}—тоимость входа: {33AA33}$%i\n",BizzInfo[i][bEnterCost]);
		scf(dialog, src, "{ffa500}Ќа счету бизнеса: {33AA33}$%i\n", BizzInfo[i][bSafe]);
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		scf(dialog, src, "{ffa500}—тоимость продуктов: {33AA33}$%i\n",BizzInfo[i][bPriceProd]);
		scf(dialog, src, "{ffa500}ѕродуктов в бизнесе: {ffffff}%i/%i",BizzInfo[i][bProds],BizzInfo[i][bMaxProds]);
		SPD(playerid, D_NONE, 0, "»нформаци€ о бизнесе", dialog, "ENTER", "");
	}
	return 1;
}

stock PrintHouseInfo(playerid, i, mode = 0) {
	if(IsValidHouse(i)) {
		format(dialog, sizeof dialog, "%s\n\n{ffffff}----------------------------------------------------------\n", HouseInfo[i][hDescription]);
		scf(dialog, src, "{ffa500}¬ладелец:{0080ff} %s\n", HouseInfo[i][hOwner]);
		scf(dialog, src, "{ffa500}÷ена дома:{33AA33} $%d\n", HouseInfo[i][hPrice]);
		scf(dialog, src, "{ffa500}—татус: {33AA33}%s\n", HouseInfo[i][hLock]?("{AA3333}[закрыт]"):("{33AA33}[открыт]"));
		scf(dialog, src, "{ffa500}јренда: {33AA33}%s\n", HouseInfo[i][hRent][0]?("{33AA33}[открыта]"):("{AA3333}[закрыта]"));
		scf(dialog, src, "{ffa500}÷ена аренды: {33AA33}$%d\n", HouseInfo[i][hRent][1]);
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		scf(dialog, src, "{ffa500}ƒенег в сейфе: {33AA33}$%d\n", HouseInfo[i][hSafe][0]);
		scf(dialog, src, "{ffa500}Ќарко в сейфе: {33AA33}%d грамм\n", HouseInfo[i][hSafe][1]);
		scf(dialog, src, "{ffa500}ћатов в сейфе: {33AA33}%d матов\n", HouseInfo[i][hSafe][2]);
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		scf(dialog, src, "{ffa500}јптечек: {33AA33}%i штук\n", HouseInfo[i][hSafe][3]);
		scf(dialog, src, "{ffa500}Ѕронежилетов: {33AA33}%i штук\n", HouseInfo[i][hSafe][4]);
		scf(dialog, src, "{ffa500}“елевизор: %s\n", HouseInfo[i][hTv]?("{33AA33}[есть]"):("{AA3333}[нету]"));
		scf(dialog, src, "{ffa500}ƒомашнее авто: {33AA33}%s\n", (400<=HouseInfo[i][hvModel]<=611)?(VehicleNames[HouseInfo[i][hvModel]-400]):("unknown"));
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		if(mode && Pl::isAdmin(playerid, MODER2LVL)) {
			scf(dialog, src, "{ffa500}Ѕез хоз€ина уже: {33AA33}%i/20", getday(gettime(), HouseInfo[i][hDate]));
		}
		SPD(playerid, D_NONE, 0, "»нформаци€ о доме", dialog, "ENTER", "");
	}
	return 1;
}


public: ShowStats(playerid, statid, mode) {
	#define FIELD_COL d16800
	#define TITLE_COL 34b036
	if(!Pl::isLogged(statid)) return 0;
	GetPlayerVersion(statid, temp, sizeof temp);
	format(dialog,sizeof dialog,"{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}”ровень: {ffffff}%d\n", 			Pl::Info[statid][pLevel]);
	scf(dialog, src, "{"#FIELD_COL"}–еспекты: {ffffff}%d/%d\n", 		Pl::Info[statid][pExp], EXP(statid));
	scf(dialog, src, "{"#FIELD_COL"}÷ена уровн€: {ffffff}$%d\n",		costlvl(statid));
	scf(dialog, src, "{"#FIELD_COL"}ѕол: {ffffff}%s\n",					GetPlayerSex(statid));
	scf(dialog, src, "{"#FIELD_COL"}¬озраст: {ffffff}%s\n",				GetPlayerAge(statid));
	scf(dialog, src, "{"#FIELD_COL"}ћестонахождение: {ffffff}%s\n",		GetPlayerOrigin(statid));
	scf(dialog, src, "{"#FIELD_COL"}ѕредупреждени€: {ffffff}%d / 3\n",	Pl::Info[statid][pWarns]);
	scf(dialog, src, "{"#FIELD_COL"}VIP аккаунт: {ffffff}%s\n",			Pl::Info[statid][pVip]?("≈сть"):("Ќету"));
	scf(dialog, src, "{"#FIELD_COL"}„асов в игре: {ffffff}%d\n",		Pl::Info[statid][pTime]);
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}–абота: {ffffff}%s\n", 				JobsInfo[Pl::Info[statid][pJob]][jName]);
	scf(dialog, src, "{"#FIELD_COL"}ќрганизаци€: {ffffff}%s\n", 		FracInfo[Pl::FracID(statid)][fName]);
	scf(dialog, src, "{"#FIELD_COL"}–анг: {ffffff}%s\n",				RankInfo[Pl::FracID(statid)][Pl::Info[statid][pRank]]);
    scf(dialog, src, "{"#FIELD_COL"}¬ыговоры: {ffffff}%d/4\n", 			Pl::Info[statid][pRebuke]);
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}ƒеньги(наличные): {ffffff}$%d\n", 	Rac::GetPlayerMoney(statid));
	scf(dialog, src, "{"#FIELD_COL"}ƒеньги(в банке): {ffffff}$%d\n",	Pl::Info[statid][pBank]);
	scf(dialog, src, "{"#FIELD_COL"}Ќомер телефона: {ffffff}%d\n",		Pl::Info[statid][pNumber]);
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}Ћотторейный є: {ffffff}%d\n",		Pl::Info[statid][pLottoNr]);
	scf(dialog, src, "{"#FIELD_COL"} ол-во преступлений: {ffffff}%d\n",	Pl::Info[statid][pCrimes]);
	scf(dialog, src, "{"#FIELD_COL"} ол-во арестов: {ffffff}%d\n",		Pl::Info[statid][pArrested]);
	scf(dialog, src, "{"#FIELD_COL"}—мертей с розыском: {ffffff}%d\n",	Pl::Info[statid][pWantedD]);
	scf(dialog, src, "{"#FIELD_COL"}”ровень розыска: {ffffff}%d\n", 	Pl::Info[statid][pWantedL]);
	scf(dialog, src, "{"#FIELD_COL"}”бийств: {ffffff}%d\n",				Pl::Info[statid][pKills]);
	scf(dialog, src, "{"#FIELD_COL"}—мертей: {ffffff}%d\n",				Pl::Info[statid][pDeaths]);
	scf(dialog, src, "{"#FIELD_COL"}¬ыговоров: {ffffff}%d\n", 			Pl::Info[statid][pRebuke]);
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}Ќаркотики: {ffffff}%d\n", 			Pl::Info[statid][pDrugs]);
	scf(dialog, src, "{"#FIELD_COL"}ћатериалы: {ffffff}%d\n", 			Pl::Info[statid][pMats]);

	if(Pl::isAdmin(playerid, 1) && mode) {
		scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
		scf(dialog, src, "{"#FIELD_COL"}UserID: {ffffff}%i\n", 		Pl::Info[statid][pID]);
		scf(dialog, src, "{"#FIELD_COL"}Client: {ffffff}%s\n", 		temp);
		scf(dialog, src, "{"#FIELD_COL"}ƒом: {ffffff}%i\n",  		Pl::Info[statid][pHouseKey]);
		scf(dialog, src, "{"#FIELD_COL"}Ѕизнес: {ffffff}%i\n", 		Pl::Info[statid][pBizKey]);
		scf(dialog, src, "{"#FIELD_COL"}Ћицензии: {ffffff}D:%i, F:%i, B:%i, G:%i, Fish:%i\n", Pl::Info[statid][pLic][0], Pl::Info[statid][pLic][1], Pl::Info[statid][pLic][2], Pl::Info[statid][pLic][3], Pl::Info[statid][pLic][4]);
		scf(dialog, src, "{"#FIELD_COL"}Ћокаци€: {ffffff}%i\n", 	Pl::Info[statid][pLocal]);
		scf(dialog, src, "{"#FIELD_COL"}¬ирт. ћир: {ffffff}%i\n",	GetPlayerVirtualWorld(statid));
		scf(dialog, src, "{"#FIELD_COL"}»нтерьер: {ffffff}%i\n", 	GetPlayerInterior(statid));
	}

	format(temp, sizeof temp,"{"#TITLE_COL"}—татистика аккуанта: {ffffff}%s", GetName(statid));
	return SPD(playerid, D_NONE, 0, temp, dialog, "ENTER","");
}

stock ShowPass(playerid, showforid, dialogid) {
	if(!Pl::isLogged(showforid)) return 0;
	new fio[2][12], _date[2][14], fracid = Pl::FracID(playerid);
	to_timestamp(_date[0], Pl::Info[playerid][pPasport][1], "%Y-%m-%d");
	to_timestamp(_date[1], Pl::Info[playerid][pPasport][2], "%Y-%m-%d");
	GetPlayerName(playerid, plname, 24), sscanf(plname, "p<_>s[12]S(-)[12]", fio[0], fio[1]);

	format(dialog, sizeof dialog,"{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}»м€: {ffffff}%s\n", fio[0]);
	scf(dialog, src, "{"#FIELD_COL"}‘амили€: {ffffff}%s\n", fio[1]);
	scf(dialog, src, "{"#FIELD_COL"}¬озраст: {ffffff}%s\n", GetPlayerAge(playerid));
	scf(dialog, src, "{"#FIELD_COL"}ѕол: {ffffff}%s\n", GetPlayerSex(playerid));
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}ќрганизаци€: {%h}%s\n", rgb<GetFracColor(fracid)>, FracInfo[fracid][fName]);
	scf(dialog, src, "{"#FIELD_COL"}ƒолжность: {ffffff}%s\n", RankInfo[fracid][Pl::Info[playerid][pRank]]);
	scf(dialog, src, "{"#FIELD_COL"}ѕреступлений: {ffffff}%i\n", Pl::Info[playerid][pCrimes]);
	scf(dialog, src, "{"#FIELD_COL"}ѕроживание в штате: {ffffff}%i(в годах)\n", Pl::Info[playerid][pLevel]);
	scf(dialog, src, "{"#FIELD_COL"}–абота: {ffffff}%s\n", JobsInfo[Pl::Info[playerid][pJob]][jName]);
	scf(dialog, src, "{ffffff}----------------------------------------------------------\n");
	scf(dialog, src, "{"#FIELD_COL"}ƒействует от: {ffffff}%s\n", _date[0]);
	scf(dialog, src, "{"#FIELD_COL"}ƒействует до: {ffffff}%s\n", _date[1]);

	if(playerid != showforid) {
		format(temp, sizeof(temp),"{"#TITLE_COL"}ѕаспорт гражданина: {ffffff}%s", plname);
		SPD(showforid, dialogid, 0, temp, dialog, "ENTER","");
	} else {
		SPD(showforid, dialogid, 0, "¬аш паспорт", dialog, "ENTER","");
	}
	return 1;
}

stock IsLegalFrac(fracid) {
	switch(fracid) {
	case 1..4	: return 1;
	case 7		: return 1;
	case 9..11	: return 1;
	}
	return 0;
}

stock GetFracType(fracid) {
	if(!IsValidFrac(fracid)) return FRAC_TYPE_UNKNOWN;
	if((linearSearch(Gangs, fracid) != -1)) return FRAC_TYPE_GANG;
	if((linearSearch(Mafias, fracid) != -1)) return FRAC_TYPE_MAFIA;
	if((linearSearch(Teams, fracid) != -1)) return FRAC_TYPE_TEAM;

	return FRAC_TYPE_OTHER;
}

stock Pl::SetFracColor(playerid) {
	return SetPlayerColor(playerid, GetFracColor(Pl::FracID(playerid)));
}

stock LoadSpawns() {
	new time = GetTickCount();
	new Cache:result = Db::query(connDb, "SELECT * FROM `"#__TableSpawns__"` ORDER BY `id` ASC");
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			new id;
			cache_get_int(i, 0, id);
			cache_get_int(i, 1, SpawnInfo[id][spInt]);
			cache_get_int(i, 2, SpawnInfo[id][spVirt]);
			cache_get_float(i, 3, SpawnInfo[id][spX]);
			cache_get_float(i, 4, SpawnInfo[id][spY]);
			cache_get_float(i, 5, SpawnInfo[id][spZ]);
			cache_get_float(i, 6, SpawnInfo[id][spA]);
		}
		debug("LoadSpawns() - Ok! Spawns: %i. Run time: %i (ms)", rows, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadGMInfo() {
	new time = GetTickCount();
	new Cache:result = Db::query(connDb, "SELECT * FROM `"#__TableStuffs__"` WHERE 1", true);
	if(cache_get_row_count()) {
		cache_get_int(0, 0, Gm::Info[Gm::TaxValue]);
		cache_get_int(0, 1, Gm::Info[Gm::PritonDrugs]);
		cache_get_int(0, 2, Gm::Info[Gm::AmbarDrugs]);
		cache_get_int(0, 3, Gm::Info[Gm::FactoryMetal]);
		cache_get_int(0, 4, Gm::Info[Gm::FactoryFuel]);
		cache_get_int(0, 5, Gm::Info[Gm::FactoryProds]);
		cache_get_int(0, 6, Gm::Info[Gm::EnableReg]);
		debug("LoadGMInfo() - Ok! Run time: %i (ms)", GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock SaveStuff() {
	format(query, sizeof query, "UPDATE `"#__TableStuffs__"` SET ");
	scf(query, temp, "`TaxValue`='%i',", Gm::Info[Gm::TaxValue]);
	scf(query, temp, "`PDrugs`='%i',", Gm::Info[Gm::PritonDrugs]);
	scf(query, temp, "`ADrugs`='%i',", Gm::Info[Gm::AmbarDrugs]);
	scf(query, temp, "`fmetal`='%i',", Gm::Info[Gm::FactoryMetal]);
	scf(query, temp, "`ffuel`='%i',", Gm::Info[Gm::FactoryFuel]);
	scf(query, temp, "`fprods`='%i',", Gm::Info[Gm::FactoryProds]);
	scf(query, temp, "`regged`='%i'", Gm::Info[Gm::EnableReg]);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock LoadHouses() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableHouses__"` ORDER BY `id` ASC", true);
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new iter; iter < rows; iter++) {
			new i;
			cache_get_int(iter, 0, i);
			HouseInfo[i][hID] = i;
			HouseInfo[i][hVirtual] = i;
			HouseInfo[i][hgGarage] = false;
			cache_get_int(iter, 1, HouseInfo[i][hOwned]);
			cache_get_int(iter, 2, HouseInfo[i][hLock]);
			cache_get_row(iter, 3, HouseInfo[i][hOwner], connDb, 24);
			cache_get_row(iter, 4, HouseInfo[i][hDescription], connDb, 24);
			cache_get_int(iter, 5, HouseInfo[i][hPrice]);
			cache_get_int(iter, 6, HouseInfo[i][hLevel]);
			cache_get_int(iter, 7, HouseInfo[i][hInt]);
			cache_get_int(iter, 8, HouseInfo[i][hDate]);
			cache_get_int(iter, 9, HouseInfo[i][hTv]);
			cache_get_str(iter, 10, "p<,>a<i>[2]", HouseInfo[i][hRent]);
			cache_get_str(iter, 11, "p<,>a<i>[5]", HouseInfo[i][hSafe]);
			cache_get_str(iter, 12, "p<,>a<i>[6]", HouseInfo[i][hGuns]);
			cache_get_str(iter, 13, "p<,>a<i>[6]", HouseInfo[i][hAmmos]);
			cache_get_str(iter, 14, "p<,>a<f>[4]", HouseInfo[i][hEnter]);
			cache_get_str(iter, 15, "p<,>a<f>[4]", HouseInfo[i][hExit]);
			cache_get_int(iter, 16, HouseInfo[i][hvModel]);
			if(400 <= HouseInfo[i][hvModel] <= 611) {
				cache_get_str(iter, 17, "p<,>a<i>[2]", HouseInfo[i][hvColor]);
				cache_get_int(iter, 18, HouseInfo[i][hvPark]);
				cache_get_str(iter, 21, "p<,>a<f>[4]", HouseInfo[i][hvSpawn]);
				HouseInfo[i][hAuto] = Veh::Create(
				HouseInfo[i][hvModel],
				HouseInfo[i][hvSpawn][0],
				HouseInfo[i][hvSpawn][1],
				HouseInfo[i][hvSpawn][2],
				HouseInfo[i][hvSpawn][3],
				HouseInfo[i][hvColor][0],
				HouseInfo[i][hvColor][1],
				3600*2
				);
				AutoInfo[HouseInfo[i][hAuto]][aOwner] = INVALID_PLAYER_ID * i;
				SetVehicleNumber(HouseInfo[i][hAuto]);
				ToggleVehicleDoor(HouseInfo[i][hAuto], false);
				cache_get_float(iter, 19, AutoInfo[HouseInfo[i][hAuto]][aMileage]);
				cache_get_str(iter, 20, "p<,>a<i>[13]i", AutoInfo[HouseInfo[i][hAuto]][aTuning], AutoInfo[HouseInfo[i][hAuto]][aPaintJob]);
				AddTuning(HouseInfo[i][hAuto]);
				switch(HouseInfo[i][hvPark]) {
				case 1 : {
						LinkVehicleToInterior(HouseInfo[i][hAuto], 3);
						SetVehicleVirtualWorld(HouseInfo[i][hAuto], HouseInfo[i][hVirtual]);
					}
				}
			}

			switch(HouseInfo[i][hOwned]) {
			case 0 : {
					HouseInfo[i][hPickup] = AddPickup(1273, 23, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 0);
					HouseInfo[i][hMapIcon] = CreateDynamicMapIcon( HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 31, 0, 0, -1, -1, 250.0);
				}
			case 1 : {
					HouseInfo[i][hPickup] = AddPickup(1318, 23, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 0);
					HouseInfo[i][hMapIcon] = CreateDynamicMapIcon(HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 32,0, 0, -1, -1, 250.0);
				}
			}

			Iter::Add(Houses, i);
		}
		debug("LoadHouses() - Ok! Houses: %i. Run time: %i (ms)", Iter::Count(Houses), GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadHGarages() {
	HGaragePickup[0] = AddPickup(1318, 23, HGaragePickupPos[0][0], HGaragePickupPos[0][1], HGaragePickupPos[0][2], 0);
	HGaragePickup[1] = AddPickup(1318, 23, HGaragePickupPos[1][0], HGaragePickupPos[1][1], HGaragePickupPos[1][2], 0);

	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableHouseGarages__"` ORDER BY `house` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i, house; i < rows; i++) {
			cache_get_int(i, 0, house);
			cache_get_str(i, 1, "p<,>a<f>[4]", HouseInfo[house][hgIntPos]);
			cache_get_str(i, 2, "p<,>a<f>[4]", HouseInfo[house][hgStreetPos]);

			HouseInfo[house][hgGarage] = true;
			HouseInfo[house][hgPickupInt] = CreateDynamicPickup(1318, 23, HouseInfo[house][hgIntPos][0], HouseInfo[house][hgIntPos][1], HouseInfo[house][hgIntPos][2], HouseInfo[house][hVirtual], -1, -1, 30.0);
			HouseInfo[house][hgPickupStreet] = CreateDynamicPickup(1318, 23, HouseInfo[house][hgStreetPos][0], HouseInfo[house][hgStreetPos][1], HouseInfo[house][hgStreetPos][2], 0, -1, -1, 8.0);

			Streamer_AppendArrayData(STREAMER_TYPE_PICKUP, HGaragePickup[0], E_STREAMER_WORLD_ID, HouseInfo[house][hVirtual]);
			Streamer_AppendArrayData(STREAMER_TYPE_PICKUP, HGaragePickup[1], E_STREAMER_WORLD_ID, HouseInfo[house][hVirtual]);
		}
		debug("LoadHGarage() - Ok! Garages: %i. Run time: %i (ms)", rows, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadBizz() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableBusines__"` ORDER BY `id` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, BizzInfo[i][bID]);
			cache_get_int(i, 1, BizzInfo[i][bOwned]);
			cache_get_int(i, 2, BizzInfo[i][bLocked]);
			cache_get_row(i, 3, BizzInfo[i][bOwner], connDb, 24);
			cache_get_row(i, 4, BizzInfo[i][bExtortion], connDb, 24);
			cache_get_row(i, 5, BizzInfo[i][bDescription], connDb, 24);
			cache_get_int(i, 6, BizzInfo[i][bLevel]);
			cache_get_int(i, 7, BizzInfo[i][bPrice]);
			cache_get_int(i, 8, BizzInfo[i][bSafe]);
			cache_get_int(i, 9, BizzInfo[i][bEnterCost]);
			cache_get_int(i, 10, BizzInfo[i][bFrac]);
			cache_get_int(i, 11, BizzInfo[i][bProds]);
			cache_get_int(i, 12, BizzInfo[i][bMaxProds]);
			cache_get_int(i, 13, BizzInfo[i][bPriceProd]);
			cache_get_int(i, 14, BizzInfo[i][bInterior]);
			cache_get_str(i, 15, "p<,>a<i>[2]", BizzInfo[i][bIcon]);
			cache_get_str(i, 16, "p<,>a<f>[4]", BizzInfo[i][bEnter]);
			cache_get_str(i, 17, "p<,>a<f>[4]", BizzInfo[i][bExit]);
            BizzInfo[i][bLocked] = 0;
			BizzInfo[i][bVirtual] = BizzInfo[i][bID];

			switch(BizzInfo[i][bOwned]) {
			case 0 : {
					BizzInfo[i][bPickupEnter] = AddPickup(1272, 23, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], 0);
				}
				default : {
					BizzInfo[i][bPickupEnter] = AddPickup(1239, 23, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], 0);
				}
			}
			if(BizzInfo[i][bIcon][BizzInfo[i][bOwned]] != 0) {
				BizzInfo[i][bMapIcon] = CreateDynamicMapIcon(BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], BizzInfo[i][bIcon][BizzInfo[i][bOwned]], 0, 0, -1, -1, 250.0);
			}
			if(BizzInfo[i][bInterior] != -1) {
				BizzInfo[i][bPickupExit] = AddPickup(1318, 23, BizzInfo[i][bExit][0], BizzInfo[i][bExit][1], BizzInfo[i][bExit][2], BizzInfo[i][bVirtual]);
			}
			GetSquarePos(BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], MAX_ZONE_SIZE, BizzInfo[i][bzMinX], BizzInfo[i][bzMinY], BizzInfo[i][bzMaxX], BizzInfo[i][bzMaxY]);
			BizzInfo[i][bZone] = Gz::Create(BizzInfo[i][bzMinX], BizzInfo[i][bzMinY], BizzInfo[i][bzMaxX], BizzInfo[i][bzMaxY]);
			GangBiznes{BizzInfo[i][bFrac]} ++;
			Iter::Add(Biznes, i);
		}
		debug("LoadBizz() - Ok! Biznes: %i. Run time: %i (ms)", Iter_Count(Biznes), GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadGas() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableRefills__"` ORDER BY `id` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, RefillInfo[i][brID]);
			cache_get_int(i, 1, RefillInfo[i][brBizID]);
			cache_get_str(i, 2, "p<,>a<f>[3]", RefillInfo[i][brPos]);
			RefillInfo[i][brPickup] = AddPickup(1650, 14, RefillInfo[i][brPos][0], RefillInfo[i][brPos][1], RefillInfo[i][brPos][2], 0);
			Iter::Add(Refills, i);
		}
		debug("LoadGas() - Ok! Gas: %i. Run time: %i (ms)", Iter::Count(Refills), GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadGangInfo() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableGangInfo__"` ORDER BY `gRespect` DESC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0,GangInfo[i][fID]);
			cache_get_int(i, 1,GangInfo[i][gRespect]);
			cache_get_float(i, 2, GangInfo[i][gPosX]);
			cache_get_float(i, 3, GangInfo[i][gPosY]);
			cache_get_float(i, 4, GangInfo[i][gPosZ]);
		}
		debug("LoadGangInfo() - Ok! Run time: %i (ms)", GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock SaveGI() {
	for(new i; i < sizeof GangInfo; ++i) {
		format(query, sizeof query, "UPDATE `"#__TableGangInfo__"` SET ");
		scf(query, src, "`gRespect`='%i',", GangInfo[i][gRespect]);
		scf(query, src, "`gPosX`='%f',", GangInfo[i][gPosX]);
		scf(query, src, "`gPosY`='%f',", GangInfo[i][gPosY]);
		scf(query, src, "`gPosZ`='%f' ", GangInfo[i][gPosZ]);
		scf(query, src, "WHERE `fracID`='%i'", GangInfo[i][fID]);
		Db::tquery(connDb, query, "", "");
	}
	return;
}

stock LoadFracInfo() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableFracInfo__"` ORDER BY `fID` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		strmid(FracInfo[0][fName], "Civilian", 0, strlen("Civilian"), 255);
		for(new i; i < rows; i++) {
			new fracid;
			cache_get_int(i, 0, fracid);
			cache_get_int(i, 1, FracInfo[fracid][fBank]);
			cache_get_str(i, 2, "p<,>a<i>[3]", FracInfo[fracid][fRConf]);
			cache_get_str(i, 3, "p<,>a<i>[2]", FracInfo[fracid][fBConf]);
			cache_get_row(i, 4, FracInfo[fracid][fName], connDb, 36);
			cache_get_row(i, 5, FracInfo[fracid][fTag], connDb, 16);
			cache_get_str(i, 6, "p<,>a<i>[2]a<f>[4]", FracInfo[fracid][fSpawn][fSpawnInt], FracInfo[fracid][fSpawn][fSpawnPos]);
			cache_get_str(i, 7, "h", FracInfo[fracid][fColor]);
		}
		debug("LoadFracInfo() - Ok! Fracs: %i. Run time: %i (ms)", rows, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock UpdateFracInfo(fracid) {
	if(IsValidFrac(fracid)) {
		format(query, sizeof query, "UPDATE `"#__TableFracInfo__"` SET ");
		scf(query, temp, "`fBank`='%i',", FracInfo[fracid][fBank]);
		scf(query, temp, "`fRConf`='%i,%i,%i',", FracInfo[fracid][fRConf][zRANK], FracInfo[fracid][fRConf][bRANK], FracInfo[fracid][fRConf][gRANK]);
		scf(query, temp, "`fBConf`='%i,%i',", FracInfo[fracid][fBConf][bKILLS], FracInfo[fracid][fBConf][bPRICE]);
		scf(query, temp, "`fColor`='0x%s'", hexToString(FracInfo[fracid][fColor]));
		scf(query, temp, " WHERE `fID`='%i'", fracid);
		Db::tquery(connDb, query, "", "");
		return 1;
	}
	return 0;
}

stock LoadFracVehicles( ) {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableFracVehicles__"` ORDER BY `ID` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, Fc::Info[i][Fc::Id][0]);
			cache_get_int(i, 1, Fc::Info[i][Fc::Model]);
			cache_get_int(i, 2, Fc::Info[i][Fc::FracId]);
			cache_get_int(i, 3, Fc::Info[i][Fc::RankId]);
			cache_get_str(i, 4, "p<,>a<i>[2]", Fc::Info[i][Fc::Color]);
			cache_get_row(i, 5, Fc::Info[i][Fc::Number], connDb, 10);
			cache_get_str(i, 6, "p<,>a<f>[4]", Fc::Info[i][Fc::RespPos]);
			cache_get_float(i, 7, AutoInfo[0][aMileage]);

			Fc::Info[i][Fc::Id][1] = Veh::Create(
			Fc::Info[i][Fc::Model],
			Fc::Info[i][Fc::RespPos][0],
			Fc::Info[i][Fc::RespPos][1],
			Fc::Info[i][Fc::RespPos][2],
			Fc::Info[i][Fc::RespPos][3],
			Fc::Info[i][Fc::Color][0],
			Fc::Info[i][Fc::Color][1],
			600
			);

			if(!strlen(Fc::Info[i][Fc::Number])) strmid(Fc::Info[i][Fc::Number], Fc::DEF_NUMBER, 0, strlen(Fc::DEF_NUMBER), 255);
			SetVehicleNumberPlate(Fc::Info[i][Fc::Id][1], Fc::Info[i][Fc::Number]);
			AutoInfo[Fc::Info[i][Fc::Id][1]][aMileage] = AutoInfo[0][aMileage];
			Iter::Add(TeamVehicles[Fc::Info[i][Fc::FracId]], Fc::Info[i][Fc::Id][1]);
		}
		Fc::TOTAL = rows;
		debug("LoadFracVehicles() - Ok! Vehicles: %i; Run time: %i (ms)", Fc::TOTAL, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock SaveAcc() {
	foreach(new i: Player) Pl::Update(i);
	return 1;
}

public: UpdateProp() {
	foreach(new i : Biznes) UpdateBizz(i);
	foreach(new i : Houses) UpdateHouse(i);
	for(new i; i < TOTAL_VEHICLES; ++i) UpdateToSQL(i, 0);
	for(new i; i < Fc::TOTAL; ++i) Fc::Update(i);
	for(new i; i < MAX_FRAC; ++i) UpdateFracInfo(i);

	SaveStuff();

	SaveGI();

	return 1;
}

stock Float:GetDistanceBetweenPlayers(p1,p2) {
	new Float:xyz[3];
	GetPlayerPos(p2, xyz[0], xyz[1], xyz[2]);
	return GetPlayerDistanceFromPoint(p1, xyz[0], xyz[1], xyz[2]);
}

stock GetClosestPlayer(playerid, Float:radi=200.0) {
	new Float: dist, p1 = INVALID_PLAYER_ID;
	foreach(new i : inStreamPlayers[playerid]) {
		dist = GetDistanceBetweenPlayers(i, playerid);
		if(dist <= radi && dist != -1.00) {
			radi = dist;
			p1 = i;
		}
	}

	return p1;
}

stock DateProp(playerid, ...) {
	static const STATIC_ARGS = 1;
	new argCount = numargs();
	if((argCount - STATIC_ARGS) > 0) {
		for(new i = STATIC_ARGS; i < argCount; i++) {
			switch(getarg(i)) {
			case 0 : {
					new houseid = Pl::Info[playerid][pHouseKey];
					if(IsPlayerHouseOwner(playerid, houseid)) {
						HouseInfo[houseid][hDate] = gettime();
					}
				}

			case 1 : {
					if(Pl::Info[playerid][pPasport][0] != 0) {
						new currtime = gettime();
						if(currtime >= Pl::Info[playerid][pPasport][2]) {
							Pl::Info[playerid][pPasport][0] = 0;
							Pl::Info[playerid][pPasport][1] = 0;
							Pl::Info[playerid][pPasport][2] = 0;
							Send(playerid, COLOR_YELLOW, "* ¬аш паспорт больше не действителен, новый можно получить в ћэрии.");
						}
					}
				}
			}
		}
	}
	return 1;
}

public: ClearBanList(currtime) {
	new banIp[16];
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_row(i, 0, banIp);
			format(query, sizeof query, "unbanip %.16s", banIp);
			SendRconCommand(query);
		}
		format(query, sizeof query, "DELETE FROM `"#__TableBanned__"` WHERE `unbandate` <= '%i'", currtime);
		Db::tquery(connDb, query, "", "");
	}
	return 1;
}


public: Checkprop() {
	SendLog(LOG_HOUSE, "[Debug] Checkprop starting...");
	new count;
	foreach(new i : Houses) {
		if(HouseInfo[i][hOwned] && getday(gettime(), HouseInfo[i][hDate]) >= 15) {
			format(query, sizeof query, "[Debug] Home sold! HouseID: %i; Owner: %s; Price: %i", HouseInfo[i][hID], HouseInfo[i][hOwner], HouseInfo[i][hPrice]);
			SendLog(LOG_HOUSE, query);
			ClearHouse(i);
			count++;
		}
	}
	format(query, sizeof query, "[Debug] Total sales of houses: %i", count);
	SendLog(LOG_HOUSE, query);
	return 1;
}

public: onPayDay() {
	SendLog(LOG_PAYDAY_STATS, "[Debug] PayDay starting...");

	new
	tax,
	hkey,
	rent,
	bidx,
	ebill,
	interest,
	totaltax,
	tmpintrate = 1,
	totalebill,
	totalchecks
	;

	bidx = GetIndexFromBizID(Bizz_PowerHouse);
	foreach(new i : Player) {
		if(Pl::isLogged(i)) {
			if(Pl::Info[i][pLevel] > 0) {
				hkey = Pl::Info[i][pHouseKey];
				GetPlayerName(i, plname, 24);
				if(IsValidHouse(hkey)) {
					rent = HouseInfo[hkey][hRent][1];
					if(IsPlayerHouseOwner(i, hkey)) {
						rent = 0;
					} else {
						if(rent > Rac::GetPlayerMoney(i)) {
							Pl::Info[i][pHouseKey] = INVALID_HOUSE_ID;
							Send(i, COLOR_WHITE, "* ¬ы были выселены.");
							rent = 0;
						}
					}

					if(rent) {
						HouseInfo[hkey][hSafe][0] += rent;
						Rac::GivePlayerMoney(i, -rent);
					}

					ebill = (HouseInfo[hkey][hPrice] / BizzInfo[bidx][bEnterCost]);
					if(Pl::Info[i][pBank] > 0 || Rac::GetPlayerMoney(i) > 0) {
						totalebill += ebill;
						if(Pl::Info[i][pBank] >= ebill) GivePlayerBankMoney(i, -ebill);
						else Rac::GivePlayerMoney(i, -ebill);
					} else ebill = 0;
				}

				if(Pl::Info[i][pVip] > 0) tmpintrate = 3;

				interest = (Pl::Info[i][pBank]/1000)*(tmpintrate);

				if(Pl::Info[i][pPayDay] >= 9) {
					Pl::Info[i][pPayCheck] += GetPayCheck(Pl::Info[i][pLevel]);
					tax = floatround(PERCENT(Pl::Info[i][pPayCheck], Gm::Info[Gm::TaxValue]));
					Pl::Info[i][pExp]++;
					Pl::Info[i][pTime]++;
					Send(i, 0x34c92400, "|________________«ј–ѕЋј“ј______________|");
					sendf(i, src, COLOR_GREY, "* „ек: $%i Ќалог: -$%i", Pl::Info[i][pPayCheck], tax);
					sendf(i, src, COLOR_GREY, "* Ѕаланс: $%i", Pl::Info[i][pBank]-interest);
					sendf(i, src, COLOR_GREY, "* ¬клад в банке под: 0.%i процентов",tmpintrate);
					if(hkey != INVALID_HOUSE_ID) sendf(i, src, COLOR_GREY, "* —чет за электричество: -$%i", ebill);
					sendf(i, src, COLOR_GREY, "* ѕолученные средства по банковскому вкладу: $%i", interest);
					sendf(i, src, COLOR_GREY, "* ѕлата за аренду: -$%i", rent);
					Send(i, COLOR_GREY, "|--------------------------------------|");
					if(tax > 0) {
						totaltax += tax;
						Pl::Info[i][pPayCheck] -= tax;
					}
					totalchecks += Pl::Info[i][pPayCheck];
					GivePlayerBankMoney(i, interest);
					GivePlayerBankMoney(i, -Gm::Info[Gm::TaxValue]);
					GivePlayerBankMoney(i, Pl::Info[i][pPayCheck]);
					sendf(i, src, COLOR_GREY, "* “екущий баланс: $%i", Pl::Info[i][pBank]);
					GameTextForPlayer(i, "~y~Bank~n~~w~Paycheck", 5000, 1);
					PlayerPlayMusic(i);
					DEBUG[TOTAL_PLAYER_PAID] ++;

					Pl::Info[i][pPayDay] = 0;
					Pl::Info[i][pPayCheck] = 0;

					if(Pl::Info[i][pContractTime] != 0) {
						Pl::Info[i][pContractTime]--;
					}
					if(Pl::Info[i][pVip] > 0) {
						Pl::Info[i][pPayDayHad] += 1;
						if(Pl::Info[i][pPayDayHad] >= 5) {
							Pl::Info[i][pExp]++;
							Pl::Info[i][pPayDayHad] = 0;
						}
					}
                    if(Pl::Info[i][pMedHour] != 0)
                    {
                        Pl::Info[i][pMedHour] -= 1;
						if(Pl::Info[i][pMedHour] == 0)
						{
                            Send(i, COLOR_LIGHTBLUE, "” вашей мед.карты кончилс€ срок действи€! ѕродлите еЄ у врача!");
							Pl::Info[i][pMedKarta] = 0;
						}
					}
					DateProp(i, 1);
					Pl::Update(i);
				} else {
					Send(i, COLOR_LIGHTRED, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬ы играли слишком мало, поэтому сервер не выдал вам зарплату за прошлый час.");
				}
				if(MoneyMessage[i] && !(Rac::GetPlayerMoney(i) > 0 || Pl::Info[i][pBank] > 0)) {
					MoneyMessage[i] = false;
					Jailed(i, 300, 3);
					GameTextForPlayer(i, "~r~Busted!", 2000, 1);
					format(src, sizeof(src), "* ¬ы заключены в тюрьму на 10 минут! ѕричина: «адолжность");
					Send(i, COLOR_LIGHTBLUE, src);
				}
			}
		}
	}

	GiveFracMoney(7, totaltax);
	GiveBizzProfit(bidx, totalebill);

	format(src, sizeof(src), "PAYDAY STATS: ѕолучивших зарплату: %i, —обрано налога: $%i, ”шло на зарплату: $%i, —чета за электричество: $%i", DEBUG[TOTAL_PLAYER_PAID], totaltax, totalchecks, totalebill);
	SendToAdmin(COLOR_YELLOW, src, 1, 4);
	format(src, sizeof(src), "PAYDAY STATS: —охранений аккаунтов: %i, houses:%i/biznes:%i, MySQL-ошибок: %i, —ейчас играют: %i",
	DEBUG[TOTAL_SAVE_ACCOUNT], DEBUG[TOTAL_SAVE_HOUSES], DEBUG[TOTAL_SAVE_BIZNES], DEBUG[TOTAL_QUERY_ERRORS], Iter::Count(Player));
	SendToAdmin(COLOR_YELLOW, src, 1, 4);

	for(new i; i < sizeof(DEBUG); i++) DEBUG[i] = 0; // Clear debug

	return 1;
}

public: onPlayerRegister(playerid) {
	if(!IsPlayerConnected(playerid)) return 1;
	Pl::Info[playerid][pID] = cache_insert_id();
	if(Pl::Info[playerid][pID] == 1) Pl::Info[playerid][pAdmin] = 5;
	ShowLoginForm(playerid, 1);
	return 1;
}

public: onPlayerLogin(playerid) {
	if(!IsPlayerConnected(playerid)) return 1;

	if(cache_get_row_count() == 1) {
		cache_get_row(0, 1, plname);
		cache_get_int(0, 3, Pl::Info[playerid][pLevel]);
		cache_get_int(0, 4, Pl::Info[playerid][pAdmin]);
		cache_get_int(0, 5, Pl::Info[playerid][pHelper]);
		cache_get_int(0, 6, Pl::Info[playerid][pVip]);
		cache_get_int(0, 7, Pl::Info[playerid][pReg]);
		cache_get_int(0, 8, Pl::Info[playerid][pSex]);
		cache_get_int(0, 9, Pl::Info[playerid][pAge]);
		cache_get_int(0, 10, Pl::Info[playerid][pOrigin]);
		cache_get_int(0, 11, Pl::Info[playerid][pMuted]);
		cache_get_int(0, 12, Pl::Info[playerid][pExp]);
		Rac::SetPlayerMoney(playerid, cache_get_row_int(0, 13));
		cache_get_int(0, 14, Pl::Info[playerid][pBank]);
		cache_get_int(0, 15, Pl::Info[playerid][pCrimes]);
		cache_get_int(0, 16, Pl::Info[playerid][pKills]);
		cache_get_int(0, 17, Pl::Info[playerid][pTime]);
		cache_get_int(0, 18, Pl::Info[playerid][pDeaths]);
		cache_get_int(0, 19, Pl::Info[playerid][pArrested]);
		cache_get_int(0, 20, Pl::Info[playerid][pWantedL]);
		cache_get_int(0, 21, Pl::Info[playerid][pWantedD]);
		cache_get_int(0, 22, Pl::Info[playerid][pPhoneBook]);
		cache_get_int(0, 23, Pl::Info[playerid][pLottoNr]);
		cache_get_int(0, 24, Pl::Info[playerid][pJob]);
		cache_get_int(0, 25, Pl::Info[playerid][pPayCheck]);
		cache_get_int(0, 26, Pl::Info[playerid][pJailed]);
		cache_get_int(0, 27, Pl::Info[playerid][pJailTime]);
		cache_get_int(0, 28, Pl::Info[playerid][pMats]);
		cache_get_int(0, 29, Pl::Info[playerid][pDrugs]);
		cache_get_int(0, 30, Pl::Info[playerid][pLeader]);
		cache_get_int(0, 31, Pl::Info[playerid][pMember]);
		cache_get_int(0, 32, Pl::Info[playerid][pRank]);
		cache_get_int(0, 33, Pl::Info[playerid][pChar]);
		cache_get_int(0, 34, Pl::Info[playerid][pContractTime]);
		cache_get_str(0, 35, "p<,>a<i>[8]", Pl::Info[playerid][pSkill]);
		cache_get_int(0, 36, Pl::Info[playerid][pLocal]);
		cache_get_int(0, 37, Pl::Info[playerid][pNumber]);
		cache_get_int(0, 38, Pl::Info[playerid][pHouseKey]);
		cache_get_int(0, 39, Pl::Info[playerid][pBizKey]);
		cache_get_str(0, 40, "p<,>a<i>[5]", Pl::Info[playerid][pLic]);
		cache_get_int(0, 41, Pl::Info[playerid][pCarTime]);
		cache_get_int(0, 42, Pl::Info[playerid][pPayDay]);
		cache_get_int(0, 43, Pl::Info[playerid][pPayDayHad]);
		cache_get_int(0, 44, Pl::Info[playerid][pCDPlayer]);
		cache_get_int(0, 45, Pl::Info[playerid][pMutedTime]);
		cache_get_int(0, 46, Pl::Info[playerid][pWarns]);
		cache_get_int(0, 47, Pl::Info[playerid][pFuel]);
		cache_get_int(0, 48, Pl::Info[playerid][pFightstyle]);
		cache_get_int(0, 49, Pl::Info[playerid][pBanned]);
		cache_get_int(0, 50, Pl::Info[playerid][pTest]);
		cache_get_int(0, 51, Pl::Info[playerid][pRebuke]);
		cache_get_str(0, 52, "p<,>a<i>[3]", Pl::Info[playerid][pPasport]);
		cache_get_int(0, 53, Pl::Info[playerid][pLastVisit]);
		cache_get_int(0, 54, Pl::Info[playerid][pMarried]);
		cache_get_row(0, 55, Pl::Info[playerid][pMarriedTo]);
		cache_get_int(0, 56, Pl::Info[playerid][pMedKarta]);
		cache_get_int(0, 57, Pl::Info[playerid][pMedHour]);
		cache_get_int(0, 58, Pl::Info[playerid][pGPS]);
	} else {
		WrongLogin[playerid]--;
		Send(playerid, COLOR_LIGHTRED, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": Ќеверный пароль! ¬ случае 3-х кратного неверного ввода  » !");
		ShowLoginForm(playerid, 1);
		return 1;
	}

	if(Pl::Info[playerid][pBanned] == 1) {
		Send(playerid, COLOR_YELLOW, "{ffffff}¬ведите {e85209}/(q)uit {ffffff}чтобы выйти из игры");
		SPD(playerid, D_NONE, 0, "Х ACCOUNT BLOCKED Х", "Ётот аккуант был отключен администратором!\n¬ведите /q чтобы выйти из игры", "ќк", "");
		Kick(playerid);
		return 1;
	}

	Td::ShowForPlayer(playerid, Copyright);
	Td::ShowForPlayer(playerid, Logo[0]);
	Td::ShowForPlayer(playerid, Time);
	Add_To_Iterator(playerid);
	ShowBizZones(playerid);

	if(Pl::Info[playerid][pReg] == 0) {
		Rac::SetPlayerInterior(playerid, 3);
		Rac::SetPlayerPos(playerid, 215.3485, -133.1142, 1003.5078);
		Rac::SetPlayerFacingAngle(playerid, 92.2598);
		SetPlayerCameraPos(playerid, 210.4674, -131.8238, 1004.2631);
		SetPlayerCameraLookAt(playerid, 214.3328, -132.8457, 1004.1403);
		Rac::TogglePlayerControllable(playerid, false);
		SPD(playerid, D_REGG + 2, 0, "Sex", "¬ыберете пол вашего персонажа.", "∆≈Ќ", "ћ”∆");
	} else {
		sendf(playerid, temp, COLOR_WHITE, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ћы рады видеть теб€ на сервере, %s!", plname);

		if(Pl::Info[playerid][pWantedL] > 0) {
			WantedTime[playerid] = 180;
			Pl::SetWantedLevel(playerid, Pl::Info[playerid][pWantedL]);
			sendf(playerid, temp, COLOR_YELLOW, "* ¬осстановление уровн€ розыска! “екущий уровень: %i зв.", Pl::Info[playerid][pWantedL]);
		}


		Pl::SetFracColor(playerid);
		DateProp(playerid, 0, 1);

		format(temp, sizeof temp, "~w~Welcome ~n~~g~   %s", plname);
		GameTextForPlayer(playerid, temp, 6000, 1);
		Pl::SetSpawnInfo(playerid);
		Rac::SpawnPlayer(playerid);

		if(!Pl::Info[playerid][pAdmin]) {
			format(temp, sizeof temp, "* %s (ID: %i) прокралс€(ась) на ..::"#__SERVER_PREFIX""#__SERVER_NAME_LC"::.. [RUS]", plname, playerid);
			sendToLog(COLOR_GREY, src);
		}
		PlayerLogged{playerid} = true;

		format(query, sizeof query, "SELECT * FROM `"#__TableExtraVehicles__"` WHERE `owner` = '%i' ORDER BY `id` ASC", Pl::Info[playerid][pID]);
		Db::tquery(connDb, query, "LoadExtraVehicles", "i", playerid);

		format(query, sizeof query, "SELECT `f_id`,`mink` FROM `"#__TableBlacklist__"` WHERE `accused`='%i'", Pl::Info[playerid][pID]);
		Db::tquery(connDb, query, ""#Bl::"Check", "i", playerid);
	}
	return 1;
}

public: Pl::Update(playerid) {
	if(Pl::isLogged(playerid)) {
		new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
		new hidx = Pl::Info[playerid][pHouseKey];
		if(IsValidBiz(bidx)) UpdateBizz(bidx);
		if(IsValidHouse(hidx)) UpdateHouse(hidx);

		Pl::Info[playerid][pLastVisit] = gettime();
		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET ");
		scf(query, src, "`Level`='%i',", Pl::Info[playerid][pLevel]);
		scf(query, src, "`Admin`='%i',", Pl::Info[playerid][pAdmin]);
		scf(query, src, "`Helper`='%i',", Pl::Info[playerid][pHelper]);
		scf(query, src, "`Vip`='%i',", Pl::Info[playerid][pVip]);
		scf(query, src, "`Reg`='%i',", Pl::Info[playerid][pReg]);
		scf(query, src, "`Sex`='%i',", Pl::Info[playerid][pSex]);
		scf(query, src, "`Age`='%i',", Pl::Info[playerid][pAge]);
		scf(query, src, "`Origin`='%i',", Pl::Info[playerid][pOrigin]);
		scf(query, src, "`Muted`='%i',", Pl::Info[playerid][pMuted]);
		scf(query, src, "`Exp`='%i',", Pl::Info[playerid][pExp]);
		scf(query, src, "`Money`='%i',", Rac::GetPlayerMoney(playerid));
		scf(query, src, "`Bank`='%i',", Pl::Info[playerid][pBank]);
		scf(query, src, "`Crimes`='%i',", Pl::Info[playerid][pCrimes]);
		scf(query, src, "`Kill`='%i',", Pl::Info[playerid][pKills]);
		scf(query, src, "`Time`='%i',", Pl::Info[playerid][pTime]);
		scf(query, src, "`Deaths`='%i',", Pl::Info[playerid][pDeaths]);
		scf(query, src, "`Arrested`='%i',", Pl::Info[playerid][pArrested]);
		scf(query, src, "`WLevel`='%i',", Pl::Info[playerid][pWantedL]);
		scf(query, src, "`WDeaths`='%i',", Pl::Info[playerid][pWantedD]);
		scf(query, src, "`PhoneBook`='%i',", Pl::Info[playerid][pPhoneBook]);
		scf(query, src, "`LottoNr`='%i',", Pl::Info[playerid][pLottoNr]);
		scf(query, src, "`Job`='%i',", Pl::Info[playerid][pJob]);
		scf(query, src, "`PayCheck`='%i',", Pl::Info[playerid][pPayCheck]);
		scf(query, src, "`Jailed`='%i',", Pl::Info[playerid][pJailed]);
		scf(query, src, "`JailTime`='%i',", Pl::Info[playerid][pJailTime]);
		scf(query, src, "`Mats`='%i',", Pl::Info[playerid][pMats]);
		scf(query, src, "`Drugs`='%i',", Pl::Info[playerid][pDrugs]);
		scf(query, src, "`Leader`='%i',", Pl::Info[playerid][pLeader]);
		scf(query, src, "`Member`='%i',", Pl::Info[playerid][pMember]);
		scf(query, src, "`Rank`='%i',", Pl::Info[playerid][pRank]);
		scf(query, src, "`Char`='%i',", Pl::Info[playerid][pChar]);
		scf(query, src, "`Contract`='%i',", Pl::Info[playerid][pContractTime]);
		scf(query, src, "`skill`='%i,", Pl::Info[playerid][pSkill][0]);
		for(new i=1; i < 7; i++) scf(query, src, "%i,", Pl::Info[playerid][pSkill][i]);
		scf(query, src, "%i',", Pl::Info[playerid][pSkill][7]);
		scf(query, src, "`Local`='%i',", Pl::Info[playerid][pLocal]);
		scf(query, src, "`Number`='%i',", Pl::Info[playerid][pNumber]);
		scf(query, src, "`House`='%i',", Pl::Info[playerid][pHouseKey]);
		scf(query, src, "`Busines`='%i',", Pl::Info[playerid][pBizKey]);
		scf(query, src, "`licenses`='%i,%i,%i,%i,%i',", Pl::Info[playerid][pLic][0], Pl::Info[playerid][pLic][1], Pl::Info[playerid][pLic][2], Pl::Info[playerid][pLic][3], Pl::Info[playerid][pLic][4]);
		scf(query, src, "`CarTime`='%i',", Pl::Info[playerid][pCarTime]);
		scf(query, src, "`PayDay`='%i',", Pl::Info[playerid][pPayDay]);
		scf(query, src, "`PayDayHad`='%i',", Pl::Info[playerid][pPayDayHad]);
		scf(query, src, "`CDPlayer`='%i',", Pl::Info[playerid][pCDPlayer]);
		scf(query, src, "`MutedTime`='%i',", Pl::Info[playerid][pMutedTime]);
		scf(query, src, "`Warns`='%i',", Pl::Info[playerid][pWarns]);
		scf(query, src, "`Fuel`='%i',", Pl::Info[playerid][pFuel]);
		scf(query, src, "`Fightstyle`='%i',", Pl::Info[playerid][pFightstyle]);
		scf(query, src, "`Banned`='%i',", Pl::Info[playerid][pBanned]);
		scf(query, src, "`Test`='%i',", Pl::Info[playerid][pTest]);
		scf(query, src, "`Rebuke`='%i',", Pl::Info[playerid][pRebuke]);
		scf(query, src, "`Passport`='%i,%i,%i',", Pl::Info[playerid][pPasport][0], Pl::Info[playerid][pPasport][1], Pl::Info[playerid][pPasport][2]);
		scf(query, src, "`Online`='%i',", Pl::Info[playerid][pLastVisit]);
		scf(query, src, "`Rebuke`='%i',", Pl::Info[playerid][pRebuke]);
		scf(query, src, "`pMarried`='%i',", Pl::Info[playerid][pMarried]);
		scf(query, src, "`pMarriedTo`='%i',", Pl::Info[playerid][pMarriedTo]);
		scf(query, src, "`pMedKarta`='%i',", Pl::Info[playerid][pMedKarta]);
		scf(query, src, "`pMedHour`='%i',", Pl::Info[playerid][pMedHour]);
		scf(query, src, "`pGPS`='%i'", Pl::Info[playerid][pGPS]);
		scf(query, src, "WHERE `ID`='%i'", Pl::Info[playerid][pID]);
		Db::tquery(connDb, query, "", "");
		DEBUG[TOTAL_SAVE_ACCOUNT] ++;
	}
	return 1;
}

stock UpdateHouse(i) {
	new safeDiscription[28];
	Db::escape_string(HouseInfo[i][hDescription], safeDiscription);
	format(query, sizeof query, "UPDATE `"#__TableHouses__"` SET ");
	scf(query, src, "`owned`='%i',", HouseInfo[i][hOwned]);
	scf(query, src, "`locked`='%i',", HouseInfo[i][hLock]);
	scf(query, src, "`owner`='%s',", HouseInfo[i][hOwner]);
	scf(query, src, "`description`='%s',", safeDiscription);
	scf(query, src, "`price`='%i',", HouseInfo[i][hPrice]);
	scf(query, src, "`level`='%i',", HouseInfo[i][hLevel]);
	scf(query, src, "`interior`='%i',", HouseInfo[i][hInt]);
	scf(query, src, "`date`='%i',", HouseInfo[i][hDate]);
	scf(query, src, "`tv`='%i',", HouseInfo[i][hTv]);
	scf(query, src, "`rent`='%i',", HouseInfo[i][hRent][0], HouseInfo[i][hRent][1]);
	scf(query, src, "`safe`='%i,%i,%i,%i,%i',", HouseInfo[i][hSafe][0], HouseInfo[i][hSafe][1], HouseInfo[i][hSafe][2], HouseInfo[i][hSafe][3], HouseInfo[i][hSafe][4]);
	scf(query, src, "`safe_weap`='%i,%i,%i,%i,%i,%i',", HouseInfo[i][hGuns][0], HouseInfo[i][hGuns][1], HouseInfo[i][hGuns][2], HouseInfo[i][hGuns][3], HouseInfo[i][hGuns][4], HouseInfo[i][hGuns][5]);
	scf(query, src, "`safe_ammo`='%i,%i,%i,%i,%i,%i',", HouseInfo[i][hAmmos][0], HouseInfo[i][hAmmos][1], HouseInfo[i][hAmmos][2], HouseInfo[i][hAmmos][3], HouseInfo[i][hAmmos][4], HouseInfo[i][hAmmos][5]);
	scf(query, src, "`enter`='%.3f,%.3f,%.3f,%.3f',", HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], HouseInfo[i][hEnter][3]);
	scf(query, src, "`exit`='%.3f,%.3f,%.3f,%.3f',", HouseInfo[i][hExit][0], HouseInfo[i][hExit][1], HouseInfo[i][hExit][2], HouseInfo[i][hExit][3]);
	scf(query, src, "`vehicle`='%i',", HouseInfo[i][hvModel]);
	scf(query, src, "`vehicle_color`='%i,%i',", HouseInfo[i][hvColor][0], HouseInfo[i][hvColor][1]);
	scf(query, src, "`vehicle_park`='%i',", HouseInfo[i][hvPark]);
	if(IsValidVehicle(HouseInfo[i][hAuto])) {
		scf(query, src, "`vehicle_mileage`='%f',", AutoInfo[HouseInfo[i][hAuto]][aMileage]);
	}
	scf(query, src, "`vehicle_spawn`='%.3f,%.3f,%.3f,%.3f' ", HouseInfo[i][hvSpawn][0], HouseInfo[i][hvSpawn][1], HouseInfo[i][hvSpawn][2], HouseInfo[i][hvSpawn][3]);
	scf(query, src, "WHERE `id`='%i'", HouseInfo[i][hID]);
	Db::tquery(connDb, query, "", "");
	DEBUG[TOTAL_SAVE_HOUSES]++;
	return 1;
}

stock UpdateHouseGarage(idx) {
	format(query, sizeof query, "UPDATE `"#__TableHouseGarages__"` SET ");
	scf(query, src, "`intpos`='%.3f,%.3f,%.3f,%.3f',", HouseInfo[idx][hgIntPos][0], HouseInfo[idx][hgIntPos][1], HouseInfo[idx][hgIntPos][2], HouseInfo[idx][hgIntPos][3]);
	scf(query, src, "`streetpos`='%.3f,%.3f,%.3f,%.3f' ", HouseInfo[idx][hgStreetPos][0], HouseInfo[idx][hgStreetPos][1], HouseInfo[idx][hgStreetPos][2], HouseInfo[idx][hgStreetPos][3]);
	scf(query, src, "WHERE `house`='%i'", HouseInfo[idx][hID]);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock DeleteHouseGarage(idx) {
	if(HouseInfo[idx][hgGarage]) {
		HouseInfo[idx][hgGarage] = false;
		DestroyDynamicPickup(HouseInfo[idx][hgPickupInt]);
		DestroyDynamicPickup(HouseInfo[idx][hgPickupStreet]);
		format(query, sizeof query, "DELETE FROM `"#__TableHouseGarages__"` WHERE `house` = '%i'", HouseInfo[idx][hID]);
		Db::tquery(connDb, query, "", "");
	}
	return 1;
}

stock Fc::Update(idx) {
	format(query, sizeof query, "UPDATE `"#__TableFracVehicles__"` SET ");
	scf(query, src, "`model`='%i',", Fc::Info[idx][Fc::Model]);
	scf(query, src, "`frac`='%i',", Fc::Info[idx][Fc::FracId]);
	scf(query, src, "`rank`='%i',", Fc::Info[idx][Fc::RankId]);
	scf(query, src, "`colors`='%i,%i',", Fc::Info[idx][Fc::Color][0], Fc::Info[idx][Fc::Color][1]);
	scf(query, src, "`number`='%s',", Fc::Info[idx][Fc::Number]);
	scf(query, src, "`resp_pos`='%.3f,%.3f,%.3f,%.3f',", Fc::Info[idx][Fc::RespPos][0], Fc::Info[idx][Fc::RespPos][1], Fc::Info[idx][Fc::RespPos][2], Fc::Info[idx][Fc::RespPos][3]);
	scf(query, src, "`miles`='%f' ", AutoInfo[Fc::Info[idx][Fc::Id][1]][aMileage]);
	scf(query, src, "WHERE `ID`='%i'", Fc::Info[idx][Fc::Id][0]);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock UpdateBizz(i) {
	new safeDescription[24];
	Db::escape_string(BizzInfo[i][bDescription], safeDescription, connDb);
	format(query, sizeof query, "UPDATE `"#__TableBusines__"` SET ");
	scf(query, src, "`owned`='%i',", BizzInfo[i][bOwned]);
	scf(query, src, "`locked`='%i',", BizzInfo[i][bLocked]);
	scf(query, src, "`owner`='%s',", BizzInfo[i][bOwner]);
	scf(query, src, "`extortion`='%s',", BizzInfo[i][bExtortion]);
	scf(query, src, "`description`='%s',", safeDescription);
	scf(query, src, "`level`='%i',", BizzInfo[i][bLevel]);
	scf(query, src, "`price`='%i',", BizzInfo[i][bPrice]);
	scf(query, src, "`safe`='%i',", BizzInfo[i][bSafe]);
	scf(query, src, "`enter_cost`='%i',", BizzInfo[i][bEnterCost]);
	scf(query, src, "`keeper`='%i',", BizzInfo[i][bFrac]);
	scf(query, src, "`prods`='%i',", BizzInfo[i][bProds]);
	scf(query, src, "`max_prods`='%i',", BizzInfo[i][bMaxProds]);
	scf(query, src, "`price_prods`='%i',", BizzInfo[i][bPriceProd]);
	scf(query, src, "`interior`='%i',", BizzInfo[i][bInterior]);
	scf(query, src, "`icon`='%i,%i',", BizzInfo[i][bIcon][0], BizzInfo[i][bIcon][1]);
	scf(query, src, "`enter`='%.3f,%.3f,%.3f,%.3f',", BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], BizzInfo[i][bEnter][3]);
	scf(query, src, "`exit`='%.3f,%.3f,%.3f,%.3f' ", BizzInfo[i][bExit][0], BizzInfo[i][bExit][1], BizzInfo[i][bExit][2], BizzInfo[i][bExit][3]);
	scf(query, src, "WHERE `id` = '%i'", BizzInfo[i][bID]);
	Db::tquery(connDb, query, "", "");
	DEBUG[TOTAL_SAVE_BIZNES]++;
	return 1;
}

stock UpdateBizzPickups(b) {
	if(BizzInfo[b][bOwned]) {
		DestroyDynamicMapIcon(BizzInfo[b][bMapIcon]);
		DestroyDynamicPickup(BizzInfo[b][bPickupEnter]);
		if(BizzInfo[b][bIcon][BizzInfo[b][bOwned]] != 0) {
			BizzInfo[b][bMapIcon] = CreateDynamicMapIcon(BizzInfo[b][bEnter][0],BizzInfo[b][bEnter][1],BizzInfo[b][bEnter][2], BizzInfo[b][bIcon][BizzInfo[b][bOwned]], 0, -1, -1, -1, 250.0);
		}
		BizzInfo[b][bPickupEnter] = AddPickup(1239, 23, BizzInfo[b][bEnter][0], BizzInfo[b][bEnter][1], BizzInfo[b][bEnter][2],-1);
	} else {
		DestroyDynamicMapIcon(BizzInfo[b][bMapIcon]);
		DestroyDynamicPickup(BizzInfo[b][bPickupEnter]);
		if(BizzInfo[b][bIcon][BizzInfo[b][bOwned]] != 0) {
			BizzInfo[b][bMapIcon] = CreateDynamicMapIcon(BizzInfo[b][bEnter][0],BizzInfo[b][bEnter][1], BizzInfo[b][bEnter][2], BizzInfo[b][bIcon][BizzInfo[b][bOwned]], 0, -1, -1, -1, 250.0);
		}
		BizzInfo[b][bPickupEnter] = AddPickup(1272, 23, BizzInfo[b][bEnter][0], BizzInfo[b][bEnter][1], BizzInfo[b][bEnter][2],-1);
	}
	return 1;
}

stock UpdateHousePickups(i) {
	DestroyDynamicPickup(HouseInfo[i][hPickup]);
	DestroyDynamicMapIcon(HouseInfo[i][hMapIcon]);
	switch(HouseInfo[i][hOwned]) {
	case 0 : {
			HouseInfo[i][hPickup] = AddPickup(1273, 23, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 0);
			HouseInfo[i][hMapIcon] = CreateDynamicMapIcon( HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 31, 0, 0, -1, -1, 250.0);
		}
	case 1 : {
			HouseInfo[i][hPickup] = AddPickup(1318, 23, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 0);
			HouseInfo[i][hMapIcon] = CreateDynamicMapIcon(HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2], 32,0, 0, -1, -1, 250.0);
		}
	}
	return 1;
}

stock SaveToSQL(idx, type = 1) {
	if(type == 2) {
		format(query, sizeof query, "INSERT INTO `"#__TableVehicles__"` (`Model`,`pX`,`pY`,`pZ`,`pA`,");
		scf(query, temp, "`col1`,`col2`,`resp`) VALUES ('%i',", VehicleInfo[idx][vModel]);
		scf(query, temp, "'%f','%f','%f','%f',", VehicleInfo[idx][vPosX], VehicleInfo[idx][vPosY], VehicleInfo[idx][vPosZ], VehicleInfo[idx][vPosA]);
		scf(query, temp, "'%i','%i','%i')", VehicleInfo[idx][vColor1], VehicleInfo[idx][vColor2], VehicleInfo[idx][vRespTime]);

		new Cache:result = Db::query(connDb, query, true);
		VehicleInfo[idx][vID] = cache_insert_id();
		cache_delete(result);
	}
	return 1;
}

stock UpdateToSQL(idx, type=0) {
	switch(type) {
	case 0 : {
			format(query, sizeof query, "UPDATE `"#__TableVehicles__"` SET ");
			scf(query, src, "`Model`='%i',", VehicleInfo[idx][vModel]);
			scf(query, src, "`pX`='%f',", VehicleInfo[idx][vPosX]);
			scf(query, src, "`pY`='%f',", VehicleInfo[idx][vPosY]);
			scf(query, src, "`pZ`='%f',", VehicleInfo[idx][vPosZ]);
			scf(query, src, "`pA`='%f',", VehicleInfo[idx][vPosA]);
			scf(query, src, "`aM`='%f',", AutoInfo[VehicleInfo[idx][cID]][aMileage]);
			scf(query, src, "`col1`='%i',", VehicleInfo[idx][vColor1]);
			scf(query, src, "`col2`='%i',", VehicleInfo[idx][vColor2]);
			scf(query, src, "`resp`='%i',", VehicleInfo[idx][vRespTime]);
			scf(query, src, "`job`='%i' ", VehicleInfo[idx][vJob]);
			scf(query, src, "WHERE `ID`='%i'", VehicleInfo[idx][vID]);
			Db::tquery(connDb, query, "", "");
			return 1;
		}
	}
	return 0;
}

stock RemoveInSQL(idx, type=1) {
	switch(type) {
	case 2 : {
			format(query, sizeof query, "DELETE FROM `"#__TableVehicles__"` WHERE `ID` = '%i'", VehicleInfo[idx][vID]);
			Db::tquery(connDb, query, "", "");
			return 1;
		}
	}

	return 0;
}

stock updatePickup( i ) {
	format(query, sizeof query, "UPDATE `"#__TablePickups__"` SET ");
	scf(query,src,"`models`='%i,%i',", Portal::Info[i][Portal::Model][0], Portal::Info[i][Portal::Model][1]);
	scf(query,src,"`types`='%i,%i',", Portal::Info[i][Portal::Type][0], Portal::Info[i][Portal::Type][1]);
	scf(query,src,"`interiors`='%i,%i',", Portal::Info[i][Portal::Inter][0], Portal::Info[i][Portal::Inter][1]);
	scf(query,src,"`worlds`='%i,%i',", Portal::Info[i][Portal::World][0], Portal::Info[i][Portal::World][1]);
	scf(query,src,"`portal1`='%.4f,%.4f,", Portal::Info[i][Portal::Portal1][0], Portal::Info[i][Portal::Portal1][1]);
	scf(query,src,"%.4f,%.4f',", Portal::Info[i][Portal::Portal1][2], Portal::Info[i][Portal::Portal1][3]);
	scf(query,src,"`portal2`='%.4f,%.4f,", Portal::Info[i][Portal::Portal2][0], Portal::Info[i][Portal::Portal2][1]);
	scf(query,src,"%.4f,%.4f',", Portal::Info[i][Portal::Portal2][2], Portal::Info[i][Portal::Portal2][3]);
	scf(query,src,"`allowed`='%i' ", arrayToBin(Portal::Info[i][Portal::Allowed], MAX_FRAC));
	scf(query,src,"WHERE `id`='%i'", Portal::Info[i][Portal::Id]);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock updateAntiDmZone(zone) {
	format(query, sizeof query, "UPDATE `"#__TableAntidmzones__"` SET ");
	scf(query,src,"`world`='%i',", AntiDmInfo[zone][e_AntiDmWorld]);
	scf(query,src,"`coord`='%.4f,", AntiDmInfo[zone][e_AntiDmCoord][0]);
	scf(query,src,"%.4f,", AntiDmInfo[zone][e_AntiDmCoord][1]);
	scf(query,src,"%.4f,", AntiDmInfo[zone][e_AntiDmCoord][2]);
	scf(query,src,"%.4f'", AntiDmInfo[zone][e_AntiDmCoord][3]);
	scf(query,src," WHERE `id`='%i'", AntiDmInfo[zone][e_AntiDmZoneId]);
	Db::tquery(connDb, query, "", "");
	return 1;
}


public OnPlayerCommandReceived(playerid, cmdtext[]) {
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	return 1;
}


public OnPlayerCommandPerformed(playerid, cmdtext[], success) {
	switch(success) {
	case -1 : Send(playerid, COLOR_GRAD1, "* “акой команды не существует!");
	}
	return 1;
}


CMD:fish(playerid, params[])
{
    if(sFlood[playerid] > 0) return Send(playerid, 0xFFD5BBAA, "¬ы выловили всю рыбу, приходите позже!");
    if(Flood[playerid] > 0) return Send(playerid, 0xFFD5BBAA, "ѕодождите 5 секунд, перед тем как ловить следующую рыбу!");
    if(fishes[playerid] > 4) return Send(playerid, COLOR_GREY, "¬едро переполнилось!"),sFlood[playerid] = 1800;
	if(!IsAtFishPlace(playerid) && !IsABoat(GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "¬ы не на месте дл€ рыбной ловли(ѕирс в Los Santos или люба€ лодка) !");
    if(Pl::Info[playerid][pLic][4] <= 0)
    {
		if(Pl::Info[playerid][pWantedL] < 6)
		{
			Pl::Info[playerid][pWantedL] += 1;
			SetPlayerCriminal(playerid, 999, "Ѕраконьерство");
		}
    }
	Flood[playerid] = 5;
	new rand;
	new fstring[MAX_PLAYER_NAME],string[128],str[128];
	rand = random(FishNamesNumber);
	if(rand == 0) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали куртку и выбросили его в сторону");
	else if(rand == 4) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали штаны и выбросили их в сторону");
	else if(rand == 7) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали ключи от квартиры в центе —‘ и выбросили в сторону");
	else if(rand == 10) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали пару ботинок и выбросили их в сторону");
	else if(rand == 13) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали тину и выбросили еЄ");
	else if(rand == 20) return Send(playerid, COLOR_LIGHTBLUE, "¬ы поймали сумку с деньгами и выбросили еЄ в сторону");
	fishes[playerid] += 1;
	new rkg = rndNum(3,15);
	fishkg[playerid][fishes[playerid]] = rkg;
	format(fstring, sizeof(fstring), "%s", FishNames[rand]);
	strmid(Fishes[playerid][pFish1], fstring, 0, strlen(fstring), 255);
	format(str, sizeof(str), "%s(%dкг.)", FishNames[rand],rkg);
	strmid(strfish[playerid][fishes[playerid]], str, 0, strlen(str), 255);
	format(string, sizeof(string), "¬ы поймали %s", Fishes[playerid][pFish1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return true;
}

CMD:fishes(playerid, params[])
{
    new string[128];
	format(string, sizeof(string), "¬ы поймали:\n\t1. %s\n\t2. %s\n\t3. %s\n\t4. %s\n\t5. %s", strfish[playerid][1],strfish[playerid][2],strfish[playerid][3],strfish[playerid][4],strfish[playerid][5]);
    SPD(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "¬едро", string, "«акрыть","");
	return true;
}

CMD:throwback(playerid, params[])
{
	if(fishes[playerid] < 1) return Send(playerid,COLOR_GREY, "” вас нету рыбы!");
    if(!IsAtFishPlace(playerid) && !IsABoat(GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "¬ы не в –ыбацком ћесте, или на –ыбацкой Ћодке");
    new string[128];
    fishes[playerid] -= 1;
	format(string, sizeof(string), "¬ы отпустили в океан %s", strfish[playerid][fishes[playerid]]);
	strmid(strfish[playerid][fishes[playerid]], "ѕусто", 0, strlen("ѕусто"), 255);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return true;
}

CMD:throwbackall(playerid, params[])
{
    if(fishes[playerid] < 1) return Send(playerid,COLOR_GREY, "” вас нету рыбы!");
    if(!IsAtFishPlace(playerid) && !IsABoat(GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "¬ы не в –ыбацком ћесте, или на –ыбацкой Ћодке");
    strmid(strfish[playerid][1], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][2], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][3], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][4], "ѕусто", 0, strlen("ѕусто"), 255);
	strmid(strfish[playerid][5], "ѕусто", 0, strlen("ѕусто"), 255);
	Send(playerid, COLOR_LIGHTBLUE, "¬ы отпустили всю рыбу в океан!");
	fishes[playerid] = 0;
	return true;
}

CMD:releasefish(playerid, params[])
{
    if(fishes[playerid] < 1) return Send(playerid,COLOR_GREY, "” вас нету рыбы!");
    if(!IsAtFishPlace(playerid) && !IsABoat(GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "¬ы не в –ыбацком ћесте, или на –ыбацкой Ћодке");
    if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /releasefish [1-5]");
	new string[128];
    fishes[playerid] -= 1;
	format(string, sizeof(string), "¬ы отпустили в океан %s", strfish[playerid][params[0]]);
	strmid(strfish[playerid][params[0]], "ѕусто", 0, strlen("ѕусто"), 255);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return true;
}

CMD:sell(playerid, params[])
{
	if(sscanf(params, "s[15]i", params[1], params[0]))
	{
		Send(playerid, COLOR_WHITE, "¬ведите: /sell fish [1-5]");
		return 1;
	}
	if(strcmp(params[1], "fish", true) == 0)
	{
		if(fishes[playerid] < 1) return Send(playerid,COLOR_GREY, "” вас нету рыбы!");
		if(IsPlayerInRangeOfPoint(playerid,30, -27.5047,-89.9378,1003.5469) || IsPlayerInRangeOfPoint(playerid,30, -29.1611,-184.6501,1003.5469))
		{
			new string[128];
		    fishes[playerid] -= 1;
			format(string, sizeof(string), "¬ы продали %s в магазин", strfish[playerid][params[0]]);
			strmid(strfish[playerid][params[0]], "ѕусто", 0, strlen("ѕусто"), 255);
			Send(playerid, COLOR_LIGHTBLUE, string);
			new rand = rndNum(500,3000);
			Rac::GivePlayerMoney(playerid, rand);

		}
		else Send(playerid, COLOR_GRAD2, "* ¬ы не в магазине 24/7!");
	}
	return true;
}

CMD:gw(playerid, params[])
{
	new string[128];
    if(sscanf(params, "ui", params[0],params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /gw [id] [патроны]");
	if(1 > params[1] || 500 < params[1]) return Send(playerid, COLOR_GREY, " ол-во патронов от 1 до 500");
	if(params[0] == INVALID_PLAYER_ID) return true;
	if(!IsPlayerInRangeOfPlayer(playerid, 2.0, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко!");
	if(Pl::Info[playerid][pLevel] < 3) return Send(playerid, COLOR_GREY, " оманда доступна с 3 уровн€!");
	if(Pl::Info[params[0]][pLevel] < 2) return Send(playerid, COLOR_GREY, "” этого игрока должен быть минимум 2 уровень!");
	new gunID = GetPlayerWeapon(playerid);
	new gunAmmo = GetPlayerAmmo(playerid);
	if(gunID == 0) return Send(playerid, COLOR_GREY, "* ” вас нет оружи€ или вы его не выбрали!");
 	if(gunAmmo < params[1]) return Send(playerid, COLOR_GREY, "” вас нету столько патронов!");
	gunAmmo -= params[1];
 	new sendername[24],playername[24];
	getname(playerid -> sendername, params[0] -> playername);
	new weaponname[40];
	GetWeaponName(gunID,weaponname,sizeof(weaponname)) ;
	Rac::GivePlayerWeapon(params[0], gunID, params[1]);
	Rac::RemovePlayerWeapon(playerid, gunID);
	Rac::GivePlayerWeapon(playerid, gunID, gunAmmo);
	format(string, sizeof(string), "* %s передает %s в руки %s.", sendername, weaponname, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	return true;
}

CMD:armopen(playerid, params[])
{
	if(IsACop(playerid))
 	{
  		if(IsPlayerInRangeOfPoint(playerid,8, -1530.31, 482.44, 7.88))
		{
			MoveObject(arvorota, -1536.31, 482.44, 7.88,3,0.00, 0.00, 0.00);
			SetTimer("Arvorotacl", 8000, 0);
			Send(playerid, 0x6495EDFF, "¬орота закроютс€ через 8 секунд");
		}
	}
	return true;
}

CMD:hopen(playerid, params[])
{
	if(Pl::Info[playerid][pHouseKey] == 100) // “ут номер дома кому пренадлежат ворота
 	{
  		if(IsPlayerInRangeOfPoint(playerid,8, 1643.5996094,-1714.9765625,16.1000004)) // «јмени это: "1643.5996094,-1714.9765625,16.1000004" на свой координат где наход€тс€ ворота
		{
			MoveObject(housegate, 1643.5996094,-1714.9765625,11.6000004,3,0.0000000,0.0000000,0.0000000); //  оординат ќ“ –џ“џ’ ворот и про housegate не забудь
			SetTimer("housecl", 8000, 0); // вместо housecl пиши тот первый forward
			Send(playerid, 0x6495EDFF, "¬орота закроютс€ через 8 секунд");
		}
	}
	return true;
}
	
CMD:bizfee(playerid, params[])
{
	new string[128];
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
    if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /bizfee [стоимость услуги]");
	if(100 > params[0] || 9999 < params[0]) return Send(playerid, COLOR_GREY, "÷ену можно устанавливать от 100 до 9999 вирт");
	BizzInfo[bidx][bEnterCost] = params[0];
	format(string, sizeof(string), "“екуща€ стоимость: $%i", BizzInfo[bidx][bEnterCost]);
	Send(playerid, COLOR_BLUE, string);
	return true;
}
	
CMD:bizwithdraw(playerid, params[])
{
	new string[128];
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
    if(sscanf(params, "i", params[0]))
	{
		Send(playerid, COLOR_GREY, "¬ведите: /bizwithdraw [кол-во]");
		format(string, sizeof(string), "Ќа счету бизнеса: $%i", BizzInfo[bidx][bSafe]);
		Send(playerid, COLOR_BLUE, string);
		return true;
	}
	if(BizzInfo[bidx][bSafe] < (params[0]+100000)) return Send(playerid, COLOR_GREY, "Ќа счету бизнеса недостаточно денег!");
	BizzInfo[bidx][bSafe] -= params[0];
	Rac::GivePlayerMoney(playerid, params[0]);
	format(string, sizeof(string), "¬ы сн€ли: $%i. ќсталось на счету: $%i", params[0], BizzInfo[bidx][bSafe]);
	Send(playerid, COLOR_BLUE, string);
	return true;
}

CMD:extortion(playerid, params[])
{
	new string[128],sendername[MAX_PLAYER_NAME];
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
    if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /extortion [ID(„тобы убрать компаньена - 255)]");
    GetPlayerName(params[0], sendername, 24);
	Pl::Info[params[0]][pBizKey] = BizzInfo[bidx][bID];
	strmid(BizzInfo[bidx][bExtortion], sendername, 0, strlen(sendername), 24);
	format(string, sizeof(string),"“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
	Send(playerid, COLOR_BLUE, string);
	return true;
}

CMD:bizname(playerid, params[])
{
	new string[128];
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
    if(sscanf(params, "s[24]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /bizname [название]");
	strmid(BizzInfo[bidx][bDescription], params[0], 0, strlen(params[0]), 24);
	format(string, sizeof(string), "* Ќазвание изменино! “екущие название: %s", BizzInfo[bidx][bDescription]);
	Send(playerid, COLOR_BLUE, string);
	return true;
}
					
CMD:gps(playerid, params[])
{
    if(Pl::Info[playerid][pGPS] != 1) return Send(playerid,COLOR_GREY,"” вас нету GPS навигатора!");
    if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GRAD2, "¬ы не в машине!");
	SPD(playerid, 4430, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", " ќрганизации\nЅанды\n–аботы\nЅизнесы\n¬ажные места\nќтключить GPS", "¬ыбрать", "ќтмена");
	return true;
}
CMD:givemc(playerid, params[])
{
	new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 4) return Send(playerid, COLOR_GREY, "* ¬ы не медик!");
	if(Pl::Info[playerid][pRank] < 5) return Send(playerid,COLOR_GREY,"* “олько с 5-го ранга!");
	if(!IsPlayerInRangeOfPoint(playerid,100, 347.9703,173.7854,1019.9844)) return Send(playerid, COLOR_GREY, "* ¬ы не в больнице!");
	if(sscanf(params, "uiii", params[0], params[1], params[2], params[3])) return Send(playerid, COLOR_GREY, "¬ведите: /givemc [ID] [÷ена] [ƒиагноз(1 - «доров | 2 - Ќе здоров)] [„асы]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете выдать мед.карту себе!");
	if(Pl::Info[params[0]][pMedKarta] != 0) return Send(playerid, COLOR_GREY, "* ” него уже есть мед.карта!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Rac::GetPlayerMoney(params[0]) < params[1]) return Send(playerid, COLOR_GREY,"* “от человек не сможет оплатить мед.карту!");
    if(params[1] < 1000 || params[1] > 20000) return Send(playerid, COLOR_GREY, "* ÷ена мед.карты не может быть ниже $1000 и выше $20000!");
    if(params[3] < 10 || params[3] > 100) return Send(playerid, COLOR_GREY, "* ћед.карту можно выписывать от 10 до 100 часов!");
    if(params[2] < 1 || params[2] > 2) return Send(playerid, COLOR_GREY, "* ƒиагноз: от 1 до 2!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около вас!");
	SetPVarInt(playerid, "MedBuyer", params[0]);
	SetPVarInt(params[0], "MedSeller", playerid);
	SetPVarInt(params[0], "MedPrice", params[1]);
	SetPVarInt(params[0], "MedDiag", params[2]);
	SetPVarInt(params[0], "MedHour", params[3]);
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* %s предлагает ¬ам купить мед.карту за $%i на %i часов (пишите /accept mc чтобы согласитс€)", sendername, params[1],params[3]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы предложили купить мед.карту %s за $%i на %i часов (пишите /cancel mc чтобы отменить)", playername, params[1],params[3]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:showmc(playerid, params[])
{
    if(Pl::Info[playerid][pMedKarta] == 0) return Send(playerid, COLOR_GREY, "” вас нет мед.карты!");
    if(timermc[playerid] > 0) return Send(playerid, COLOR_GREY, " оманду можно использовать раз в 15 секунд!");
    if(sscanf(params, "u", params[0]))
    {
		new diagnoz[32], string[256];
	    if(Pl::Info[playerid][pMedKarta] == 1) { diagnoz = "{22ff00}«доров"; } else { diagnoz = "{ff001c}Ќе здоров"; }
		format(string, sizeof(string), "{ffffff}¬аш диагноз: %s\n\t{ffffff}—рок действи€ мед.карты истекает через %i часов", diagnoz,Pl::Info[playerid][pMedHour]);
		SPD(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "ћед.карта", string, "√отово","");
		timermc[playerid] = 15;
		return true;
	}
	else
	{
	    if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около вас!");
		new diagnoz[32], string[256];
	    if(Pl::Info[playerid][pMedKarta] == 1) { diagnoz = "{22ff00}«доров"; } else { diagnoz = "{ff001c}Ќе здоров"; }
		format(string, sizeof(string), "{ffffff}ƒиагноз %s: %s\n\t{ffffff}—рок действи€ мед.карты истекает через %i часов", GetName(playerid),diagnoz,Pl::Info[playerid][pMedHour]);
		SPD(params[0], D_NONE, DIALOG_STYLE_MSGBOX, "ћед.карта", string, "√отово","");
		timermc[playerid] = 15;
		return true;
	}
}


CMD:fracpay(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pLeader] != Pl::FracID(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не лидер!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /fracpay [—умма каждому члену фракции]");
	if(!(1000 <= params[0] <= 10000000)) return Send(playerid, COLOR_GREY, "* —умма должна быть от $1000 до $10000000!");
	new fracid = Pl::FracID(playerid);
	new price = (params[0] * Iter::Count(TeamPlayers[fracid]));
	if(price > GetFracMoney(fracid)) return Send(playerid, COLOR_GREY, "* ¬ казне не хватает денег!");
	if(FracPay[fracid] != 0) return Send(playerid, COLOR_GREY, "* «арплату можно выдавать только раз за час!");

	FracPay[fracid] = 1;
	GiveFracMoney(fracid, -price);

	if(IsAGangF(fracid)) {
		foreach(new i: TeamPlayers[fracid]) {
			Rac::GivePlayerMoney(i, params[0]);
			format(string, sizeof(string), "* ¬ы получили зарплату от Ћидера, в размере $%i", params[0]);
			Send(i, COLOR_LIGHTBLUE, string);
		}
	} else {
		foreach(new i: TeamPlayers[fracid]) {
			GivePlayerBankMoney(i, params[0]);
			format(string, sizeof(string), "* ¬ы получили зарплату от Ћидера, в размере $%i", params[0]);
			Send(i, COLOR_LIGHTBLUE, string);
		}
	}
	format(string, sizeof(string), " * ¬ы выдали зарплату членам своей фракции, в размере $%i", price);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:editgarint(playerid, params[]) {
	new house = Pl::Info[playerid][pHouseKey];
	if(!IsPlayerHouseOwner(playerid, house)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(!HouseInfo[house][hgGarage]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет гража!");
	if(!IsPlayerInHouse(playerid, 50.0, house)) return Send(playerid, COLOR_GREY, "* ¬ы должны находитс€ в своем доме!");
	GetPlayerPos(playerid, HouseInfo[house][hgIntPos][0], HouseInfo[house][hgIntPos][1], HouseInfo[house][hgIntPos][2]);
	GetPlayerFacingAngle(playerid, HouseInfo[house][hgIntPos][3]);
	DestroyDynamicPickup(HouseInfo[house][hgPickupInt]);
	HouseInfo[house][hgPickupInt] = CreateDynamicPickup(1318, 23, HouseInfo[house][hgIntPos][0], HouseInfo[house][hgIntPos][1], HouseInfo[house][hgIntPos][2], HouseInfo[house][hID], -1, -1, 30.0);
	UpdateHouseGarage(house);
	Send(playerid, COLOR_YELLOW, "* ѕикап установлен!");
	return 1;
}

CMD:editgarstreet(playerid, params[]) {
	new house = Pl::Info[playerid][pHouseKey];
	if(!IsPlayerHouseOwner(playerid, house)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(!HouseInfo[house][hgGarage]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет гража!");
	if(IsPlayerInRangeOfPoint(playerid, 50.0, HouseInfo[house][hEnter][0], HouseInfo[house][hEnter][1], HouseInfo[house][hEnter][2])) {
		GetPlayerPos(playerid, HouseInfo[house][hgStreetPos][0], HouseInfo[house][hgStreetPos][1], HouseInfo[house][hgStreetPos][2]);
		GetPlayerFacingAngle(playerid, HouseInfo[house][hgStreetPos][3]);
		DestroyDynamicPickup(HouseInfo[house][hgPickupStreet]);
		HouseInfo[house][hgPickupStreet] = CreateDynamicPickup(1318, 23, HouseInfo[house][hgStreetPos][0], HouseInfo[house][hgStreetPos][1], HouseInfo[house][hgStreetPos][2], 0, -1, -1, 8.0);
		UpdateHouseGarage(house);
		Send(playerid, COLOR_YELLOW, "* ѕикап установлен!");
	} else {
		Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от дома!");
	}
	return 1;
}


CMD:mycar(playerid, params[]) {
	return ShowExtraVehiclesMenu(playerid);
}

CMD:dopcar_add(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "uiI(-1)I(-1)", params[0], params[1], params[2], params[3])) return Send(playerid, COLOR_GREY, "¬ведите: /dopcar_add [id/name] [model] (optional [color1] [color2])");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!(400 <= params[1] <= 611)) return Send(playerid, COLOR_GREY, "* Invalid model ID!");
	if(!(TotalExtraVehicles[params[0]] < MAX_EXTRA_VEHICLES)) return Send(playerid, COLOR_GREY, "* ƒл€ этого игрока создано макс. количество доп. транспорта!");
	new Float:x, Float:y, Float:z, Float:a;
	GetPlayerPos(params[0], x, y, z);
	GetPlayerFacingAngle(params[0], a);
	new id = AddExtraVehicle(params[0], params[1], x, y, z, a, params[2], params[3]);
	if(id != INVALID_VEHICLE_ID) {
		Rac::PutPlayerInVehicle(params[0], ExtraVehicles[params[0]][id][evID2], 0);
		GetPlayerName(playerid, sendername, 24);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /dopcar_add", sendername);
		SendToAdmin(COLOR_LIGHTBLUE, string, 4, 3);
		Send(playerid, COLOR_YELLOW, "* ƒоп. траспорт был создан!");
	}
	return 1;
}

CMD:dopcar_del(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /dopcar_del [id/name])");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	dialog[0] = '\0';
	new listitem;
	SetPVarInt(playerid, "SelectedPlayer", params[0]);
	foreach(new i : ExtraVehicles[params[0]]) {
		format(temp, sizeof temp, "extra[%i]", listitem++), SetPVarInt(playerid, temp, i);
		if(ExtraVehicles[params[0]][i][evID2] != INVALID_VEHICLE_ID) {
			scf(dialog, temp, "%s %s %s\n", VehicleNames[ExtraVehicles[params[0]][i][evModel] - 400],\
			ExtraVehicles[params[0]][i][evPark] == PARK_HOME ? ("{33AA33}[домашний]") : (" "));
		} else {
			scf(dialog, temp, "%s {AA3333} [в гараже]\n", VehicleNames[ExtraVehicles[params[0]][i][evModel] - 400]);
		}
	}
	if(!strlen(dialog)) return Send(playerid, COLOR_GREY, "* ” игрока нет доп. машин!");
	SPD(playerid, D_EV_MENU+3, DIALOG_STYLE_LIST, "¬аш личный транспорт", dialog, "SELECT", "CANCEL");
	return 1;
}

CMD:put(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(GetPlayerVehicleID(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы уже в транспорте!");
	new vehicleid = ClosestVeh(playerid, 3.0);
	if(vehicleid == INVALID_VEHICLE_ID) return Send(playerid, COLOR_GREY, "Ќет машин поблизости");
	return Rac::PutPlayerInVehicle(playerid, vehicleid, 0);
}

CMD:fakekill(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fakekill [ид/часть имени] [причина]");
	SyncInfo[playerid][sKillerID] = params[0];
	SyncInfo[playerid][sReasonID] = params[1];
	return Rac::SetPlayerHealth(playerid, 0.0);
}

CMD:loadmap(playerid, params[]) { new string[144], mapfile[24], worldid, interiorid, player;
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "s[24]I(-1)I(-1)I(-1)", mapfile, worldid, interiorid, player))
	return Send(playerid, COLOR_GREY, "¬ведите: /loadmap [mapfile] (example: maps/file.map)");
	new mapid = map::Load(mapfile, worldid, interiorid, player);
	if(mapid == INVALID_MAP_ID) return Send(playerid, COLOR_GREY, "* Map file not found!");
	format(string, sizeof string, "*  арта загружена! [id:%i]", mapid);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:unloadmap(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /unloadmap [mapid]");
	if(!map::Destroy(params[0])) return Send(playerid, COLOR_GREY, "* Invalid map id!");
	format(string, sizeof string, "*  арта выгружена! [id:%i]", params[0]);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:togglereg(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	switch(Gm::Info[Gm::EnableReg]) {
	case 0 : {
			Send(playerid, COLOR_YELLOW, "* –егистраци€ включена!");
			Gm::Info[Gm::EnableReg] = 1;
		}
	case 1 : {
			Send(playerid, COLOR_YELLOW, "* –егистраци€ отключена!");
			Gm::Info[Gm::EnableReg] = 0;
		}
	}
	SaveStuff();
	return 1;
}

CMD:sobcheck(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /sobcheck [id/part name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(AFKInfo[params[0]][afk_State]) return Send(playerid, COLOR_GREY, "* »грок в AFK!");
	if(GetPlayerVehicleID(params[0])) return Send(playerid, COLOR_GREY, "* »грок не должен быть в транспорте!");
	new Float:x, Float:y, Float:z;
	GetPlayerCameraPos(params[0], x, y, z);
	Rac::TogglePlayerControllable(params[0], false);
	SetTimerEx("onSobeitCheck", 4000, false, "if", params[0], z);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /sobcheck к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:ptmcheck(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(Rac::GetPlayerState(playerid) != 9) return Send(playerid, COLOR_GREY, "* “олько в режиме спектировани€!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "* ¬ведите: /ptmcheck [id/part name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	new targetid = GetPlayerTargetPlayer(params[0]);
	if(targetid != INVALID_PLAYER_ID && Rac::GetPlayerState(params[0]) == 1) {
		new Float:x[2], Float:y[2], Float:z[2], Float:a;
		GetPlayerPos(params[0], x[0], y[0], z[0]);
		GetPlayerFacingAngle(params[0], a);
		GetXYInFrontOfPoint(x[0], y[0], a, -3.0);
		GetPlayerPos(targetid, x[1], y[1], z[1]);
		Rac::SetPlayerPos(targetid, x[0], y[0], z[0]);
		SetTimerEx("onPTMCheck", 2000, false, "iifff", params[0], targetid, x[1], y[1], z[1]);
		getname(playerid -> sendername, params[0] -> playername);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /ptmpcheck к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 3, 3);
	} else {
		Send(playerid, COLOR_GREY, "* Ќедостаточно условий!");
	}
	return 1;
}

CMD:payday(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	SetTimer("onPayDay", 100, false);
	return 1;
}

CMD:int(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return 1 ;
	if(sscanf(params, "i", params[0])) return 1;
	if(params[0] <= -1 || params[0] >= sizeof SAInteriors) {
		params[0] = GetPVarInt(playerid, "SelectedItem");
		if(params[0] <= -1) params[0] = 0;
	}
	Rac::SetPlayerPos(playerid, SAInteriors[params[0]][iX], SAInteriors[params[0]][iY], SAInteriors[params[0]][iZ]);
	SetPlayerFacingAngle(playerid, SAInteriors[params[0]][iA]);
	Rac::SetPlayerInterior(playerid, SAInteriors[params[0]][iI]);
	Rac::SetPlayerVirtualWorld(playerid, 100+playerid);
	SetPVarInt(playerid, "SelectedItem", params[0]);
	ShowMenuForPlayer(SAInteriorsMenu, playerid);
	return 1;
}

CMD:cambehind(playerid, params[]) {
	return SetCameraBehindPlayer(playerid);
}

CMD:addskin(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "ii", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fracname [fracid] [skinid]");
	if(!Container::Find(params[0], params[1])) return Send(playerid, COLOR_GREY, "* Skin found!");
	Container::Add(params[0], params[1]);
	format(query, sizeof query, "INSERT INTO `"#__TableFracSkins__"` (`f_id`,`skin_id`) VALUES ('%i','%i')", params[0], params[1]);
	Db::tquery(connDb, query, "", "");
	Send(playerid, COLOR_YELLOW, "* —кин добавлен!");
	return 1;
}

CMD:delskin(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "ii", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fracname [fracid] [skinid]");
	if(!Container::Find(params[0], params[1])) return Send(playerid, COLOR_GREY, "* Skin not found!");
	Container::Remove(params[0], params[1]);
	format(query, sizeof query, "DELETE FROM `"#__TableFracSkins__"` WHERE `f_id` = '%i' AND `skin_id` = '%i'", params[0], params[1]);
	Db::tquery(connDb, query, "", "");
	Send(playerid, COLOR_YELLOW, "* —кин удален!");
	return 1;
}

CMD:fracname(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "is[36]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fracname [fracid] [name]");
	if(!regex_match_exid(params[1], ValidText)) return Send(playerid, COLOR_GREY, "* Ќедопустимое название!");
	SetFracName(params[0], params[1]);
	Send(playerid, COLOR_YELLOW, "* Ќазвание фракции изменено!");
	return 1;
}

CMD:fractag(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "is[16]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fracname [fracid] [name]");
	if(!regex_match_exid(params[1], ValidText)) return Send(playerid, COLOR_GREY, "* Ќедопустимое название!");
	SetFracTag(params[0], params[1]);
	Send(playerid, COLOR_YELLOW, "* “эг фракции изменен!");
	return 1;
}

CMD:netstat(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /netstat [playerid]");
	if(params[0] == 999) Pl::NetStats[playerid] = params[0];
	else if(params[0] == 1000) Pl::NetStats[playerid] = params[0];
	else if(Pl::isLogged(params[0])) Pl::NetStats[playerid] = params[0];
	else Send(playerid, COLOR_GREY, "* Ётот игрок не подключен!");

	return 1;
}

CMD:savecam(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	new Float:player[4], Float:camera[3], Float:vector[3];
	GetPlayerPos(playerid, player[0], player[1], player[2]);
	GetPlayerFacingAngle(playerid, player[3]);
	GetPlayerCameraPos(playerid, camera[0], camera[1], camera[2]);
	GetPlayerCameraFrontVector(playerid, vector[0], vector[1], vector[2]);
	format(string, sizeof string, "SetPlayerPos(playerid, %.4f, %.4f, %.4f, %.4f); // %s\n", player[0], player[1], player[2], player[3], params);
	writeFile("campos.txt", string);
	format(string, sizeof string, "SetPlayerCameraPos(playerid, %.4f, %.4f, %.4f);\n", camera[0], camera[1], camera[2]);
	writeFile("campos.txt", string);
	format(string, sizeof string, "SetPlayerCameraLookAt(playerid, %.4f, %.4f, %.4f);\n", camera[0]+(vector[0]*4), camera[1]+(vector[1]*4), camera[2]+(vector[2]*4));
	writeFile("campos.txt", string);
	Send(playerid, COLOR_YELLOW, "* Camera pos saved");
	return 1;
}

CMD:velocity(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ucf", params[0], params[1], distance)) return Send(playerid, COLOR_GREY, "Used: /superjmp [id] [] [float]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(GetPlayerState(params[0]) == 2 || GetPlayerState(params[0]) == 3) {
		new v_id = GetPlayerVehicleID(params[0]);
		GetVehicleVelocity(v_id, posx, posy, posz);
		switch(params[1]) {
		case 'x' : SetVehicleVelocity(v_id, distance, posy, posz);
		case 'y' : SetVehicleVelocity(v_id, posx, distance, posz);
		case 'z' : SetVehicleVelocity(v_id, posx, posy, distance);

		}
	} else {
		GetPlayerVelocity(params[0], posx, posy, posz);
		switch(params[1]) {
		case 'x' : SetPlayerVelocity(params[0], distance, posy, posz);
		case 'y' : SetPlayerVelocity(params[0], posx, distance, posz);
		case 'z' : SetPlayerVelocity(params[0], posx, posy, distance);
		}
	}
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /velocity к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 3, 3);
	return 1;
}

CMD:addcar(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не должны сидеть в машине!");
	if(sscanf(params, "iiii", params[0], params[1], params[2], params[3])) return Send(playerid, COLOR_GREY, "¬ведите: /addcar [model] [vColor1] [vColor2] [vRespTime time]");
	if(params[0] < 400 || params[0] > 611) return Send(playerid, COLOR_GREY, "* Ќеверный ID моднли!");
	if(params[1] < -1 || params[1] > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126!");
	if(params[2] < -1 || params[2] > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126 !");

	new idx = TOTAL_VEHICLES; TOTAL_VEHICLES++;
	GetPlayerPos(playerid, VehicleInfo[idx][vPosX], VehicleInfo[idx][vPosY], VehicleInfo[idx][vPosZ]);
	GetPlayerFacingAngle(playerid, VehicleInfo[idx][vPosA]);
	VehicleInfo[idx][vModel] = params[0]; VehicleInfo[idx][vColor1] = params[1];
	VehicleInfo[idx][vColor2] = params[2]; VehicleInfo[idx][vRespTime] = params[3];
	VehicleInfo[idx][cID] = Veh::Create(
	VehicleInfo[idx][vModel],
	VehicleInfo[idx][vPosX],
	VehicleInfo[idx][vPosY],
	VehicleInfo[idx][vPosZ],
	VehicleInfo[idx][vPosA],
	VehicleInfo[idx][vColor1],
	VehicleInfo[idx][vColor2],
	VehicleInfo[idx][vRespTime]
	);

	Iter::Add(JobVehicles[VehicleInfo[idx][vJob]], VehicleInfo[idx][cID]);
	SetVehicleNumber(VehicleInfo[idx][cID]);
	SaveToSQL(idx,2);

	Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /addcar", sendername);
	SendToAdmin(COLOR_LIGHTBLUE, string, 4, 3);
	return 1;
}

CMD:parkcar(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY, "* ¬ы не сидите в машине!");

	for(new idx; idx < TOTAL_VEHICLES; idx++) {
		if(IsPlayerInVehicle(playerid, VehicleInfo[idx][cID])) {
			AutoInfo[0][aMileage] = AutoInfo[VehicleInfo[idx][cID]][aMileage];
			GetVehiclePos(VehicleInfo[idx][cID], VehicleInfo[idx][vPosX], VehicleInfo[idx][vPosY], VehicleInfo[idx][vPosZ]);
			GetVehicleZAngle(VehicleInfo[idx][cID], VehicleInfo[idx][vPosA]);
			Veh::Destroy(VehicleInfo[idx][cID]);
			VehicleInfo[idx][cID] = Veh::Create(
			VehicleInfo[idx][vModel],
			VehicleInfo[idx][vPosX],
			VehicleInfo[idx][vPosY],
			VehicleInfo[idx][vPosZ],
			VehicleInfo[idx][vPosA],
			VehicleInfo[idx][vColor1],
			VehicleInfo[idx][vColor2],
			VehicleInfo[idx][vRespTime]
			);
			AutoInfo[VehicleInfo[idx][cID]][aMileage] = AutoInfo[0][aMileage];
			SetVehicleNumber(VehicleInfo[idx][cID]);
			UpdateToSQL(idx, 0);
			Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);
			return Send(playerid, COLOR_YELLOW, "* ћашина была припаркована!");
		}
	}
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /parkcar.", sendername);
	SendToAdmin(COLOR_LIGHTBLUE, string, 4, 3); return 1;
}

CMD:destcar(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY, "* ¬ы не сидите в машине!");

	for(new i; i < TOTAL_VEHICLES; i++) {
		if(IsPlayerInVehicle(playerid, VehicleInfo[i][cID])) {
			AutoInfo[VehicleInfo[i][cID]][aMileage] = 0.0;
			Veh::Destroy(VehicleInfo[i][cID]);
			RemoveInSQL(i, 2);
			TOTAL_VEHICLES --;
			Iter::Remove(JobVehicles[VehicleInfo[i][vJob]], VehicleInfo[i][cID]);
			VehicleInfo[i][vID] = VehicleInfo[TOTAL_VEHICLES][vID];
			VehicleInfo[i][cID] = VehicleInfo[TOTAL_VEHICLES][cID];
			VehicleInfo[i][vModel] = VehicleInfo[TOTAL_VEHICLES][vModel];
			VehicleInfo[i][vPosX] = VehicleInfo[TOTAL_VEHICLES][vPosX];
			VehicleInfo[i][vPosY] = VehicleInfo[TOTAL_VEHICLES][vPosY];
			VehicleInfo[i][vPosZ] = VehicleInfo[TOTAL_VEHICLES][vPosZ];
			VehicleInfo[i][vPosA] = VehicleInfo[TOTAL_VEHICLES][vPosA];
			VehicleInfo[i][vColor1] = VehicleInfo[TOTAL_VEHICLES][vColor1];
			VehicleInfo[i][vColor2] = VehicleInfo[TOTAL_VEHICLES][vColor2];
			VehicleInfo[i][vRespTime] = VehicleInfo[TOTAL_VEHICLES][vRespTime];
			return Send(playerid, COLOR_YELLOW, "* ћашина была удалена!");
		}
	}

	return 1;
}

CMD:changehc(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "iiii", params[0], params[1], params[2], params[3])) return Send(playerid, COLOR_GREY, "¬ведите: /changehc [houseid] [model] [vColor1] [vColor2]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID дома!");
	if(params[1] < 400 || params[1] > 611) return Send(playerid, COLOR_GREY, "* Ќеверный ID моднли!");
	if(params[2] < 0 || params[2] > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126!");
	if(params[3] < 0 || params[3] > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126 !");
	if(HouseInfo[params[0]][hvModel] >= 400 && HouseInfo[params[0]][hvModel] <= 611) ResetTuning(HouseInfo[params[0]][hAuto], 1, params[0]);
	AutoInfo[0][aMileage] = AutoInfo[HouseInfo[params[0]][hAuto]][aMileage];
	GetPlayerPos(playerid, HouseInfo[params[0]][hvSpawn][0], HouseInfo[params[0]][hvSpawn][1], HouseInfo[params[0]][hvSpawn][2]);
	GetPlayerFacingAngle(playerid, HouseInfo[params[0]][hvSpawn][3]);
	Veh::Destroy(HouseInfo[params[0]][hAuto]);
	HouseInfo[params[0]][hvModel] = params[1];
	HouseInfo[params[0]][hvColor][0] = params[2];
	HouseInfo[params[0]][hvColor][0] = params[3];
	HouseInfo[params[0]][hAuto] = Veh::Create(HouseInfo[params[0]][hvModel],
	HouseInfo[params[0]][hvSpawn][0], HouseInfo[params[0]][hvSpawn][1],
	HouseInfo[params[0]][hvSpawn][2], HouseInfo[params[0]][hvSpawn][3],
	HouseInfo[params[0]][hvColor][0], HouseInfo[params[0]][hvColor][1], 18000);
	AutoInfo[HouseInfo[params[0]][hAuto]][aMileage] = AutoInfo[0][aMileage];
	SetVehicleNumber(HouseInfo[params[0]][hAuto]);
	Rac::PutPlayerInVehicle(playerid, HouseInfo[params[0]][hAuto], 0);
	ToggleVehicleDoor(HouseInfo[params[0]][hAuto], false);
	UpdateHouse(params[0]);
	return Send(playerid, COLOR_YELLOW, "* ћашина была создана!");
}

CMD:destroyhc(playerid, params[]) {
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /destroyhc [houseid]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID дома!");
	if(HouseInfo[params[0]][hvModel] < 400 || HouseInfo[params[0]][hvModel] > 611) return Send(playerid, COLOR_GREY, "* ” этого дома нет машины!");
	AutoInfo[HouseInfo[params[0]][hAuto]][aMileage] = 0.0; HouseInfo[params[0]][hvModel] = 0;
	Veh::Destroy(HouseInfo[params[0]][hAuto]); UpdateHouse(params[0]);
	return Send(playerid, COLOR_YELLOW, "* ћашина была удалена!");
}

CMD:apark(playerid, params[]) {
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	new veh = GetPlayerVehicleID(playerid);
	foreach(new i : Houses) {
		if(HouseInfo[i][hAuto] == veh) {
			AutoInfo[0][aMileage] = AutoInfo[HouseInfo[i][hAuto]][aMileage];
			GetVehiclePos(HouseInfo[i][hAuto], HouseInfo[i][hvSpawn][0], HouseInfo[i][hvSpawn][1], HouseInfo[i][hvSpawn][2]);
			GetVehicleZAngle(HouseInfo[i][hAuto], HouseInfo[i][hvSpawn][3]);
			Veh::Destroy(HouseInfo[i][hAuto]);
			HouseInfo[i][hAuto] = Veh::Create(HouseInfo[i][hvModel],
			HouseInfo[i][hvSpawn][0], HouseInfo[i][hvSpawn][1],
			HouseInfo[i][hvSpawn][2], HouseInfo[i][hvSpawn][3],
			HouseInfo[i][hvColor][0], HouseInfo[i][hvColor][1], 18000);
			AutoInfo[HouseInfo[i][hAuto]][aMileage] = AutoInfo[0][aMileage];
			SetVehicleNumber(HouseInfo[i][hAuto]);
			AddTuning(HouseInfo[i][hAuto]);
			Rac::PutPlayerInVehicle(playerid, HouseInfo[i][hAuto], 0);
			return Send(playerid, COLOR_YELLOW, "* ћашина была припаркована в этом месте!");
		}
	}
	Send(playerid, COLOR_GREY, "* Ёто не домашна€ машина!");
	return 1;
}

CMD:park(playerid, params[]) {
	new hid = Pl::Info[playerid][pHouseKey];
	if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(!(400 <= HouseInfo[hid][hvModel] <= 611)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет домашней машины!");
	if(IsPlayerInRangeOfPoint(playerid, 50.0, HouseInfo[hid][hEnter][0], HouseInfo[hid][hEnter][1], HouseInfo[hid][hEnter][2])) {
		GetPlayerPosEx(playerid, HouseInfo[hid][hvSpawn][0], HouseInfo[hid][hvSpawn][1], HouseInfo[hid][hvSpawn][2], HouseInfo[hid][hvSpawn][3]);
		if(IsValidVehicle(HouseInfo[hid][hAuto])) {
			AutoInfo[0][aMileage] = AutoInfo[HouseInfo[hid][hAuto]][aMileage];
			Veh::Destroy(HouseInfo[hid][hAuto]);
		}
		HouseInfo[hid][hvPark] = NONE_VEHICLE;
		HouseInfo[hid][hAuto] = Veh::Create(
		HouseInfo[hid][hvModel],
		HouseInfo[hid][hvSpawn][0],
		HouseInfo[hid][hvSpawn][1],
		HouseInfo[hid][hvSpawn][2],
		HouseInfo[hid][hvSpawn][3],
		HouseInfo[hid][hvColor][0],
		HouseInfo[hid][hvColor][1],
		180000
		);
		AutoInfo[HouseInfo[hid][hAuto]][aOwner] = INVALID_PLAYER_ID * hid;
		AutoInfo[HouseInfo[hid][hAuto]][aMileage] = AutoInfo[0][aMileage];
		SetVehicleNumber(HouseInfo[hid][hAuto]);
		AddTuning(HouseInfo[hid][hAuto]);
		Rac::PutPlayerInVehicle(playerid, HouseInfo[hid][hAuto], 0);
		Send(playerid, COLOR_YELLOW, "* ћашина была припаркована в этом месте!");
	} else if(IsPlayerInHouseGarage(playerid)) {
		HouseInfo[hid][hvPark] = HOME_VEHICLE;
		GetPlayerPosEx(playerid, HouseInfo[hid][hvSpawn][0], HouseInfo[hid][hvSpawn][1], HouseInfo[hid][hvSpawn][2], HouseInfo[hid][hvSpawn][3]);
		if(IsValidVehicle(HouseInfo[hid][hAuto])) {
			AutoInfo[0][aMileage] = AutoInfo[HouseInfo[hid][hAuto]][aMileage];
			Veh::Destroy(HouseInfo[hid][hAuto]);
		}
		HouseInfo[hid][hAuto] = Veh::Create(
		HouseInfo[hid][hvModel],
		HouseInfo[hid][hvSpawn][0],
		HouseInfo[hid][hvSpawn][1],
		HouseInfo[hid][hvSpawn][2],
		HouseInfo[hid][hvSpawn][3],
		HouseInfo[hid][hvColor][0],
		HouseInfo[hid][hvColor][1],
		180000
		);
		AutoInfo[HouseInfo[hid][hAuto]][aOwner] = INVALID_PLAYER_ID * hid;
		AutoInfo[HouseInfo[hid][hAuto]][aMileage] = AutoInfo[0][aMileage];
		LinkVehicleToInterior(HouseInfo[hid][hAuto], 3);
		SetVehicleVirtualWorld(HouseInfo[hid][hAuto], HouseInfo[hid][hVirtual]);
		SetVehicleNumber(HouseInfo[hid][hAuto]);
		AddTuning(HouseInfo[hid][hAuto]);
		Rac::PutPlayerInVehicle(playerid, HouseInfo[hid][hAuto], 0);
		Send(playerid, COLOR_YELLOW, "* ћашина была припаркована в гараже!");
	} else {
		Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от дома!");
	}
	return 1;
}

CMD:bl(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAGang(playerid) && !IsAMafia(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не член банды/мафии");
	new fracid = Pl::FracID(playerid);
	if(sscanf(params, "uS(none)[36]", params[0], params[1])) {
		format(query, sizeof query, "SELECT (SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`accused`),`mink`,FROM_UNIXTIME(`date`),\
		(SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`accuser`),`reason` FROM `"#__TableBlacklist__"` WHERE `f_id`='%i'", fracid);
		Db::tquery(connDb, query, ""#Bl::"Show", "ii", playerid, fracid);
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if((GetBRank(fracid) > Pl::Info[playerid][pRank]) && (Pl::Info[playerid][pLeader] < 1)) {
		format(string, sizeof string, "* ¬ам нужен как минимум %d-й ранг!", GetBRank(fracid));
		Send(playerid, COLOR_GREY, string);
	} else {
		getname(playerid -> sendername, params[0] -> playername);
		if(strcmp(params[1], "none", false) == 0) {
			if(!Bl::Info[params[0]][Bl::onFrac][fracid]) return Send(playerid, COLOR_GREY, "* Ётого игрока нет в вашем „—!");
			Bl::Remove(params[0], fracid);
			format(string, sizeof string, "[BLACK LIST] %s %s вычеркнул ¬ас из черного списка %s", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, FracInfo[fracid][fName]);
			Send(params[0], COLOR_AZTECAS, string);
			format(string, sizeof string, "[BLACK LIST] %s %s вычеркнул %s из черного списка %s", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, playername, FracInfo[fracid][fName]);
			sendToFamily(fracid, COLOR_AZTECAS, string);
		} else {
			if(fracid == Pl::FracID(params[0])) return Send(playerid, COLOR_GREY, "* Ёто невозможно!");
			if(Bl::Info[params[0]][Bl::onFrac][fracid]) return Send(playerid, COLOR_GREY, "* Ётот игрок уже есть в вашем „—!");
			if(strlen(params[1]) > 30) return Send(playerid, COLOR_GREY, "* —лишком длинна€ причина!");
			Bl::Add(params[0], playerid, params[1]);
			format(string, sizeof string, "[BLACK LIST] %s %s внес ¬ас в черный список %s, причина: %s", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, FracInfo[fracid][fName],params[1]);
			Send(params[0], COLOR_AZTECAS, string);
			format(string, sizeof string, "[BLACK LIST] %s %s внес %s в черный список %s, причина: %s", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, playername, FracInfo[fracid][fName], params[1]);
			sendToFamily(fracid, COLOR_AZTECAS, string);
		}
	}
	return 1;
}
/*
CMD:bmenu(playerid, params[]) {
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
	return ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu] ¬ыберете пункт", "dialog/bmenu.txt", "ENTER", "CANCLE");
}
*/
CMD:home(playerid, params[]) {
	if(!IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	return ShowDialog(playerid, D_HMENU, DIALOG_STYLE_LIST, "[House Menu]", "dialog/hmenu.txt", "ENTER", "CANCLE");
}

CMD:lmenu(playerid, params[]) {
	if(!Pl::Info[playerid][pLeader]) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	ShowLMenu(playerid);
	return 1;
}

CMD:antidmzone(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, 5) ) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(TOTAL_ANTIDM_ZONES >= sizeof AntiDmInfo) return Send(playerid, COLOR_GREY, "* —оздано макс. кол-во зон!");
	if(sscanf(params, "f", distance)) return Send(playerid, COLOR_GREY, "¬ведите: /antidmzone [radius]");
	format(string, sizeof string, "INSERT INTO `"#__TableAntidmzones__"` (`coord`) VALUES ('0.0,0.0,0.0,%.4f')", params[0]);
	new Cache:result = Db::query(connDb, string, true);
	if(cache_affected_rows()) {
		new zone = TOTAL_ANTIDM_ZONES++;
		AntiDmInfo[zone][e_AntiDmZoneId] = cache_insert_id();
		AntiDmInfo[zone][e_AntiDmWorld] = GetPlayerVirtualWorld(playerid);
		AntiDmInfo[zone][e_AntiDmCoord][3] = distance;
		GetPlayerPos (
		playerid,
		AntiDmInfo[zone][e_AntiDmCoord][0],
		AntiDmInfo[zone][e_AntiDmCoord][1],
		AntiDmInfo[zone][e_AntiDmCoord][2]
		);
		AntiDmInfo[zone][e_AntiDmZone] = CreateDynamicSphere(
		AntiDmInfo[zone][e_AntiDmCoord][0],
		AntiDmInfo[zone][e_AntiDmCoord][1],
		AntiDmInfo[zone][e_AntiDmCoord][2],
		AntiDmInfo[zone][e_AntiDmCoord][3],
		AntiDmInfo[zone][e_AntiDmWorld]
		);
		updateAntiDmZone(zone);
		Send(playerid, -1, "* јнти-дм зона создана!");
	}
	cache_delete(result);
	return 1;
}

CMD:addpic(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(TOTAL_PORTAL >= sizeof Portal::Info) return Send(playerid, COLOR_GREY, "* —оздано макс. кол-во пикапов!");
	if(sscanf(params, "iI(-1)I(23)", params[0], params[1],params[2]))
	return Send(playerid, COLOR_GREY, "¬ведите: /addpickup [modelid] (optional [vw] [type])");

	format(string, sizeof string, "INSERT INTO `"#__TablePickups__"` (`models`) VALUES ('%i,0')", params[0]);
	new Cache:result = Db::query(connDb, string, true);
	if(cache_affected_rows()) {
		if(params[1] == -1) params[1] = GetPlayerVirtualWorld(playerid);

		new i = TOTAL_PORTAL; TOTAL_PORTAL++;
		Portal::Info[i][Portal::Id] = cache_insert_id();
		Portal::Info[i][Portal::Type][0] = params[2];
		Portal::Info[i][Portal::Model][0] = params[0];
		Portal::Info[i][Portal::Inter][0] = GetPlayerInterior(playerid);
		Portal::Info[i][Portal::World][0] = params[1];
		GetPlayerPos(
		playerid,
		Portal::Info[i][Portal::Portal1][0],
		Portal::Info[i][Portal::Portal1][1],
		Portal::Info[i][Portal::Portal1][2]
		);
		if(params[2] == 14) GetVehicleZAngle(GetPlayerVehicleID(playerid), Portal::Info[i][Portal::Portal1][3]);
		else GetPlayerFacingAngle(playerid, Portal::Info[i][Portal::Portal1][3]);
		Portal::Info[i][Portal::Pickup][0]=_AddPickup(Portal::Info[i][Portal::Model][0],Portal::Info[i][Portal::Type][0],Portal::Info[i][Portal::Portal1],Portal::Info[i][Portal::World][0]);
		updatePickup( i );
		Send(playerid, -1, "* ѕикап входа создан!");
	}
	cache_delete(result);
	return 1;
}

CMD:setpic1(playerid, params[]) {
	if( !Pl::isAdmin(playerid, 5) ) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	new teleport = GetPVarInt(playerid, "selectTeleport");
	if( teleport == 0xffff ) return Send(playerid, COLOR_GREY, "* ¬ы не выбрали портал!");
	if(sscanf(params, "iI(-1)I(23)", params[0], params[1],params[2]))
	return Send(playerid, COLOR_GREY, "¬ведите: /setpic1 [modelid]");

	if( params[1] == -1 ) params[1] = GetPlayerVirtualWorld(playerid);
	Portal::Info[teleport][Portal::Type][0] = params[2];
	Portal::Info[teleport][Portal::Model][0] = params[0];
	Portal::Info[teleport][Portal::Inter][0] = GetPlayerInterior(playerid);
	Portal::Info[teleport][Portal::World][0] = params[1];
	GetPlayerPos(
	playerid,
	Portal::Info[teleport][Portal::Portal1][0],
	Portal::Info[teleport][Portal::Portal1][1],
	Portal::Info[teleport][Portal::Portal1][2]
	);
	if(params[2] == 14) GetVehicleZAngle(GetPlayerVehicleID(playerid), Portal::Info[teleport][Portal::Portal1][3]);
	else GetPlayerFacingAngle(playerid, Portal::Info[teleport][Portal::Portal1][3]);
	DestroyDynamicPickup(Portal::Info[teleport][Portal::Pickup][0]);
	Portal::Info[teleport][Portal::Pickup][0]=_AddPickup(Portal::Info[teleport][Portal::Model][0],Portal::Info[teleport][Portal::Type][0],Portal::Info[teleport][Portal::Portal1],Portal::Info[teleport][Portal::World][0]);
	updatePickup( teleport ), Rac::SetPlayerVirtualWorld(playerid,params[1]), SetPVarInt(playerid, "selectTeleport", 0xffff);
	Send(playerid, COLOR_GREY, "ѕозици€ пикапа изменина!");

	return 1;
}

CMD:setpic2(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	new teleport = GetPVarInt(playerid, "selectTeleport");
	if(teleport == 0xffff) return Send(playerid, COLOR_GREY, "* ¬ы не выбрали портал!");
	if(sscanf(params, "iI(-1)I(23)", params[0], params[1],params[2]))
	return Send(playerid, COLOR_GREY, "¬ведите: /setpic2 [modelid]");

	if( params[1] == -1 ) params[1] = GetPlayerVirtualWorld(playerid);
	Portal::Info[teleport][Portal::Type][1] = params[2];
	Portal::Info[teleport][Portal::Model][1] = params[0];
	Portal::Info[teleport][Portal::Inter][1] = GetPlayerInterior(playerid);
	Portal::Info[teleport][Portal::World][1] = params[1];
	GetPlayerPos
	(
	playerid,
	Portal::Info[teleport][Portal::Portal2][0],
	Portal::Info[teleport][Portal::Portal2][1],
	Portal::Info[teleport][Portal::Portal2][2]
	);
	if(params[2] == 14) GetVehicleZAngle(GetPlayerVehicleID(playerid), Portal::Info[teleport][Portal::Portal2][3]);
	else GetPlayerFacingAngle(playerid, Portal::Info[teleport][Portal::Portal2][3]);
	DestroyDynamicPickup(Portal::Info[teleport][Portal::Pickup][1]);
	Portal::Info[teleport][Portal::Pickup][1]=_AddPickup(Portal::Info[teleport][Portal::Model][1],Portal::Info[teleport][Portal::Type][1],Portal::Info[teleport][Portal::Portal2],Portal::Info[teleport][Portal::World][1]);
	updatePickup( teleport ), Rac::SetPlayerVirtualWorld(playerid,params[1]), SetPVarInt(playerid, "selectTeleport", 0xffff);
	Send(playerid, COLOR_GREY, "ѕозици€ пикапа изменина!");

	return 1;
}

CMD:editmode(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	EditMode[playerid] = !EditMode[playerid];
	SetPVarInt(playerid, "selectTeleport", 0xffff);
	format(string, sizeof string, "–ежим редактировани€: %s", (EditMode[playerid])?("{00cc00}¬кл."):("{ff0000}¬ыкл."));
	Send(playerid, -1, string);
	return 1;
}

CMD:addfc(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "Use: /addfc [fracid]");
	if(params[0] < 1 || params[0] > 20) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	if(Fc::TOTAL >= MAX_FC) return Send(playerid, COLOR_GREY, "* —оздано макс. кол-во транспорта!");
	Fc::ShowModel(playerid, params[0], D_ADD_FC);
	return 1;
}

CMD:delfc(playerid, params[]) {
	new vehid = GetPlayerVehicleID(playerid), idx, fracid;
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* Ќужно быть в автомобиле!");
	if(!Fc::GetInfo(vehid, "if", idx, fracid)) return Send(playerid, COLOR_GREY, "* Ёто не фракционна€ машина!");
	Iter::Remove(TeamVehicles[fracid], vehid);
	Fc::Delete(idx);
	Send(playerid, COLOR_YELLOW, "* ћашина была удалена!");
	return 1;
}

CMD:showmodel(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "Use: /showmodel [fracid]");
	if(params[0] < 1 || params[0] > 20) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	Fc::ShowModel(playerid, params[0], D_SHOW_MODEL);
	return 1;
}

CMD:addrefill(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Iter::Count(Refills) >= sizeof RefillInfo) return Send(playerid, COLOR_GREY, "* —оздано максимальное количество заправок!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬едите: /addrefill [bizid]");
	if(GetIndexFromBizID(params[0]) == -1) return Send(playerid, COLOR_GREY, "* ¬веден не верный ID бизнеса!");

	new i = Iter::Count(Refills);
	Iter::Add(Refills, i);

	GetPlayerPos(playerid, RefillInfo[i][brPos][0], RefillInfo[i][brPos][1], RefillInfo[i][brPos][2]);
	RefillInfo[i][brBizID] = params[0];
	RefillInfo[i][brPickup] = AddPickup(1650, 14, RefillInfo[i][brPos][0], RefillInfo[i][brPos][1], RefillInfo[i][brPos][2], 0);

	format(query, sizeof query, "INSERT INTO `"#__TableRefills__"` (`biz`, `pos`) VALUES (%i,'%.3f,%.3f,%.3f')", params[0], RefillInfo[i][brPos][0], RefillInfo[i][brPos][1], RefillInfo[i][brPos][2]);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_affected_rows()) {
		RefillInfo[i][brID] = cache_insert_id();
		Send(playerid, COLOR_GREY, "* «аправка была добавлена!");
	}
	cache_delete(result);
	return 1;
}

CMD:addbiz(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ii", params[0], params[1])) {
		Send(playerid, COLOR_FADE1, "¬едите: /addbiz [lvl] [type]");
		Send(playerid, COLOR_FADE2, "“ипы бизнесов:");
		Send(playerid, COLOR_FADE3, "0 - обычный, 1 - аммунаци€");
		Send(playerid, COLOR_FADE4, "2 - бургершот, 3 - пиццири€");
		Send(playerid, COLOR_FADE5, "4 - чикен, 5 - 24/7");
		return 1;
	}
	if(Iter::Count(Biznes) >= MAX_BIZNES) return Send(playerid, COLOR_GREY, "* —оздано максимальное количество бизнесов!");
	new Float:x, Float:y, Float:z, Float:a;
	GetPlayerPos(playerid, x, y, z);
	GetPlayerFacingAngle(playerid, a);
	format(query, sizeof query, "INSERT INTO `"#__TableBusines__"` (`enter`) VALUES ('%.3f,%.3f,%.3f,%.3f')", x, y, z, a);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_affected_rows()) {
		new b = Iter::Count(Biznes);
		Iter::Add(Biznes, b);
		switch(params[1]) {
		case 1..5 : {
				BizzInfo[b][bInterior] = DefaultBiz[params[1]][bInterior];
				CopyArray(BizzInfo[b][bIcon], DefaultBiz[params[1]][bIcon], 2);
				CopyArray(BizzInfo[b][bExit], DefaultBiz[params[1]][bExit], 4);
			}
			default : {
				BizzInfo[b][bInterior] = DefaultBiz[0][bInterior];
				CopyArray(BizzInfo[b][bIcon], DefaultBiz[0][bIcon], 2);
				CopyArray(BizzInfo[b][bExit], DefaultBiz[0][bExit], 4);
			}
		}
		BizzInfo[b][bID] = cache_insert_id();
		BizzInfo[b][bOwned] = 0;
		strmid(BizzInfo[b][bOwner], "The State", 0, strlen("The State"), 24);
		strmid(BizzInfo[b][bDescription], "biznes", 0, strlen("biznes"), 24);
		strmid(BizzInfo[b][bExtortion], "No-one", 0, strlen("No-one"), 24);
		BizzInfo[b][bEnter][0] = x;
		BizzInfo[b][bEnter][1] = y;
		BizzInfo[b][bEnter][2] = z;
		BizzInfo[b][bEnter][3] = a;
		BizzInfo[b][bLevel] = params[0];
		BizzInfo[b][bPrice] = 500000;
		BizzInfo[b][bEnterCost] = 500;
		BizzInfo[b][bSafe] = 10000;
		BizzInfo[b][bLocked] = 1;
		BizzInfo[b][bProds] = 250;
		BizzInfo[b][bMaxProds] = 500;
		BizzInfo[b][bPriceProd] = 100;
		BizzInfo[b][bVirtual] = BizzInfo[b][bID];
		BizzInfo[b][bFrac] = Gangs[random(sizeof Gangs)];
		BizzInfo[b][bPickupEnter] = AddPickup(1272, 23, BizzInfo[b][bEnter][0], BizzInfo[b][bEnter][1], BizzInfo[b][bEnter][2]);
		BizzInfo[b][bPickupExit] = AddPickup(1318, 23, BizzInfo[b][bExit][0], BizzInfo[b][bExit][1], BizzInfo[b][bExit][2], BizzInfo[b][bVirtual]);
		BizzInfo[b][bMapIcon] = CreateDynamicMapIcon(BizzInfo[b][bEnter][0],BizzInfo[b][bEnter][1],BizzInfo[b][bEnter][2],52, 0, -1, -1, -1, 250.0);
		GetSquarePos(BizzInfo[b][bEnter][0], BizzInfo[b][bEnter][1], MAX_ZONE_SIZE, BizzInfo[b][bzMinX], BizzInfo[b][bzMinY], BizzInfo[b][bzMaxX], BizzInfo[b][bzMaxY]);
		BizzInfo[b][bZone] = Gz::Create(BizzInfo[b][bzMinX], BizzInfo[b][bzMinY], BizzInfo[b][bzMaxX], BizzInfo[b][bzMaxY]);
		Gz::ShowForAll(BizzInfo[b][bZone], GetFracColor(BizzInfo[b][bFrac]));
		UpdateBizz(b);
		Send(playerid, COLOR_GREY, "* Ѕизнес создан!");
	}
	cache_delete(result);
	return 1;
}


CMD:saveme(playerid, params[]) {
	Pl::Update(playerid);
	return Send(playerid, COLOR_GREY, "* »гра сохраненна");
}

CMD:online(playerid, params[]) {
	ShowDialog(playerid, D_ONLINE, 2, ""#__SERVER_PREFIX""#__SERVER_NAME_LC" ќнлайн", "dialog/online.txt", "¬ыбор","ќтмена");
	return 1;
}

CMD:offline(playerid, params[]) {
	if(!Pl::isAdmin(playerid, 1) && !Pl::Info[playerid][pVip]) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	ShowDialog(playerid, D_OFFLINE, 2, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": OFFLINE", "dialog/offline.txt", "¬ыбор","ќтмена");
	return 1;
}

CMD:leaders(playerid, params[]) {
	return ShowOnline(playerid,0);
}

CMD:licenzers(playerid, params[]) {
	return ShowOnline(playerid,1);
}

CMD:members(playerid, params[]) {
	return ShowOnline(playerid,2);
}

CMD:advokats(playerid, params[]) {
	return ShowOnline(playerid,3);
}

CMD:admins(playerid, params[]) {
	return ShowOnline(playerid,4);
}

CMD:helpers(playerid, params[]) {
	return ShowOnline(playerid,5);
}

CMD:lodgers(playerid, params[]) {
	return ShowOnline(playerid, 6);
}

CMD:iznas(playerid, params[]) {
	if(Pl::Info[playerid][pJailed]) return Send(playerid, COLOR_RED, "* «десь нельз€ ссасть и петушитьс€!");
	if(ReduceTime[playerid] == 3) return Send(playerid, COLOR_LIGHTRED, "¬аши силы исчерпаны.");
	if(sscanf(params, "u", params[0])) Send(playerid, COLOR_GREY, "¬ведите: /iznas [id/Name]");
	if(playerid == params[0]) return Send(playerid, COLOR_RED, "* Ќельз€ изнасиловать самого себ€.");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pVip] > 0) return Send(playerid, COLOR_RED, "* Ёто стальна€ попа!");
	if(!IsPlayerInRangeOfPlayer(playerid, 2.0, params[0])) return Send(playerid, COLOR_GREY, "* »грок слишком далеко!");

	ReduceTime[playerid] += 1;
	if(ReduceTime[playerid] >= 3) {
		SetTimerEx("ReduceTimer", 8000, false, "i", playerid);
		if(Pl::Info[playerid][pWantedL] < 3)
		{
            Pl::Info[playerid][pWantedL] += 1;
			SetPlayerCriminal(playerid, params[0], "»знасилование");
		}
	}
	ApplyAnimation(params[0],"SNM","SPANKINGW",4.1,0,1,1,1,1);
	ApplyAnimation(playerid,"SNM","SPANKEDW",4.1,0,1,1,1,1);
	ApplyAnimation(params[0],"SNM","SPANKINGW",4.1,0,1,1,1,1,1);

	Send(playerid,COLOR_RED,"* ¬ы изнасиловали игрока!");
	Send(params[0],COLOR_RED,"* ¬ас изнасиловали!");
	return 1;
}

CMD:local(playerid, params[]) { new string[144];
	format(string, sizeof string, "¬ы находитесь в локации - %d", Pl::Info[playerid][pLocal]);
	return Send(playerid, 0xFF0000AA, string);
}

CMD:switchkey(playerid, params[]) {
	if(!SwitchKey[playerid]) {
		if(HireCar[playerid] == INVALID_VEHICLE_ID) return GameTextForPlayer(playerid, "~w~You do not hire a car", 5000, 6);
		SwitchKey[playerid] = true;
		GameTextForPlayer(playerid, "~w~You control now your house car", 5000, 6);
	} else {
		SwitchKey[playerid] = false;
		GameTextForPlayer(playerid, "~w~You control now your hire car", 5000, 6);
	}
	return 1;
}

CMD:givekey(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /givekey [id/Name]");
	if(HireCar[playerid] == INVALID_VEHICLE_ID && !IsValidHouse(Pl::Info[playerid][pHouseKey])) Send(playerid, COLOR_GREY, "* ¬ы не можете дать ключ у вас его нет!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* »грок слишком далеко!");

	new vehicleid;
	if(HireCar[playerid] != INVALID_VEHICLE_ID && !SwitchKey[playerid]) {
		vehicleid = HireCar[playerid];
		ToggleVehicleDoor(vehicleid, true);
		HireCar[playerid] = INVALID_VEHICLE_ID;
	}
	else vehicleid = HouseInfo[Pl::Info[playerid][pHouseKey]][hAuto];

	if(HireCar[params[0]] != INVALID_VEHICLE_ID) {
		ToggleVehicleDoor(HireCar[params[0]], true);
	}
	HireCar[params[0]] = vehicleid;
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* ¬ы дали %s свои ключи от машины.", playername);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	Send(playerid, COLOR_GRAD1, string);
	format(string, sizeof string, "* ¬ы получили ключи дл€ машины от %s", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s вынимает набор ключей и передает их %s.", sendername, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	return 1;
}

CMD:handsup(playerid, params[]) {
	if(Pl::CuffedTime[playerid] <= 0) SetPlayerSpecialAction(playerid, SPECIAL_ACTION_HANDSUP);
	return 1;
}


CMD:color(playerid, params[]) return Pl::SetFracColor(playerid);
CMD:red(playerid, params[]) return SetPlayerColor(playerid, COLOR_RED);
CMD:white(playerid, params[]) return SetPlayerColor(playerid, COLOR_WHITE);
CMD:navy(playerid, params[]) return SetPlayerColor(playerid, COLOR_NAVY);
CMD:aqua(playerid, params[]) return SetPlayerColor(playerid, COLOR_AQUA);
CMD:bisque(playerid, params[]) return SetPlayerColor(playerid, COLOR_BISQUE);
CMD:chartreuse(playerid, params[]) return SetPlayerColor(playerid, COLOR_CHARTREUSE);
CMD:brown(playerid, params[]) return SetPlayerColor(playerid, COLOR_BROWN);
CMD:coral(playerid, params[]) return SetPlayerColor(playerid, COLOR_CORAL);
CMD:greenyellow(playerid, params[]) return SetPlayerColor(playerid, COLOR_GREENYELLOW);
CMD:lawngreen(playerid, params[]) return SetPlayerColor(playerid, COLOR_LAWNGREEN);
CMD:limegreen(playerid, params[]) return SetPlayerColor(playerid, COLOR_LIMEGREEN);
CMD:olive(playerid, params[]) return SetPlayerColor(playerid, COLOR_OLIVE);
CMD:pink(playerid, params[]) return SetPlayerColor(playerid, COLOR_PINK);
CMD:springgreen(playerid, params[]) return SetPlayerColor(playerid, COLOR_SPRINGGREEN);
CMD:yellowgreen(playerid, params[]) return SetPlayerColor(playerid, COLOR_YELLOWGREEN);
CMD:mediummagenta(playerid, params[]) return SetPlayerColor(playerid, COLOR_MEDIUMMAGENTA);
CMD:system(playerid, params[]) return SetPlayerColor(playerid, COLOR_SYSTEM);
CMD:purple(playerid, params[]) return SetPlayerColor(playerid, COLOR_PURPLE);
		
CMD:mheal(playerid, params[]) {
	if(!IsPlayerInRangeOfPoint(playerid,4.0,366.3,158.9,1008.3)) return 1;
	if(Pl::FracID(playerid) == 7) Rac::SetPlayerHealth(playerid,100.0);
	return 1;
}

CMD:sit(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY,"* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY,"¬ведите: /sit [playerid]");
	if(Pl::CuffedTime[params[0]] <= 0) return Send(playerid, COLOR_GREY,"* »грок не в наручниках!");
	if(IsPlayerInAnyVehicle(playerid) || IsPlayerInAnyVehicle(params[0])) return Send(playerid, COLOR_GREY,"* ¬ы или тот игрок находитесь уже в тачке!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY,"* ¬ы слишком далеко от игрока!");
	new vehid = ClosestVeh(playerid, 4.0);
	if(vehid != INVALID_VEHICLE_ID) {
		new seatid = GetVehicleFreeSeat(vehid);
		if(seatid) {
			Rac::PutPlayerInVehicle(params[0], vehid, seatid);
			getname(playerid -> sendername, params[0] -> playername);
			format(string, sizeof string, "* %s заломал руки %s, и посадил в машину.", sendername, playername);
			ProxDetector(20.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
		}
		else Send(playerid, COLOR_GREY,"* ¬ тачке нет свободных мест!");
	}
	else Send(playerid, COLOR_GREY, "* ¬ы не р€дом с автомобилем!");

	return 1;
}

CMD:gotome(playerid, params[]) {
	if(!IsACop(playerid)) return Send(playerid,COLOR_GREY,"* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid,COLOR_GREY,"¬ведите: /gotome [playerid]");
	if(IsPlayerInAnyVehicle(playerid) || IsPlayerInAnyVehicle(params[0])) return Send(playerid,COLOR_GREY, "* ¬ы или тот игрок находитесь в тачке!");
	if(Pl::CuffedTime[params[0]] <= 0) return Send(playerid,COLOR_GREY,"* »грок не в наручниках!");
	if(IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid,COLOR_GREY,"* ¬ы слишком далеко от игрока!");
	GetPlayerPos(playerid, posx, posy, posz);
	Rac::SetPlayerPos(params[0],posx+0.5, posy+0.5, posz);
	return Send(params[0],COLOR_LIGHTRED,"* ¬ас насильно потащили за собой!");
}

CMD:dance(playerid, params[]) {
	if(GetPlayerState(playerid) == PLAYER_STATE_ONFOOT) {
		if(sscanf(params, "d", params[0])) return Send(playerid,COLOR_GREY ,"¬ведите: /dance [1-3]");
		if(params[0] < 1 || params[0] > 3) return Send(playerid,COLOR_GREY ,"¬ведите: /dance [1-3]");
		switch(params[0]) {
		case 1: SetPlayerSpecialAction(playerid,SPECIAL_ACTION_DANCE1);
		case 2: SetPlayerSpecialAction(playerid,SPECIAL_ACTION_DANCE2);
		case 3: SetPlayerSpecialAction(playerid,SPECIAL_ACTION_DANCE3);
		}
	}
	return 1;
}

CMD:setname(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_LIGHTRED2, "* Ќики не мен€ем!");
	if(sscanf(params, "us[24]", params[0], params[1])) return Send(playerid, COLOR_GRAD1, "¬ведите: /setname [playerid] [newname]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD1, "* Ётот игрок не залогинен!");
	if(!regex_match_exid(params[1], ValidText)) return Send(playerid, COLOR_GRAD1, "* Ќедопустимый ник!");
	if(NameChange{params[0]}) return Send(playerid, COLOR_GREY, "* Ётому игроку уже изменили ник!");
	if(Pl::Info[params[0]][pAdmin] > Pl::Info[playerid][pAdmin]) return Send(playerid, COLOR_LIGHTRED, "¬ведите: ¬ы не можете изминить им€ админу который старше вас!");
	format(string, sizeof string, "SELECT * FROM `"#__TableUsers__"` WHERE BINARY `Name`='%s'", params[1]);
	new Cache:result = Db::query(connDb, string, true);
	if(cache_get_row_count()) {
		Send(playerid,COLOR_GREY,"* “акое им€ уже есть на сервере!");
	} else {
		SetPVarString(params[0], "NewName", params[1]);
		NameChange{params[0]} = 5;
		Send(params[0],COLOR_LIGHTBLUE,"јдмин сменил вам ник. ¬ течении п€ти секунд изменени€ вступ€т в силу");
		Send(playerid,COLOR_LIGHTBLUE,"¬ы сменили ник игроку. ¬ течении п€ти секунд изменени€ всуп€т в силу");
	}
	cache_delete(result);
	return 1;
}

CMD:setskin(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD1, "»спользуйте: /setskin [ид игрока/часть ника] [ид скина]");
	if(params[1] < 0 || params[1] > 299) return Send(playerid, COLOR_GRAD1, "* ѕоследний скин 299, не больше.");
	Pl::Info[params[0]][pChar] = params[1]; SetPlayerSkin(params[0], Pl::Info[params[0]][pChar]);
	return 1;
}

CMD:pdd(playerid, params[]) {
	return ShowDialog(playerid, D_NONE, 0, "ѕравила дорожного движени€", "dialog/help/pdd.txt", "ENTER", "");
}

CMD:pay(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD1, "¬ведите: /pay [playerid] [amount]");
	if(params[1] > 1000 && Pl::Info[playerid][pLevel] < 2) return Send(playerid, COLOR_GRAD1, "* ¬ы должны быть 2 уровнем, чтобы довать больше $1000");
	if(params[1] < 1 || params[1] > 100000) return Send(playerid, COLOR_GRAD1, "* Ќе ниже 1, и не выше 100000 сразу.");
	if(params[1] > Rac::GetPlayerMoney(playerid)) return  Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 4.0, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко!");
	if(params[1] > 0 && Rac::GetPlayerMoney(playerid) >= params[1]) {
		getname(playerid -> sendername, params[0] -> playername);
		Rac::GivePlayerMoney(playerid, -params[1]);
		Rac::GivePlayerMoney(params[0], params[1]);
		format(string, sizeof string, "* ¬ы передали $%d %s (ID: %d).", params[1], playername, params[0]);
		Send(playerid, COLOR_GRAD1, string);
		PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
		PlayerPlaySound(params[0], 1052, 0.0, 0.0, 0.0);
		format(string, sizeof string, "* ¬ы получили $%d от %s (ID: %d).", params[1], sendername, playerid);
		Send(params[0], COLOR_GRAD1, string);
		format(string, sizeof(string), "* %s достал деньги и передал их игроку %s.", sendername, playername);
		ProxDetector(10.0, playerid, string, 0xC2A2DAAA, 0xC2A2DAAA, 0xC2A2DAAA, 0xC2A2DAAA, 0xC2A2DAAA);
		format(string, sizeof string, "%s заплатил $%d %s", sendername, params[1], playername);
		SendLog(LOG_PAY, string);
	}
	else Send(playerid, COLOR_GRAD1, "* Ќедействительное операционное количество.");

	return 1;
}

CMD:charity(playerid, params[]) { new string[144], sendername[24];
	if(sscanf(params, "d", params[0])) Send(playerid, COLOR_GRAD1, "* ¬ведите: /charity [amount]");
	if(params[0] < 0) return Send(playerid, COLOR_GRAD1, "* ” ¬ас нет денег!");
	if(Rac::GetPlayerMoney(playerid) < params[0]) return Send(playerid, COLOR_GRAD1, "* ” ¬ас нет такова большого количества денег.");
	Rac::GivePlayerMoney(playerid, -params[0]); GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "* %s спасибо вам за пожертвование, $%d.", sendername, params[0]);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	Send(playerid, COLOR_GRAD1, string), SendLog(LOG_PAY,string);
	return 1;
}

CMD:givepas(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 7) return Send(playerid, COLOR_GREY, "* ¬ы не сотрудник мэрии!");
	if(Pl::Info[playerid][pRank] < 2) return Send(playerid,COLOR_GREY,"* “олько со 2-го ранга!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /givepas [id/Name] [days 5-60]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	if(params[1] < 5 || params[1] > 60) return Send(playerid, COLOR_GRAD2, "¬ведите: /givepasport [id/Name] [days 5-60]");

	new currtime = gettime();
	Pl::Info[params[0]][pPasport][0] = 1;
	Pl::Info[params[0]][pPasport][1] = currtime;
	Pl::Info[params[0]][pPasport][2] = ( (params[1] * 86400) + currtime );
	format(string, sizeof string, "* ¬ам был выдан паспорт. „тобы посмотреть его введите: /pasport");
	Send(params[0], COLOR_YELLOW, string);

	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s выдал паспорт игроку %s[%i] на %i дней!", sendername, playername, playerid, params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);

	return 1;
}

CMD:takepas(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 7) return Send(playerid, COLOR_GREY, "* ¬ы не сотрудник мэрии!");
	if(Pl::Info[playerid][pRank] < 2) return Send(playerid,COLOR_GREY,"* “олько со 2-го ранга!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /takepas [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	if(!Pl::Info[params[0]][pPasport][0]) return Send(playerid, COLOR_GRAD2, "* ” этого игрока нет паспорта!");
	for(new i; i < 3; i++) Pl::Info[params[0]][pPasport][i] = 0;

	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* јдминистратор %s забрал ваш паспорт!", sendername);
	Send(params[0], COLOR_YELLOW, string);
	format(string, sizeof string, "[AdmWarn] * %s забрал паспорт у игрока %s[%i]", sendername, playername, playerid);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:agl(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD2, "* Ќедостачточно прав!");
	if(sscanf(params, "s[15]u", params[1], params[0])) {
		Send(playerid, COLOR_WHITE, "¬ведите: /agl [лицензи€] [id/Name]");
		Send(playerid, COLOR_WHITE, "* ƒоступные лицензии: Driving, Pilots, Sailing, Weapon, Fishing");
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	getname(playerid -> sendername, params[0] -> playername);

	if(strcmp(params[1], "all", true) == 0) {
		AshQueue(playerid, 1);
		Pl::Info[params[0]][pTest] = 0;
		Pl::Info[params[0]][pLic][0] = 1;
		Pl::Info[params[0]][pLic][1] = 1;
		Pl::Info[params[0]][pLic][3] = 1;
		Pl::Info[params[0]][pLic][2] = 1;
		Pl::Info[params[0]][pLic][4] = 1;

		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s дал вам все лицензии.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1], "driving",true) == 0) {
		AshQueue(playerid, 1);

		Pl::Info[params[0]][pTest] = 0;
		Pl::Info[params[0]][pLic][0] = 1;

		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s ƒал вам лицензию на вождение.", sendername);
		Send(params[1], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1],"pilots",true) == 0) {
		Pl::Info[params[0]][pLic][1] = 1;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s ƒал вам лицензию на управление воздушным транспортом.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1],"sailing",true) == 0) {
		Pl::Info[params[1]][pLic][2] = 1;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s ƒал вам лицензию на управление водным транспортом.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1],"weapon",true) == 0) {
		Pl::Info[params[0]][pLic][3] = 1;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s ƒал вам лицензию на оружие.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1],"fishing",true) == 0) {
		Pl::Info[params[0]][pLic][4] = 1;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /agl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s ƒал вам лицензию на рыбалку.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	return 1;
}

CMD:atl(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD2, "* Ќедостачточно прав!");
	if(sscanf(params, "s[15]u", params[1], params[0])) {
		Send(playerid, COLOR_WHITE, "¬ведите: /atl [лицензи€] [playerid]");
		Send(playerid, COLOR_WHITE, "* ƒоступные лицензии: Driving, Pilots, Sailing, Weapon, Fishing.");
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");

	getname(playerid -> sendername, params[0] -> playername);

	if(strcmp(params[1], "all", true) == 0) {
		Pl::Info[params[0]][pLic][0] = 0;
		Pl::Info[params[0]][pLic][1] = 0;
		Pl::Info[params[0]][pLic][3] = 0;
		Pl::Info[params[0]][pLic][2] = 0;
		Pl::Info[params[0]][pLic][4] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у ¬ас все лицензии.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1], "driving",true) == 0) {
		Pl::Info[params[0]][pLic][0] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у вас лицензию на вождение.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(params[1], "pilots",true) == 0) {
		Pl::Info[params[0]][pLic][1] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], params[1]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у вас лицензию на управление воздушным транспортом.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);

	} else if(strcmp(temp,"sailing",true) == 0) {
		Pl::Info[params[0]][pLic][2] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], temp);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у вас лицензию на управление водным транспортом.", sendername);
		Send(params[1], COLOR_LIGHTBLUE, string);

	} else if(strcmp(temp, "weapon",true) == 0) {
		Pl::Info[params[0]][pLic][3] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], temp);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у вас лицензию на оружие.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		
	} else if(strcmp(temp, "fishing",true) == 0) {
		Pl::Info[params[0]][pLic][4] = 0;
		format(string, sizeof string, "[AdmWarn] * %s применил команду /atl к игроку %s[%s]. “ип: %s",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName], temp);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
		format(string, sizeof string, "* јдминистратор %s забрал у вас лицензию на рыбалку.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	return 1;
}

CMD:stats(playerid, params[]) {
	return ShowStats(playerid, playerid, 0);
}

CMD:inv(playerid, params[])
{
    Send(playerid, COLOR_GRAD2, "[RP]GreatWorld: јктивирован режим невидимки!");
	return SetPlayerColor(playerid, 0xFFFFFF00);
}

CMD:propose(playerid, params[]) // сделать предложение
{
	new string[128], name_1[25], name_2[25];
	if(GetPlayerMoney(playerid) < 100000) return SendClientMessage(playerid, COLOR_GREY, "«атраты Ѕрака $100000!");
	if(!IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}¬ы не имеете ƒома!");
	if(Pl::Info[playerid][pMarried]) return SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}¬ы уже ∆енаты !");
	if(sscanf(params, "r", params[0])) return SendClientMessage(playerid, COLOR_WHITE, "{b3f9b0}Х {FFFFFF} /propose [ID игрока/„асть»мени]");
	if(params[0] != INVALID_PLAYER_ID && params[0] != playerid)
	{
		if(Pl::Info[params[0]][pMarried]) return SendClientMessage(playerid, COLOR_GREY, "Ётот игрок уже ∆енат !");
        GetPlayerName(playerid, name_1, sizeof(name_1));
		GetPlayerName(params[0], name_2, sizeof(name_2));
		format(string, sizeof(string), "¬ы предложили выйти замуж %s.", name_2);
		SendClientMessage(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof(string), "%s предложил вам выйти замуж, ¬ы согласны?", name_1);
		SPD(params[0], 10000, DIALOG_STYLE_MSGBOX, "ѕредложение", string, "ƒа", "Ќет");
		ProposeOffer[params[0]] = playerid;
	}
	else SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}Ётого игрока нету на сервере !");
	return true;
}

CMD:witness(playerid, params[]) // назначить свидетел€
{
    new string[128], name_1[25], name_2[25];
	if(sscanf(params, "r", params[0])) return SendClientMessage(playerid, COLOR_WHITE, "{b3f9b0}Х {FFFFFF} /witness [ID игрока/„асть»мени]");
	if(params[0] != INVALID_PLAYER_ID && params[0] != playerid)
	{
	    GetPlayerName(playerid, name_1, sizeof(name_1));
		GetPlayerName(params[0], name_2, sizeof(name_2));
		format(string, sizeof(string), "¬ы просите %s быть вашим —видетелем Ѕрака.", name_2);
		SendClientMessage(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof(string), "%s просит ¬ас быть его —видетелем Ѕрака, ¬ы согласны?", name_1);
      	SPD(params[0], 10001, DIALOG_STYLE_MSGBOX, "ѕредложение", string, "ƒа", "Ќет");
		MarryWitnessOffer[params[0]] = playerid;
	}
	else SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}Ётого игрока нету на сервере !"); // by Extazy and update by Flashin
	return true;
}

CMD:divorce(playerid, params[]) // развод
{
    new string[128], name_1[25], name_2[25];
	if(!Pl::Info[playerid][pMarried]) return SendClientMessage(playerid, COLOR_WHITE,"{f9b0b0}x {FFFFFF}¬ы не женаты !");
	if(sscanf(params, "r", params[0])) return SendClientMessage(playerid, COLOR_WHITE, "{b3f9b0}Х {FFFFFF} /divorce [ID игрока/„асть»мени]");
	if(params[0] != INVALID_PLAYER_ID && params[0] != playerid)
	{
	    GetPlayerName(playerid, name_1, sizeof(name_1));
		GetPlayerName(params[0], name_2, sizeof(name_2));
		if(strcmp(Pl::Info[params[0]][pMarriedTo], name_1, false) == 0)
		{
			format(string, sizeof(string), "¬ы послали Ѕумаги –азвода к %s.", name_2);
			SendClientMessage(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof(string), "%s послал ¬ам Ѕумаги на –азвод, ¬ы согласны?", name_1);
			SPD(params[0], 10002, DIALOG_STYLE_MSGBOX, "ѕредложение", string, "ƒа", "Ќет");
			DivorceOffer[params[0]] = playerid;
		}
		else SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}Ётот игрок не ∆енат на ¬ас !");
	}
	else SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}Ётот игрок не на сервере.");
	return true;
}

CMD:delivery(playerid, params[]) {
	if(Pl::Info[playerid][pJob] != 10) return Send(playerid,COLOR_GREY,"¬ы не дальнобойщик!");
	if(GetPlayerState(playerid) != 2) return Send(playerid,COLOR_GREY,"* ¬ы не в транспорте!");
	new veh = GetPlayerVehicleID(playerid);
	if(!IsATruckCar(veh)) return Send(playerid,COLOR_GREY,"¬ы не в тачке дальнобойщика!");
	if(!IsAnyTrailerAttachedToVehicle(veh)) return Send(playerid,COLOR_GREY,"* ” ¬ас не прицеплен прицеп!");
	if(acceptgruz{playerid} > 0) return Send(playerid,COLOR_GREY,"* ¬ы уже вз€ли груз");
	new rnd; do { rnd = random(sizeof(CargoInfo)); } while(!rnd);
	DestroyDynamicPickup(pickupd[playerid][0]); DestroyDynamicMapIcon(pickupd[playerid][1]); acceptgruz{playerid} = rnd;
	pickupd[playerid][0] = CreateDynamicPickup(1239, 14, CargoInfo[rnd][0], CargoInfo[rnd][1], CargoInfo[rnd][2], 0, 0, playerid, 50.0);
	pickupd[playerid][1] = CreateDynamicMapIcon(CargoInfo[rnd][0], CargoInfo[rnd][1], CargoInfo[rnd][2], 51, 0, 0, 0, playerid, 99999.9);
	Streamer::SetIntData(4, pickupd[playerid][1], E_STREAMER_STYLE, MAPICON_GLOBAL_CHECKPOINT);
	Send(playerid,COLOR_LIGHTBLUE,"√руз загружен! ќтвезите груз на маркер!");
	return 1;
}

CMD:skydive(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(GetPlayerInterior(playerid) > 0) return Send(playerid, COLOR_GREY, "*  ¬ы не можете прыгать с парашютом в помещении!");
	GetPlayerPos(playerid, posx, posy, posz);
	Rac::SetPlayerPos(playerid, posx, posy, posz+1000);
	Rac::GivePlayerWeapon(playerid, 46, 1);
	return 1;
}

CMD:check(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /check [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::isAdmin(params[0], 5) && !Pl::isAdmin(playerid,5)) return Send(playerid, COLOR_RED, "* ¬ы не может выполнить это действие!");
	return ShowStats(playerid, params[0], 1);
}

CMD:checkw(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /checkw [id/Name]");
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_RED, "* Ётот игрок не залогинен!");
	new isw, weapon, ammo, wname[24]; dialog[0]='\0';
	for(new i; i < 13; i++) {
		GetPlayerWeaponData(params[0], i, weapon, ammo);
		if(weapon != 0 && ammo != 0) {
			isw ++;
			GetWeaponName(weapon, wname, 24);
			if(Rac::GetPlayerAmmo(params[0], weapon) < ammo && !Rac::IsGreenWeapon(weapon)) {
				scf(dialog, string, ""#_GREY_ARROW"%s[ID: %i] | ѕатроны: %d\n", wname, weapon, ammo);
			} else {
				scf(dialog, string, ""#_GREY_ARROW"%s[ID: %i] | ѕатроны: %d\n", wname, weapon, ammo);
			}
		}
	}
	format(string, sizeof string, "%s имеет следующие оружие:", GetName(params[0]));
	if(isw > 0) SPD(playerid, D_NONE, DIALOG_STYLE_LIST, string, dialog, "OK", "");
	else SPD(playerid, D_NONE, 0, string, "” этого игрока нет оружи€!", "OK", "");

	return 1;
}

CMD:number(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pPhoneBook] != 1) return Send(playerid, COLOR_GREY, "* ” ¬ас нет телефонной книги!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD1, "¬ведите: /number [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не подключен!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	format(string, sizeof string, "Name: %s, Ph: %d", GetName(params[0]), Pl::Info[params[0]][pNumber]);
	Send(playerid, COLOR_GRAD1, string);
	return 1;
}

CMD:buylevel(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pLevel]) {
		if(Rac::GetPlayerMoney(playerid) < costlvl(playerid)) {
			format(string, sizeof string, "* ” ¬ас нет достаточного количества наличных денег ($%d) !", costlvl(playerid));
			Send(playerid, COLOR_GRAD1, string);
		} else if (Pl::Info[playerid][pExp] < EXP(playerid)) {
			format(string, sizeof string, "* Ќужно %d респектов, ” ¬ас всего [%d] !", EXP(playerid), Pl::Info[playerid][pExp]);
			Send(playerid, COLOR_GRAD1, string);
		} else {
			Pl::Info[playerid][pAge] ++; GameTextForPlayer(playerid, string, 5000, 1);
			format(string, sizeof string, "* ¬ы купили уровень %d за ($%d)", (Pl::Info[playerid][pLevel]+1), costlvl(playerid));
			Send(playerid, COLOR_LIGHTBLUE, string);

			format(string, sizeof string, "~g~LEVEL UP~n~~w~You Are Now Level %d", (Pl::Info[playerid][pLevel] + 1));
			PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0); PlayerPlayMusic(playerid);
			Rac::GivePlayerMoney(playerid, -costlvl(playerid)); GiveFracMoney(7, costlvl(playerid));
			Pl::Info[playerid][pLevel]++;

			if(Pl::Info[playerid][pVip] > 0) {
				Pl::Info[playerid][pExp] -= EXP(playerid);
				if(Pl::Info[playerid][pExp] <= 0) Pl::Info[playerid][pExp] = 0;
			}
			else Pl::Info[playerid][pExp] = 0;
		}
	}
	return 1;
}

CMD:savetun(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY,"* ¬ы должны сидеть в машине!");
	if(sscanf(params, "s[10]", params[0])) return Send(playerid, COLOR_GREY,"/savetun [name]");
	new vehid = GetPlayerVehicleID(playerid);
	if(strcmp(params[0], "house", true) == 0) {
		foreach(new i : Houses) {
			if(HouseInfo[i][hAuto] == vehid) {
				UpdateTuning(HouseInfo[i][hAuto], 1, i);
				return Send ( playerid, COLOR_YELLOW, "* “юниг домашней машины был сохранен!");
			}
		}

	} else if(strcmp(params[0], "veh", true) == 0) {
		for(new i; i < TOTAL_VEHICLES; i++) {
			if(VehicleInfo[i][cID] == vehid) {
				UpdateTuning(VehicleInfo[i][cID], 2, VehicleInfo[i][vID]);
				return Send ( playerid, COLOR_YELLOW, "* “юниг машины был сохранен!");
			}
		}
	}
	return Send(playerid, COLOR_YELLOW, "* ќшибка, у этой машины нельз€ сохранить тюнинг!");
}

CMD:deltun(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY,"* ¬ы должны сидеть в машине!");
	if(sscanf(params, "s[10]", params[0])) return Send(playerid, COLOR_GREY,"/deltun [name]");
	new vehid = GetPlayerVehicleID(playerid);
	if(strcmp(params[0], "house", true) == 0) {
		foreach(new i : Houses) {
			if(HouseInfo[i][hAuto] == vehid) {
				ResetTuning(HouseInfo[i][hAuto], 1, i);
				return Send ( playerid, COLOR_YELLOW, "* “юниг домашней машины был удален!");
			}
		}
	}
	else if(strcmp(params[0], "veh", true) == 0) {
		for(new i; i < TOTAL_VEHICLES; i++) {
			if(VehicleInfo[i][cID] == vehid) {
				ResetTuning(VehicleInfo[i][cID], 2, VehicleInfo[i][vID]);
				return Send ( playerid, COLOR_YELLOW, "* “юниг машины был удален!");
			}
		}
	}
	return Send(playerid, COLOR_YELLOW, "* ќшибка, у этой машины нельз€ удалить тюнинг!");
}

CMD:asetpass(playerid, params[]) { new string[144], uname[24], ukey[36], uhash[SHA1_HASH_LEN];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]s[36]", uname, ukey)) return Send(playerid, COLOR_GREY, "¬ведите: /asetpass [name] [password]");
	new pid=ReturnUser(uname);
	if(Pl::isLogged(pid)) {
		KeyProtect(ukey, uhash);
		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Key`='%s' WHERE `ID`='%i'", uhash, Pl::Info[pid][pID]);
		Db::tquery(connDb, query, "", "");

		format(string, sizeof string, "* ¬ы изменили пароль %s, новый пароль; %s", uname, ukey);
		Send(playerid, COLOR_LIGHTRED, string);
		format(string, sizeof string, "* јдминистратор %s изменили ваш пароль, новый пароль %s", GetName(playerid), ukey);
		Send(pid, COLOR_LIGHTRED, string);
		Send(playerid, COLOR_LIGHTRED,"* ќЅя«ј“≈Ћ№Ќќ сделайте скриншот с новым паролем, дл€ этого нажмите F8");

		format(string, sizeof string, "[AdmWarn] * %s изменил пароль %s[uid:%i]", GetName(playerid), uname, Pl::Info[pid][pID]);
		SendLog(LOG_ADMWARN, string);
	} else {
		new uid = GetIDFromName(uname);
		if(uid == -1) return Send(playerid, COLOR_GREY, "* Ќет такого юзера!");
		KeyProtect(ukey, uhash);
		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Key`='%s' WHERE `ID`='%i'", uhash, uid);
		Db::tquery(connDb, query, "", "");

		format(string, sizeof string, "* ¬ы изменили пароль %s, новый пароль %s", uname, ukey);
		Send(playerid, COLOR_LIGHTRED, string);

		format(string, sizeof string, "[AdmWarn] * %s изменил пароль %s[uid:%i]", GetName(playerid), uname, uid);
		SendLog(LOG_ADMWARN, string);
	}
	return 1;
}

CMD:setpass(playerid, params[]) {
	SPD(playerid, D_CHANGE_PASS, DIALOG_STYLE_PASSWORD, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ATTENTION PLEASE",
	"¬Ќ»ћјЌ»≈! ƒл€ изменени€ парол€ от вашего\n\
	аккаунта Ќ≈ќЅ’ќƒ»ћќ ¬¬≈—“» “≈ ”ў»… ѕј–ќЋ№!\n\
	¬ы будете забанены, если укажите неверный пароль!", "ќ ", "ќ“ћ≈Ќј");
	return 1;
}

CMD:setsex(playerid, params[]) {
	SPD(playerid, 65, DIALOG_STYLE_MSGBOX, "—мена пола", "¬ыбирите ваш пол.", "ƒ≈¬”Ў ј", "ѕј–≈Ќ№");
	return 1;
}

CMD:setage(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid,COLOR_GREY,"* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setage [id] [возраст]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Pl::Info[params[0]][pAge] = params[1];
	return 1;
}

CMD:ad(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(Pl::Info[playerid][pJailed] != 0) return Send(playerid, COLOR_GREY, "* ¬ы не можите использовать эту команду в тюрьме!");
	if(Pl::Info[playerid][pLevel] < 2) return Send(playerid, COLOR_GREY, "* „тобы подать рекламу вам требуетс€ 2 level!");
	if(Pl::Info[playerid][pTime] < 2) return Send(playerid, COLOR_GREY, "* ¬ы должны отыграть 2 часа на сервере, чтобы использовать эту команду!");
	if(Pl::Info[playerid][pNumber] == 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет телефона!  упить его можно в 24/7.");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /ad [текст]");
	else if(!adds && !Pl::isAdmin(playerid, 3)) {
		format(string, sizeof string, "ѕожалуйста попробуйте еще раз позже %i секунды между –екламными объ€влени€ми!",  (addtimer/1000));
		Send(playerid, COLOR_GRAD2, string);
	} else {
		new len = strlen(params);
		new payout = len * 25;
		if(Rac::GetPlayerMoney(playerid) < payout) {
			format(string, sizeof string, "* ¬ы написали %d символов, стоимостью $%d. ” ¬ас нет столько денег.", len, payout);
			Send(playerid, COLOR_LIGHTBLUE, string);
		} else {
			new bidx = GetIndexFromBizID(Bizz_TelephoneCompany);
			GetPlayerName(playerid, sendername, 24);
			Rac::GivePlayerMoney(playerid, -payout);
			GiveBizzProfit(bidx, payout);
			if(Pl::FracID(playerid) == 8 && Pl::Info[playerid][pMaskOn]) {
				format(string, sizeof string, "ќбъ€вление: %s. јвтор: Ќеизвестно, телефон: Ќеизвестно.", params[0]);
			} else {
				format(string, sizeof string, "ќбъ€вление: %s. јвтор: %s, телефон: %i.", params[0], sendername, Pl::Info[playerid][pNumber]);
			}
			OOCNews(COLOR_GROVE,string);
			SendLog(LOG_AD_CHAT,string);
			format(string, sizeof string, "~r~Paid $%d~n~~w~Message contained: %d Characters", payout, len);
			GameTextForPlayer(playerid, string, 7000, 5);
		}
		if(!Pl::isAdmin(playerid, MODER3LVL)) {
			adds = false;
			SetTimer("AddsOn", addtimer, false);
		}
	}
	return 1;
}

CMD:gov(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /gov [текст]");
	if(Pl::Info[playerid][pLevel] < 2) return Send(playerid, COLOR_GREY, "* ¬ы должны иметь 3 лвл!");
	new fracid = Pl::FracID(playerid);
	GetPlayerName(playerid, sendername, 24);
	switch(fracid) {
	case 1..4, 7, 10, 11 : {
			if(Pl::Info[playerid][pRank] >= GetGRank(fracid)) {
				SendToAll(COLOR_WHITE, "______________| √ородские новости |______________");
				format(string, sizeof string, "*%s %s: %s", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, params);
				SendToAll(COLOR_DBLUE, string);
				SendLog(LOG_GOV_CHAT, string);
			} else {
				format(string, sizeof string, "* ƒоступно только с %i ранга", GetGRank(fracid));
				Send(playerid, COLOR_GREY, string);
			}
		}
	}
	return 1;
}

CMD:togooc(playerid, params[]) { new string[144];
	gOoc[playerid] = !gOoc[playerid];
	format(string, sizeof string, "* „ат OOC %s!", (gOoc[playerid])?("включен"):("выключен"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:tognews(playerid, params[]) { new string[144];
	gNews[playerid] = !gNews[playerid];
	format(string, sizeof string, "* Ќовости %s!", (gNews[playerid])?("включены"):("выключены"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:togfam(playerid, params[]) { new string[144];
	gFam[playerid] = !gFam[playerid];
	format(string, sizeof string, "* „ат семьи %s!", (gFam[playerid])?("включен"):("выключен"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:noooc(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	noooc = !noooc;
	format(string, sizeof string, "** OOC чат %s администратором.", (noooc)?("выключен"):("включен"));
	SendToAll(COLOR_GREY, string);
	return 1;
}

CMD:bigears(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	BigEar[playerid] = !BigEar[playerid];
	format(string, sizeof string, "* ¬аши уши %s!", (BigEar[playerid])?("выросли"):("стали нормальными"));
	Send(playerid, COLOR_GREY, string);
	return 1;
}

CMD:togphone(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pVip] != 1 && !Pl::isAdmin(playerid, 1)) return Send(playerid, COLOR_LIGHTRED2, "* Ќедостаточно прав!");
	PhoneOnline[playerid] = !PhoneOnline[playerid];
	format(string, sizeof string, "* ¬аш телефон %s!", (PhoneOnline[playerid])?("включен"):("выключен"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:togtp(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_LIGHTRED2, "* Ќедостаточно прав!");
	TogTP[playerid] = !TogTP[playerid];
	format(string, sizeof string, "* ¬ы %s телепортироватс€ к себе!", (TogTP[playerid])?("разрешили"):("запретили"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:toglogins(playerid, params[]) {
	if(!Iter::Contains(ToglogPlayers, playerid)){
		Iter::Add(ToglogPlayers, playerid);
		Send(playerid, COLOR_GREY, "* —ообщени€ о подключении/отключении игроков включены!");
	} else {
		Iter::Remove(ToglogPlayers, playerid);
		Send(playerid, COLOR_GREY, "* —ообщени€ о подключении/отключении игроков отключены!");
	}
	return 1;
}

CMD:me(playerid, params[]) { new string[144];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(sscanf(params, "s[90]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /me [текст]");
	format(string, sizeof string, "* %s %s", GetName(playerid), params[0]);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	return 1;
}

CMD:knockdown(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(useknock[playerid] > 0) return Send(playerid, COLOR_GREY, "* Ёту команду можно использовать только раз в 30 сек");
	if(Fell[playerid] > 0) return  Send(playerid, COLOR_GREY, "* ¬ас сбили, и вы не можете сбить с ног");
	if(IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ транспорте нельз€ использовать эту команду");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /knockdown [id/Name]");
	if(playerid == params[0]) return Send(playerid, COLOR_GREY, "* Ќельз€ сбить с ног самого себ€!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "¬ы слишком далеко!");
	if(IsPlayerInAnyVehicle(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок в транспорте");
	new rannn = random(100);
	getname(playerid -> sendername, params[0] -> playername);
	if(rannn < 30) {
		format(string, sizeof string, "* %s попыталс€(ась) сбить с ног %s (неудачно)", Pl::Info[playerid][pMaskOn]?("Ќеизвесный"):(sendername), playername);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	} else if(rannn >= 30) {
		format(string, sizeof string, "* %s попыталс€(ась) сбить с ног %s (удачно)", Pl::Info[playerid][pMaskOn]?("Ќеизвесный"):(sendername), playername);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
		Rac::TogglePlayerControllable(params[0], 0);
		ApplyAnimation(params[0],"PED","BIKE_fall_off",4.1,0,1,1,1,1);
		ApplyAnimation(playerid,"PED","GUN_BUTT_crouch",4.1,0,1,1,1,1);
		TurnPlayerFaceToPlayer(params[0], playerid);
		TurnPlayerFaceToPlayer(playerid, params[0]);
		Rac::GivePlayerHealth(params[0], -5.0);
		Fell[params[0]] = 5;
	}
	useknock[playerid] = 30;
	return 1;
}

CMD:do(playerid, params[]) { new string[144];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(sscanf(params, "s[90]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /do [текст]");
	format(string, sizeof string, "* %s (( %s ))", params[0], GetName(playerid));
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	return 1;
}

CMD:try(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /try [текст]");
	new rannn = random(100);
	GetPlayerName(playerid, sendername, 24);
	if(rannn < 25) {
		format(string, sizeof string, "* %s попыталс€ %s (неудачно)", sendername, params);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	}
	else if(rannn >= 25)
	{
		format(string, sizeof string, "* %s попыталс€ %s (удачно)", sendername, params);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	}
	return 1;
}

CMD:b(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /b [текст]");
	if(Pl::Info[playerid][pMaskOn]) {
		format(string, sizeof string, "Ќеизвесный сказал: (( %s ))", params);
		ProxDetector(20.0, playerid, string,COLOR_FADE1,COLOR_FADE2,COLOR_FADE3,COLOR_FADE4,COLOR_FADE5);
	} else {
		GetPlayerName(playerid, sendername, 24);
		format(string, sizeof string, "%s сказал: (( %s ))", sendername, params);
		ProxDetector(20.0, playerid, string,COLOR_FADE1,COLOR_FADE2,COLOR_FADE3,COLOR_FADE4,COLOR_FADE5);
	}
	return 1;
}

CMD:close(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /c [текст]");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "%s сказал: %s", sendername, params[0]);
	if(!IsPlayerInAnyVehicle(playerid)) {
		AnimClear[playerid] = 4;
		ApplyAnimation(playerid,"PED","IDLE_chat",4.1,0,1,1,1,1);
	}
	ProxDetector(3.0, playerid, string,COLOR_FADE1,COLOR_FADE2,COLOR_FADE3,COLOR_FADE4,COLOR_FADE5);
	return 1;
}

CMD:shout(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /s [текст]");
	if(!Pl::Info[playerid][pMaskOn]) {
		GetPlayerName(playerid, sendername, 24);
		format(string, sizeof string, "%s крикнул: %s!", sendername, params[0]);
		ProxDetector(30.0, playerid, string,COLOR_WHITE,COLOR_WHITE,COLOR_WHITE,COLOR_FADE1,COLOR_FADE2);
		SetPlayerChatBubble(playerid, params[0], COLOR_GREEN, 50.0, 10000);
		if(!IsPlayerInAnyVehicle(playerid)) {
			AnimClear[playerid] = 4;
			ApplyAnimation(playerid,"ON_LOOKERS", "shout_01", 4.1, 1, 1, 1, 1, 1, 1);
		}
	} else {
		format(string, sizeof string, "Ќеизвестный крикнул: %s!", params[0]);
		ProxDetector(30.0, playerid, string,COLOR_WHITE,COLOR_WHITE,COLOR_WHITE,COLOR_FADE1,COLOR_FADE2);
		SetPlayerChatBubble(playerid, params[0], COLOR_GREEN, 50.0, 10000);
		if(!IsPlayerInAnyVehicle(playerid)) {
			AnimClear[playerid] = 4;
			ApplyAnimation(playerid,"ON_LOOKERS", "shout_01", 4.1, 1, 1, 1, 1, 1, 1);
		}
	}
	return 1;
}

CMD:o(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(Pl::Info[playerid][pTime] < 2) return Send(playerid, COLOR_GREY, "* ¬ы должны отыграть 2 часа на сервере, чтобы использовать эту команду!");
	if((noooc) && !Pl::isAdmin(playerid, 1)) return Send(playerid, COLOR_GRAD2, " OOC чат выключен.");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GRAD2, "»спользуйте: (/o)oc [ooc chat]");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "(( %s[ID: %d]: %s ))", sendername, playerid, params[0]);
	OOCOff(COLOR_OOC,string);
	printf("%s", string);
	return 1;
}

CMD:m(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(Pl::Info[playerid][pTime] < 2) return Send(playerid, COLOR_GREY, "* ¬ы должны отыграть 2 часа на сервере, чтобы использовать эту команду!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /m [текст]");
	if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, " вы должны находитс€ в транспортном средстве");
	new fracid = Pl::FracID(playerid);
	if(!IsACop(playerid) && fracid != 4) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	if(!Fc::GetInfo(GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "* ¬ы не в служебной машине!");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[%s %s %s:o< %s]", FracInfo[fracid][fTag], RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, params[0]);
	ProxDetector(60.0, playerid, string,COLOR_YELLOW,COLOR_YELLOW,COLOR_YELLOW,COLOR_YELLOW,COLOR_YELLOW);
	return 1;
}

CMD:r(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /r [текст]");
	if(!IsATeam(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не член команды!");
	new fracid = Pl::FracID(playerid);
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[R] %s %s: %s. **", RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, params[0]);
	sendToFamily(fracid, COLOR_RADIO, string);
	return 1;
}

CMD:duty(playerid, params[]) { new string[144];
	if(Pl::FracID(playerid) == TEAM_COP) {
		if(IsPlayerInRangeOfPoint(playerid,3,255.3,77.4,1003.6) || IsPlayerInRangeOfPoint(playerid,3,-1616.1294,681.1594,7.1875) || Pl::Info[playerid][pLocal] != 0) {
			if(!OnDuty[playerid]) {
				OnDuty[playerid] = true;
				Rac::GivePlayerWeapon(playerid, 3, 200);
				Rac::GivePlayerWeapon(playerid, 24, 70);
				format(string, sizeof string, "* ќфицер %s вз€л значок и оружие из своего шкафчика.", GetName(playerid));
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
			} else {
				OnDuty[playerid] = false;
				Rac::ResetPlayerWeapons(playerid);
				format(string, sizeof string, "* ќфицер %s ложит свой значок и оружие в свой шкафчик.", GetName(playerid));
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
			}
		}
		else return Send(playerid, COLOR_LIGHTRED2, "* ¬ы не в раздевалке!");

	} else if(Pl::FracID(playerid) == TEAM_MEDIC) {
		switch(OnDuty[playerid]) {
		case 0: {
				Medics ++;
				OnDuty[playerid] = true;
				Send(playerid, COLOR_LIGHTBLUE, "* ¬ы заступили на работу!");
			}
		case 1: {
				Medics --;
				OnDuty[playerid] = false;
				Send(playerid, COLOR_LIGHTBLUE, "* ¬ы теперь не на дежурстве!");
			}
		}
	}

	if(Pl::Info[playerid][pJob] == JOB_MECHANIC) {
		switch(OnDuty[playerid]) {
		case 0: {
				Mechanics ++;
				OnDuty[playerid] = true;
				Send(playerid, COLOR_LIGHTBLUE, "* ¬ы заступили на дежурство!");
			}
		case 1: {
				Mechanics --;
				OnDuty[playerid] = false;
				Send(playerid, COLOR_LIGHTBLUE, "* ¬ы теперь не на дежурстве!");
			}
		}
	}
	return 1;
}

CMD:ao(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD2, "* OOC канал отключен админом!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /ao [текст]");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[ADMIN] %s: %s " , sendername, params);
	OOCOff(COLOR_LIGHTGREEN,string);
	return 1;
}

CMD:ot(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid,COLOR_GREY,"* Ќедостаточно прав!");
	if(sscanf(params, "us[90]", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /ot [id] [ответ]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "*ќтвет от %s: %s", sendername, params[1]);
	Send(params[0], COLOR_YELLOW, string);
	format(string, sizeof string, "*ќтвет от %s > %s[%i]: %s", sendername, playername, params[0], params[1]);
	SendToAdmin(COLOR_LIGHTBLUE, string, 1, 2);
	return 1;
}

CMD:aduty(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::Info[playerid][pAdmin]) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	AdminDuty[playerid] = !AdminDuty[playerid];
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "(( [A] јдмин %s %s ))", sendername, (AdminDuty[playerid])?("заступил на дежурство! (/report)"):("ушел с дежурства."));
	SendToAll(COLOR_OOC,string);
	return 1;
}

CMD:spawncars(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	format(string, sizeof string, "* јдминистратор %s[%i] зареспавнил все автомобили.", GetName(playerid), playerid);
	RespawnUnoccupiedVehicles();
	SendToAll(COLOR_LIGHTRED, string);
	return 1;
}

CMD:restart(playerid, params[]) {
	if(Pl::Info[playerid][pAdmin] != 5 && !IsPlayerAdmin(playerid)) return 1;
	SendToAll(COLOR_LIGHTRED2,"* јдминистратор перезагрузил сервер!");
	GameModeInitExitFunc(0); return 1;
}

CMD:autorestart(playerid, params[]) {
	if(Pl::Info[playerid][pAdmin] != 5 && !IsPlayerAdmin(playerid)) return 1;
	SendToAll(COLOR_LIGHTRED2,"* јдминистратор перезагрузил сервер!");
	GameModeInitExitFunc(1); return 1;
}

CMD:updateprop(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pAdmin] != 5 && !IsPlayerAdmin(playerid)) return 1;
	new time=GetTickCount();
	UpdateProp();
	format(string, sizeof string, "* Property updated %i (ms)", GetTickCount()-time);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1 ;
}

CMD:d(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /d [текст]");
	if(Pl::Info[playerid][pTime] < 1) return Send(playerid, COLOR_GREY, "* ¬ы должны отыграть 3 часа на сервере, чтобы использовать эту команду!!");
	if(!IsATeam(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не член команды!");
	new fracid = Pl::FracID(playerid);
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[%s] %s %s: %s. **", FracInfo[fracid][fTag], RankInfo[fracid][Pl::Info[playerid][pRank]], sendername, params[0]);
	sendToTeam(COLOR_ALLDEPT, string, Teams);
	return 1;
}

CMD:su(playerid, params[]) { new string[144];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник.");
	if(sscanf(params, "uis[64]", params[0], params[1], params[2])) return Send(playerid, COLOR_GRAD2, "¬ведите: /su [id/Name] [кол-во звезд] [преступление]");
	if(!OnDuty[playerid] && Pl::FracID(playerid) == 1) return Send(playerid, COLOR_GREY, "* ¬ы не при исполнении служебных об€занностей!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(IsACop(params[0])) return Send(playerid, COLOR_GREY, "* ¬ы не можете подозревать ѕолицейского!");
	if(params[1] > 6) return Send(playerid,COLOR_GREY,"* Ѕольше 6 звезд кидать нельз€!");
	if(Pl::Info[params[0]][pWantedL] == 0) {
		Pl::Info[params[0]][pWantedL] += params[1];
		SetPlayerCriminal(params[0], playerid, params[2]);
		format(string,sizeof string,"* “еперь у этого игрока %i уровень розыска.", Pl::Info[params[0]][pWantedL]);
		Send(playerid, COLOR_LIGHTRED, string);
	}
	return 1;
}
CMD:mdc(playerid, params[]) { new string[144], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник.");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /mdc [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!OnDuty[playerid] && Pl::FracID(playerid) == 1) return Send(playerid, COLOR_GREY, "* ¬ы не при исполнении служебных об€занностей!");
	if(Pl::Info[params[0]][pWantedL] == 0) return Send(playerid, COLOR_GREY, "* »грок нет в базе данных!");
	new veh = GetPlayerVehicleID(playerid);
	if(IsACopCar(veh) || IsPlayerInRangeOfPoint(playerid, 5.0, 253.9280,69.6094,1003.6406)) {
		GetPlayerName(params[0], playername, 24);
		Send(playerid, COLOR_BLUE, "-=ћќЅ»Ћ№Ќџ…  ќћѕ№ё“≈– ƒјЌЌџ’=-");
		format(string, sizeof string, "* »м€: %s", playername);
		Send(playerid, COLOR_WHITE, string);
		format(string, sizeof string, "* ѕреступление: %s", Pl::Crime[params[0]][pAccusing]);
		Send(playerid, COLOR_GRAD2, string);
		format(string, sizeof string, "* ѕотерпевший: %s", Pl::Crime[params[0]][pVictim]);
		Send(playerid, COLOR_GRAD3, string);
		format(string, sizeof string, "* —ообщаемый: %s", Pl::Crime[params[0]][pAccused]);
		Send(playerid, COLOR_GRAD4, string);
		Send(playerid, COLOR_BLUE, "");
	} else {
		Send(playerid, COLOR_GREY, "* ¬ы не находитесь в ѕолицейском “ранспортном средстве или в ѕолицейском управлении.");
	}
	return 1;
}

CMD:open(playerid, params[]) {
	if(Pl::Info[playerid][pBizKey] != INVALID_BIZ_ID || Pl::isAdmin(playerid, 4))  {
		foreach(new i : Biznes) {
			if(IsPlayerInRangeOfPoint(playerid, 3.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2]) || IsPlayerInBiz(playerid, 5.0, BizzInfo[i][bID])) {
				if(Pl::Info[playerid][pBizKey] == BizzInfo[i][bID] || Pl::isAdmin(playerid, 4)) {
					switch(BizzInfo[i][bLocked]) {
					case 0: {
							BizzInfo[i][bLocked] = 1;
							GameTextForPlayer(playerid, "~w~Bussiness ~r~Closed", 5000, 4);
							PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
						}
					case 1: {
							BizzInfo[i][bLocked] = 0;
							GameTextForPlayer(playerid, "~w~Bussiness ~g~Open", 5000, 4);
							PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
						}
					}
				}
				else {
					GameTextForPlayer(playerid, "~r~You Dont Have A Key", 5000, 4);
				}
				return 1;
			}
		}
	}

	if(Pl::Info[playerid][pHouseKey] != INVALID_HOUSE_ID || Pl::isAdmin(playerid, 4)) {
		foreach(new i : Houses) {
			if(IsPlayerInRangeOfPoint(playerid, 3.0, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2]) || IsPlayerInHouse(playerid, 2.0, i)) {
				if(Pl::Info[playerid][pHouseKey] == i || Pl::isAdmin(playerid, 4)) {
					switch(HouseInfo[i][hLock]) {
					case 0: {
							HouseInfo[i][hLock] = 1;
							GameTextForPlayer(playerid, "~w~Door ~r~Locked", 5000, 4);
							PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
						}

					case 1: {
							HouseInfo[i][hLock] = 0;
							GameTextForPlayer(playerid, "~w~Door ~g~Unlocked", 5000, 4);
							PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
						}
					}
				}
				else {
					GameTextForPlayer(playerid, "~r~You Dont Have A Key", 5000, 4);
				}
				return 1;
			}
		}
	}
	return 1;
}

CMD:pm(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас мол€чанка!");
	if(Pl::Info[playerid][pLevel] < 2) return Send(playerid, COLOR_GREY, "* „тобы писать Ћ— вам требуетс€ 2 level!");
	if(sscanf(params, "us[90]", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /w [id/Name] [ответ]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* Ќельз€ отправить сообщение себе!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(HidePM[params[0]]) return Send(playerid, COLOR_RED, "* ѕэйджер отключен!");
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "PM от %s(ID:%i): %s", sendername, playerid, params[1]);
	Send(params[0], COLOR_YELLOW, string);
	format(string, sizeof string, "PM к %s(ID:%i): %s", playername, params[0], params[1]);
	Send(playerid, COLOR_YELLOW, string);
	PlayerPlaySound(playerid, 1084, 0.0, 0.0, 0.0);
	PlayerPlaySound(params[0], 1084, 0.0, 0.0, 0.0);
	printf("[PM] от %s к %s: %s", sendername, playername, params[1]);
	return 1;
}

CMD:drink(playerid, params[]) {
	if(!IsAtBar(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не в баре!");
	if(Pl::Drunk[playerid] > 10) return Send(playerid, COLOR_GREY, "* Ѕармен отказываетс€ вам наливать!");
	Rac::TogglePlayerControllable(playerid,0); ShowMenuForPlayer(BarMenu, playerid);
	return 1;
}

CMD:rentroom(playerid, params[]) {
	if(!Pl::Info[playerid][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет паспорта!");
	if(IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) {
		Send(playerid, COLOR_WHITE, "* ” ¬ас уже есть дом. —начало продайте его: /sellhouse - введите дл€ продажи!");
	} else {
		foreach(new i : Houses) {
			if(IsPlayerInRangeOfPoint(playerid, 2.0, HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2])) {
				if(HouseInfo[i][hOwned] == 1 && HouseInfo[i][hRent][0] == 1) {
					if(Rac::GetPlayerMoney(playerid) < HouseInfo[i][hRent][1]) return SendClientMessage(playerid, COLOR_WHITE, "* ” ¬ас не хватает денег!");
					Pl::Info[playerid][pHouseKey] = i;
					Rac::GivePlayerMoney(playerid,-HouseInfo[i][hRent][1]);
					HouseInfo[i][hSafe][0] += HouseInfo[i][hRent][0];
					EnterHouse(playerid, i);
					GameTextForPlayer(playerid, "~g~] ~w~Welcome Home ~g~] ~w~~n~You can exit at any time by moving to this door and typing ~g~/exit", 10000, 3);
					Send(playerid, COLOR_WHITE, "* ѕишите /help там по€вились новые команды!");
					PlayerPlayMusic(playerid);
					Pl::Update(playerid);
					Pl::SetSpawnInfo(playerid);

					return 1;
				}
			}
		}
	}
	return 1;
}

CMD:unrent(playerid, params[]) {
	new hidx = Pl::Info[playerid][pHouseKey];
	if(!IsValidHouse(hidx)) return Send(playerid, COLOR_GREY, "* ¬ы не арендуете дом!");
	if(IsPlayerHouseOwner(playerid, hidx)) return Send(playerid, COLOR_WHITE, " ¬ам принадлежит этот дом!");
	Pl::Info[playerid][pLocal] = 0;
	Pl::Info[playerid][pHouseKey] = INVALID_HOUSE_ID;
	if(Pl::Info[playerid][pLocal] == (OFFSET_HOUSE + hidx)) {
		ExitHouse(playerid, hidx);
	}
	Pl::SetSpawnInfo(playerid);
	Send(playerid, COLOR_WHITE, "* “еперь вы Ѕомж!");
	return 1;
}

CMD:buyhouse(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::Info[playerid][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет паспорта!");
	if(IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) {
		Send(playerid, COLOR_GREY, "* ” ¬ас уже есть ƒом. —начало продайте его: /sellhouse - ввидите дл€ продажи!");
	} else {
		for(new h = 1; h < sizeof(HouseInfo); h++) {
			if(!HouseInfo[h][hOwned] && IsPlayerInRangeOfPoint(playerid, 2.0, HouseInfo[h][hEnter][0], HouseInfo[h][hEnter][1], HouseInfo[h][hEnter][2])) {
				if(HouseInfo[h][hPrice] > Rac::GetPlayerMoney(playerid)) {
					Send(playerid, COLOR_LIGHTRED, "* ” ¬ас нет столько денег!");
				} else {
					if(Pl::Info[playerid][pLevel] < HouseInfo[h][hLevel]) {
						format(string, sizeof string, "* ¬ам нужно проживать {0080FF}%d {ffffff}лет в штате что-бы купить этот дом!", HouseInfo[h][hLevel]);
						Send(playerid, COLOR_WHITE, string);
					} else {
						new bidx = GetIndexFromBizID(Bizz_EstateAgency);
						HouseInfo[h][hOwned] = 1;
						Pl::Info[playerid][pHouseKey] = h;
						GetPlayerName(playerid, sendername, 24);
						strmid(HouseInfo[h][hOwner], sendername, 0, 24, 24);
						UpdateHousePickups(h);
						Rac::GivePlayerMoney(playerid,-HouseInfo[h][hPrice]);
						EnterHouse(playerid, h);
						GameTextForPlayer(playerid, "~g~] ~w~Welcome Home ~g~]~w~~n~You can exit at any time by moving to this door and typing ~g~/exit", 10000, 3);
						Send(playerid, COLOR_LIGHTBLUE, "* ¬озможности домовладельца можно посмотреть в /help!");
						DateProp(playerid, 0);
						Pl::Update(playerid);
						Pl::SetSpawnInfo(playerid);
						PlayerPlayMusic(playerid);
						GiveBizzProfit(bidx, PERCENT(HouseInfo[h][hPrice], 10));
					}
				}

				return 1;
			}
		}
	}
	return 1;
}

CMD:changehouse(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(sscanf(params, "uI(0)", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /changehouse [ид/им€] [доплата вам]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(GetPVarInt(playerid, "HouseBuyer") != INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ы уже придложили обмен домами!");
	if(!IsPlayerInBiz(playerid, 60.0, Bizz_EstateAgency)) return Send(playerid, COLOR_GREY, "* ¬ы должны находитс€ в агенстве недвижимости!");
	if(!(0 <= params[1] <= (2000000 * 100))) return Send(playerid, COLOR_GREY, "* —умма должна быть от $0 до $200kk");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около вас!");
	SetPVarInt(playerid, "HouseBuyer", params[0]);
	SetPVarInt(params[0], "HouseSeller", playerid);
	SetPVarInt(params[0], "HouseType", 1);
	SetPVarInt(params[0], "HousePrice", params[1]);
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* %s предлагает ¬ам убмен€тс€ домами, с доплатой $%i (пишите /accept house чтобы согласитс€)", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы предложили обмен€тс€ домами %s, с доплатой $%i (пишите /cancel house чтобы отменить)", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:sellhouse(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /sellhouse [ид/им€] [сумма]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(!IsPlayerInBiz(playerid, 60.0, Bizz_EstateAgency)) return Send(playerid, COLOR_GREY, "* ¬ы должны находитс€ в агенстве недвижимости!");
	if(!(1 <= params[1] <= (2000000 * 100))) return Send(playerid, COLOR_GREY, "* —умма должна быть от $1 до $200kk");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около вас!");
	if(GetPVarInt(playerid, "HouseBuyer") != INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ы уже придложили покупку дома!");
	SetPVarInt(playerid, "HouseBuyer", params[0]);
	SetPVarInt(params[0], "HouseSeller", playerid);
	SetPVarInt(params[0], "HouseType", 0);
	SetPVarInt(params[0], "HousePrice", params[1]);
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* %s предлагает ¬ам купить дом, за $%i (пишите /accept house чтобы согласитс€)", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы предложили купить дом %s, за $%i (пишите /cancel house чтобы отменить)", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}
/*
	new house = Pl::Info[playerid][pHouseKey];
	GetPlayerName(playerid, sendername, 24);
	if(!IsValidHouse(house)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	if(strcmp(sendername, HouseInfo[house][hOwner], true) == 0) {
		if(HouseInfo[house][hPrice] != 0) {
			new proc = PERCENT(HouseInfo[house][hPrice], 5);
			new sellprice = HouseInfo[house][hPrice] - proc;
			BizzInfo[GetIndexFromBizID(48)][bProfit] += proc;
			Rac::GivePlayerMoney(playerid, sellprice);
			format(string, sizeof string, "~w~Congratulations~n~ You have sold your property for ~n~~g~$%d", sellprice);
			GameTextForPlayer(playerid, string, 10000, 3);
			format(string, sizeof string, "[Debug] %s продал дом. Price: $%i; SellPrice: $%i; Safe: $%i",
			sendername, HouseInfo[house][hPrice], sellprice, HouseInfo[house][hSafe][0]);
			SendLog(LOG_HOUSE, string);
		}
		if(Pl::Info[playerid][pLocal] == OFFSET_HOUSE + house) {
			ExitHouse(playerid, house)
		}
		ClearHouse(house);
		UpdateHouse(house);
		Pl::Update(playerid);
		Pl::Info[playerid][pHouseKey] = INVALID_HOUSE_ID;
		PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	} else {
		Send(playerid, COLOR_WHITE, "* ¬ы не владелец дома!");
	}
	return 1;
}*/


CMD:buybiz(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::Info[playerid][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет паспорта!");
	new pbiz = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	GetPlayerName(playerid, sendername, 24);
	if(IsPlayerBizOwner(playerid, pbiz) || IsPlayerBizExtortion(playerid, pbiz)) {
		Send(playerid, COLOR_GREY, "* ” вас уже есть Ѕизнес. —начало продайте его: /sellbiz - ввидите дл€ продажи!");
	} else {
		foreach(new i : Biznes) {
			if(!BizzInfo[i][bOwned] && IsPlayerInRangeOfPoint(playerid, 2.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2])) {
				if(Pl::Info[playerid][pLevel] < BizzInfo[i][bLevel]) {
					format(string, sizeof string, "* ¬ы должны быть уровнем %d, чтобы купить это!",BizzInfo[i][bLevel]);
					Send(playerid, COLOR_GRAD5, string);
				} else {
					if(Rac::GetPlayerMoney(playerid) >= BizzInfo[i][bPrice]) {
						BizzInfo[i][bOwned] = 1;
						Pl::Info[playerid][pBizKey] = BizzInfo[i][bID];
						strmid(BizzInfo[i][bOwner], sendername, 0, 24, 24);
						Rac::GivePlayerMoney(playerid,-BizzInfo[i][bPrice]);
						BizzInfo[i][bSafe] = 100000;
						PlayerPlayMusic(playerid);
						if(BizzInfo[i][bInterior] == -1) {
							Send(playerid, COLOR_LIGHTBLUE, "* ѕоздравл€ю вас с покупкой");
							Send(playerid, COLOR_LIGHTBLUE, "* ѕишите /help чтобы рассмотреть новую деловую секцию помощи.");
						} else {
							EnterBiz(playerid, i);
							GameTextForPlayer(playerid, "~w~Welcome~n~You can exit at any time by moving to this door and typing /exit", 5000, 3);
							Send(playerid, COLOR_LIGHTBLUE, "* ѕоздравл€ю вас с покупкой");
							Send(playerid, COLOR_LIGHTBLUE, "* ѕишите /help чтобы рассмотреть новую деловую секцию помощи.");
						}
						UpdateBizzPickups(i);
						Pl::Update(playerid);
						Gz::ShowForAll(BizzInfo[i][bZone], GetFracColor(BizzInfo[i][bFrac]));
					} else {
						Send(playerid, COLOR_WHITE, "* ” ¬ас нет наличных денег дл€ этого!");
					}
				}
				return 1;
			}
		}
	}
	return 1;
}

CMD:sellbiz(playerid, params[]) { new string[144];
	new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
	if(!IsPlayerBizOwner(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
	ClearBiz(bidx);
	Pl::Info[playerid][pBizKey] = INVALID_BIZ_ID;
	new sellprice = BizzInfo[bidx][bPrice] - PERCENT(BizzInfo[bidx][bPrice], 5);
	if(sellprice > 0) Rac::GivePlayerMoney(playerid, sellprice);
	format(string, sizeof string, "~w~Congratulations~n~ You have sold your property for ~n~~g~$%d", sellprice);
	GameTextForPlayer(playerid, string, 10000, 3);
	format(string, sizeof string, "[Ќовости недвижимости] Ѕизнес %s был выставлен на продажу! ÷ена: $%i", BizzInfo[bidx][bDescription], BizzInfo[bidx][bPrice]);
	SendToAll(COLOR_NEWS, string);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	Pl::Update(playerid);

	return 1;
}

CMD:asellbiz(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GRAD1, "¬ведите: /asellbiz [bizid]");
	new bidx = GetIndexFromBizID(params[0]);
	ClearBiz(bidx);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	format(string, sizeof string, "~w~You have sold the ~g~Business");
	GameTextForPlayer(playerid, string, 10000, 3);
	format(string, sizeof string, "[Ќовости недвижимости] Ѕизнес %s был выставлен на продажу! ÷ена: $%i", BizzInfo[bidx][bDescription], BizzInfo[bidx][bPrice]);
	SendToAll(COLOR_NEWS, string);
	return 1;
}

CMD:asellhouse(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /asellhouse");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID дома!");
	ClearHouse(params[0]);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	format(string, sizeof string, "[Ќовости недвижимости] Ѕыл выставлен дом на продажу! ÷ена: $%d", HouseInfo[params[0]][hPrice]);
	SendToAll(COLOR_NEWS, string);
	format(string, sizeof string, "~w~You have sold this ~g~property", HouseInfo[params[0]][hPrice]);
	GameTextForPlayer(playerid, string, 10000, 3);
	UpdateHouse(params[0]);
	return 1;
}

CMD:asellhouseall(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	foreach(new i : Houses) {
		ClearHouse(i);
		UpdateHouse(i);
	}
	SendToAll(COLOR_NEWS, "* [RP]GreatWorld::.. [RUS]: ¬се дома штата были выставлены на продажу!");
	return 1;
}

CMD:asellbizall(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return 1;
	foreach(new i : Biznes) {
		ClearBiz(i);
		UpdateBizz(i);
	}
	SendToAll(COLOR_NEWS, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬се бизнесы штата были выставлены на продажу!");
	return 1;
}

CMD:call(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /call [номер телефона]");
	if(Pl::Info[playerid][pNumber] == 0) return Send(playerid, COLOR_GRAD2, "* ” ¬ас нет телефона!");
	if(params[0] == Pl::Info[playerid][pNumber]) return Send(playerid, COLOR_GRAD2, "* ¬ы не можете позвонить себе");
	if(Mobile[playerid] != INVALID_PLAYER_ID) return Send(playerid, COLOR_GRAD2, "  ¬ы готовы позвонить...");
	foreach(new i: Player) {
		if(Pl::isLogged(i)) {
			if(Pl::Info[i][pNumber] == params[0]) {
				if(!PhoneOnline[i]) return Send(playerid, COLOR_GREY, "* “елефон выключен!");
				if(Mobile[i] != INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* Ћини€ зан€та!");

				Mobile[playerid] = i;
				CellTime[playerid] = 1;

				getname(playerid -> sendername, i -> playername);
				format(string, sizeof string, "* %s звонит по телефону", sendername);
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
				SetPlayerSpecialAction(playerid,SPECIAL_ACTION_USECELLPHONE);
				format(string, sizeof string, " ¬аш мобильник звонит ¬ведите (/p) звонит %s", sendername);
				Send(i, COLOR_YELLOW, string);
				format(string, sizeof string, "* %s's телефон начинает звонить.", playername);
				ProxDetector(30.0, i, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
				Send(playerid, COLOR_WHITE, "ѕодсказка: »спользуйте “ дл€ того чтобы говорить, введите /h чтобы положить трубку");

				return 1;
			}
		}
	}
	return 1;
}

CMD:anim(playerid, params[]) {
	Send(playerid, COLOR_GRAD2, "/piss /sitdown /sitdown2 /stay /upplay /droch /konch");
	return 1;
}

CMD:droch(playerid, params[]) {
	ApplyAnimation(playerid, "PAULNMAC", "wank_loop", 10000.0, 9999, 9999, 9999, 9999, 9999);
	return 1;
}

CMD:konch(playerid, params[]) {
	ApplyAnimation(playerid, "PAULNMAC", "wank_out", 10000.0, 9999, 9999, 9999, 9999, 9999);
	return 1;
}

CMD:piss(playerid, params[]) {
	if (Pl::Info[playerid][pJailed]) return Send(playerid, COLOR_RED, "—ƒ≈—№ Ќ≈Ћ№«я ——ј“№ » ѕ≈“”Ў»“ь—я!");
	SetPlayerSpecialAction(playerid,68);
	return 1;
}

CMD:sitdown(playerid, params[]) {
	//ApplyAnimation(playerid,"FOOD","FF_Dam_Bkw",4.1,0,1,1,1,1);
	ApplyAnimation(playerid,"PED","SEAT_down",4.1,0,0,0,1,1);
	return 1;
}

CMD:sitdown2(playerid, params[]) {
	ApplyAnimation(playerid,"INT_HOUSE","LOU_In",4.1,0,0,0,1,1);
	return 1;
}

CMD:upplay(playerid, params[]) {
	ApplyAnimation(playerid,"INT_HOUSE","LOU_Out",4.1,0,1,1,1,1);
	return 1;
}

CMD:stay(playerid, params[]) {
	ApplyAnimation(playerid,"DEALER","DEALER_IDLE",4.1,0,1,1,1,1);
	return 1;
}

CMD:sms(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(PlayerTied[playerid]) return Send(playerid,COLOR_GREY,"¬ы св€заны");
	if(Pl::Info[playerid][pNumber] == 0) return Send(playerid, COLOR_GRAD2, "* ” ¬ас нет телефона...");
	if(Pl::Info[playerid][pTime] < 1) return Send(playerid, COLOR_GREY, "* ¬ы должны отыграть 1 час на сервере, чтобы использовать эту команду!");
	if(sscanf(params, "ds[90]", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /sms [phonenumber] [text]");
	if(params[0] == 0) return Send(playerid, COLOR_GREY, "* Ќеверный номер!");
	foreach(new i: Player) {
		if(Pl::isLogged(i)) {
			if(Pl::Info[i][pNumber] == params[0]) {
				if(!PhoneOnline[i]) return Send(playerid, COLOR_GREY, "* “елефон игрока отключен!");
				new bidx = GetIndexFromBizID(Bizz_TelephoneCompany);
				BizzInfo[bidx][bProds]--;
				GiveBizzProfit(bidx, BizzInfo[bidx][bEnterCost]);
				Rac::GivePlayerMoney(playerid, -BizzInfo[bidx][bEnterCost]);
				format(string, sizeof string, "~r~$-%i", BizzInfo[bidx][bEnterCost]);
				GameTextForPlayer(playerid, string, 5000, 1);
				PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);

				GetPlayerName(playerid, sendername, 24);
				format(string, sizeof string, "* %s вынимает мобилу.", sendername);
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
				format(string, sizeof string, "*SMS: %s. ќтправитель: %s (%d)", params[1], sendername, Pl::Info[playerid][pNumber]);
				Send(i, COLOR_YELLOW, string);
				Send(playerid, COLOR_YELLOW, "* —ћ—ка отправленна");
				return 1;
			}
		}
	}
	return 1;
}

CMD:p(playerid, params[]) { new string[144], sendername[24];
	if(Mobile[playerid] != 0xFFFF) return Send(playerid, COLOR_GREY, "  ¬ы уже разговариваите по телефону!");
	foreach(new i: Player)
	{
		if(Pl::isLogged(i))
		{
			if(Mobile[i] == playerid)
			{
				Mobile[playerid] = i;
				Send(i, COLOR_GREY, "* ќн подн€л трубку.");
				GetPlayerName(playerid, sendername, 24);
				format(string, sizeof string, "* %s отвечает на звонок.", sendername);
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
				SetPlayerSpecialAction(playerid,SPECIAL_ACTION_USECELLPHONE);
				return 1;
			}
		}
	}
	return 1;
}

CMD:h(playerid, params[]) {
	new caller = Mobile[playerid];
	if(caller != INVALID_PLAYER_ID)
	{
		if( Pl::isLogged(caller) )
		{
			CellTime[caller] = 0;
			CellTime[playerid] = 0;
			Mobile[caller] = INVALID_PLAYER_ID;
			Mobile[playerid] = INVALID_PLAYER_ID;
			Send(caller, COLOR_GRAD2, "јбонент положил трубку.");
			SetPlayerSpecialAction(caller,SPECIAL_ACTION_STOPUSECELLPHONE);
			Send(playerid, COLOR_GRAD2, "¬ы положили трубку.");
			SetPlayerSpecialAction(playerid,SPECIAL_ACTION_STOPUSECELLPHONE);
			return 1;
		}
	}
	Send(playerid, COLOR_GRAD2, "¬аш телефон в кармане.");

	return 1;
}

CMD:time(playerid, params[]) { new string[144];
	new h, m, s; gettime(h, m, s);
	if(Pl::Info[playerid][pJailTime] > 0) {
		format(string, sizeof string, "~w~time: ~g~%02i:%02i~n~~w~Jail Time Left: ~g~%i sec", h, m, Pl::Info[playerid][pJailTime]);
	} else {
		format(string, sizeof string, "~w~Time: ~g~%02i:%02i", h, m);
	}
	GameTextForPlayer(playerid, string, 3500, 1);
	ApplyAnimation(playerid,"COP_AMBIENT","coplook_watch",4.1,0,0,0,0,0);
	return 1;
}

CMD:house(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /house [housenumber]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "Invalid house id!");
	EnterHouse(playerid, params[0]);
	GameTextForPlayer(playerid, "~w~Teleporting", 5000, 1);
	Pl::Info[playerid][pLocal] = OFFSET_HOUSE + params[0];
	return 1;
}

CMD:houseo(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "»спользуйте: /houseo [housenumber]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "Invalid house id!");
	ExitHouse(playerid, params[0]);
	GameTextForPlayer(playerid, "~w~Teleporting", 5000, 1);
	return 1;
}

CMD:biz(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /biz [biznumber]");
	new bidx = GetIndexFromBizID(params[0]);
	if(!IsValidBiz(bidx)) return Send(playerid, COLOR_GREY, "* Ќет такого бизнеса!");
	if(BizzInfo[bidx][bInterior] == -1) {
		ExitBiz(playerid, bidx);
	} else {
		EnterBiz(playerid, bidx);
	}
	GameTextForPlayer(playerid, "~w~Teleporting", 5000, 1);
	return 1;
}

CMD:edit(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	ShowDialog(playerid, D_EDIT, DIALOG_STYLE_INPUT, "EDIT", "dialog/edit.txt", "OK", "ќ“ћ≈Ќј");
	return 1;
}

CMD:exit(playerid, params[]) {
	if(Pl::CarInt[playerid] != INVALID_VEHICLE_ID) {
		GetVehiclePos(Pl::CarInt[playerid], vehx, vehy, vehz);
		Rac::SetPlayerInterior(playerid, 0);
		Rac::SetPlayerVirtualWorld(playerid, 0);
		Rac::SetPlayerPos(playerid, vehx+5.0, vehy, vehz);
		Pl::CarInt[playerid] = INVALID_VEHICLE_ID;
	} else {
		new i = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
		if(IsValidHouse(i)) {
			if(IsPlayerInRangeOfPoint(playerid, 50.0, HouseInfo[i][hExit][0], HouseInfo[i][hExit][1], HouseInfo[i][hExit][2])
					&& HouseInfo[i][hVirtual] == GetPlayerVirtualWorld(playerid)) {
				SetPVarInt(playerid, "PlayerHouse", i);
				return SPD(playerid, D_EX_HOUSE, 0, "EXIT", "¬ы хотите выйти?", "ƒј", "Ќ≈“");
			}
		}
	}
	return 1;
}

CMD:hmenu(playerid, params[]) {
	if(Pl::Info[playerid][pHouseKey] == INVALID_HOUSE_ID) {
		GameTextForPlayer(playerid, "~w~You are homeless", 5000, 1);
	} else {
		DestroyDynamicCP(checkpoints[playerid]);
		checkpoints[playerid] = CreateDynamicCP(HouseInfo[Pl::Info[playerid][pHouseKey]][hEnter][0], HouseInfo[Pl::Info[playerid][pHouseKey]][hEnter][1], HouseInfo[Pl::Info[playerid][pHouseKey]][hEnter][2], 4.0,-1,-1,playerid,99999.9);
		GameTextForPlayer(playerid, "~w~Waypoint set ~r~Home", 5000, 1);
		Pl::CheckpointStatus[playerid] = CHECKPOINT_HOME;
	}
	return 1;
}

CMD:bizinfo(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /bizinfo [bizid]");
	if(!IsValidBiz(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID бизнеса!");
	PrintBizInfo(playerid, params[0]);
	return 1;
}

CMD:houseinfo(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /houseinfo [houseid]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID дома!");
	PrintHouseInfo(playerid, params[0], 1);
	return 1;
}


CMD:abizname(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "is[24]", params[0], temp)) return Send(playerid, COLOR_GREY, "¬ведите: /bizname [biz] [name]");
	new i = GetIndexFromBizID(params[0]);
	strmid(BizzInfo[i][bDescription], temp, 0, strlen(temp), 24);
	format(string, sizeof string, "Ќазвани€ бизнеса номер %d изменино на [%s]", BizzInfo[i][bID], BizzInfo[i][bDescription]);
	Send(playerid, COLOR_WHITE, string)
	;
	return 1;
}

CMD:heal(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 4) return Send(playerid, COLOR_GREY, "* ¬ы не медик!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /heal [playerid] [price]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете излечить себ€!");
	if(params[1] < 1 || params[1] > 1000) return Send(playerid, COLOR_GREY, "* »сцеление цены не ниже $1 и не выше $1000!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	new veh = GetPlayerVehicleID(playerid);
	if(IsPlayerInVehicle(params[0], veh) && IsAnAmbulance(veh)) {
		if(Rac::GetPlayerHealth(params[0]) >= 100.0) return Send(playerid, COLOR_GREY,"* “от человек полностью излечен!");
		if(Rac::GetPlayerMoney(params[0]) < params[1]) return Send(playerid, COLOR_GREY,"* “от человек не сможет оплатить лечение!");
		Rac::SetPlayerHealth(params[0], 100.0);
		Rac::GivePlayerMoney(playerid, params[1]);
		Rac::GivePlayerMoney(params[0], -params[1]);
		getname(playerid->sendername,params[0]->playername);
		format(string, sizeof string, "* ¬ы вылечили %s за %i$", playername, params[1]);
		Send(playerid, COLOR_LIGHTGREEN,string);
		format(string, sizeof string, "* ћедик %s выличил вас за %i$", sendername, params[1]);
		Send(params[0], COLOR_LIGHTGREEN,string);
		PlayerPlaySound(playerid, 1150, 0.0, 0.0, 0.0);
		PlayerPlaySound(params[0], 1150, 0.0, 0.0, 0.0);
		if(STDPlayer[params[0]] > 0) {
			STDPlayer[params[0]] = 0;
		}
	}
	else Send(playerid, COLOR_GRAD1, "* ќдин из ¬ас не находитс€ в —анитарной машине / ¬ертолет !");

	return 1;
}

CMD:mole(playerid, params[]) { new string[144];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "s[90]", params[0])) return Send(playerid, COLOR_GRAD1, "¬ведите: /mole [текст]");
	format(string, sizeof string, "*SMS: %s. ќтправитель: "#__SERVER_PREFIX""#__SERVER_NAME_LC"", params[0]);
	SendToAll(COLOR_YELLOW, string);
	return 1;
}

CMD:id(playerid, params[]) { new string[144], playername[24];
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /id [id/PartOfName]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подключекн!");
	GetPlayerName(params[0], playername, 24);
	switch(AFKInfo[params[0]][afk_State]) {
	case 0 : format(string, sizeof string, "ID: (%i) %s", params[0], playername);
	case 1 : format(string, sizeof string, "ID: (%i) %s {33CCFF}<PAUSE: %i sec.>", params[0], playername, AFKInfo[params[0]][afk_Time][0]);
	}
	Send(playerid, COLOR_GRAD1, string);
	return 1;
}

CMD:tv(playerid, params[]) { new string[144], playername[24];
	new hkey = Pl::Info[playerid][pHouseKey];
	if(sscanf(params, "s[24]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /tv [id] (off - перестать смотреть тв)");
	if(strcmp("off", params[0], true) == 0) {
		if(WatchingTV[playerid]) {
			WatchingTV[playerid] = false;
			Pl::SpecInfo[playerid][pSpecID] = 999;
			Pt::Hide(playerid, Pt::Spec[playerid]);
			GameTextForPlayer(playerid, "~w~                TV~n~~r~                Off", 5000, 6);
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
		} else {
			Send(playerid, COLOR_GREY, "* ¬ы не смотрите TV.");
		}
	} else if(Pl::isAdmin(playerid, 1) || (Pl::Info[playerid][pLocal] == (OFFSET_HOUSE + hkey) && IsValidHouse(hkey))) {
		new specid = ReturnUser(params[0]);
		if(specid == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете следить сами за собой!");
		if(!Pl::isLogged(specid)) return Send(playerid, COLOR_GREY, "* »грок не авторизирован!");
		if(WatchingTV[specid]) return Send(playerid, COLOR_GREY, "* Ётот игрок сам в “¬!");
		if(!Pl::isAdmin(playerid, 1) && HouseInfo[hkey][hTv] != 1) return GameTextForPlayer(playerid, "~r~This upgrade isn't installed", 5000, 1);
		if(Pl::Info[specid][pAdmin] > 0 && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* Ётот канал не работает!");
		GetPlayerName(specid, playername, 24);
		if(!Pl::isAdmin(playerid, MODER1LVL)) Rac::TogglePlayerControllable(playerid, 0);
		Pl::SpecInfo[playerid][pSpecID] = specid;
		format(string, sizeof string, "[TV]  анал: (%i) %s", specid, playername);
		Send(playerid, COLOR_GREEN, string);
		SetPlayerColor(playerid, COLOR_ALPHA);

		Pl::SpecInfo[specid][pSpecVw]		[0] = GetPlayerVirtualWorld(specid);
		Pl::SpecInfo[specid][pSpecInt]		[0] = GetPlayerInterior(specid);
		Pl::SpecInfo[specid][pSpecState]	[0] = GetPlayerState(specid);

		Rac::TogglePlayerSpectating(playerid, true);
		switch(Pl::SpecInfo[specid][pSpecState][0]) {
		case 2, 3 : {
				PlayerSpectateVehicle(playerid, GetPlayerVehicleID(specid));
			}
			default : {
				PlayerSpectatePlayer(playerid, specid);
			}
		}
		Pt::Show(playerid, Pt::Spec[playerid]);
		Rac::SetPlayerInterior(playerid, Pl::SpecInfo[specid][pSpecInt][0]);
		Rac::SetPlayerVirtualWorld(playerid, Pl::SpecInfo[specid][pSpecVw][0]);
		WatchingTV[playerid] = true;
	}
	else Send(playerid, COLOR_GREEN, "* ¬ы не дома.");

	return 1;
}

CMD:a(playerid, params[]) { new string[144];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /(a)dmin [чат]");
	GetPlayerName(playerid, plname, 24);
	format(string, sizeof string, "*%s %s: %s", GetAdminRank(Pl::Info[playerid][pAdmin]), plname, params);
	SendToAdmin(COLOR_ORANGE, string, 1);
	return 1;
}

CMD:cnn(playerid, params[]) { new string[144];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "iis[90]", params[0], params[1], params[3])) return Send(playerid, COLOR_GRAD1, "¬ведите: /cnn [type] [time] [text]");
	if(params[0] < 0 || params[0] == 2 || params[0] > 6) return Send(playerid, COLOR_GREY, "* ¬ы не можите использовать этот тип текста!");
	format(string, sizeof string, "~w~%s", params[3]);
	GameTextForPlayer(playerid, string, params[1], params[0]);
	return 1;
}

CMD:prison(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "us[64]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /prison [id/Name] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed] == 2) return Send(playerid, COLOR_GREY, "* Ётот игрок уже в присоне!");
	if(Pl::Info[playerid][pAdmin] < Pl::Info[params[0]][pAdmin]) return Send(playerid, COLOR_LIGHTRED, "* ¬ы не можите посадить администратора в ƒемоган!");
	Jailed(params[0], 2800, 2);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /prison к игроку %s[%i]. ѕричина: %s", sendername, playername, params[0], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* ¬ы были размещены в ‘орт ƒеморган администратаром %s. ѕричина: %s", sendername, params[1]);
	Send(params[0], COLOR_LIGHTRED, string);
	GameTextForPlayer(params[0], "~w~Welcome to ~n~~r~Fort DeMorgan", 5000, 3);
	return 1;
}

CMD:unprison(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /unprison [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed] != 2) return Send(playerid, COLOR_GREY, "* Ётот игрок не в присоне!");
	if(playerid == params[0] && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* ¬ы не можите оправдатьс€!");
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /unprison к игроку %s[%i].", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	UnJail(params[0], 2);
	Send(params[0],COLOR_RED,"* ¬ы были выпущены из ƒеморгана!");
	return 1;
}

CMD:jail(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "uds[36]", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "¬ведите: /jail [id/Name] [time] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed] >= 1) return Send(playerid, COLOR_GREY, "* Ётот игрок уже находитс€ в тюрьме!");
	if(params[1] < 60 || params[1] > 3600) return Send(playerid, COLOR_GREY, "* —рок ареста может быть от 1 минуты и до 1 часа!");
	if(Pl::Info[playerid][pAdmin] < Pl::Info[params[0]][pAdmin]) return Send(playerid, COLOR_LIGHTRED, "* ¬ы не можете посадить в тюрьму администратора!");
	Jailed(params[0], params[1], 3);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "<< јдмин %s арестовал нарушител€ %s. ѕричина: %s >>", sendername, playername, params[2]);
	OOCNews(COLOR_LIGHTRED, string);
	format(string, sizeof string, "* ¬ы были заключены в тюрьму на %d секунд.", params[1]);
	Send(params[0], COLOR_LIGHTRED, string);
	return 1;
}

CMD:unjail(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /unjail [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(playerid == params[0] && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* ¬ы не можите оправдатьс€!");
	if(Pl::Info[params[0]][pJailed] != 1) return Send(playerid, COLOR_GREY, "* Ётот игрок не в тюрьме!");
	UnJail(params[0], 1);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /unjail к игроку %s[%i].", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s выпустил вас из тюрьмы!", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:setstat(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	ShowDialog(playerid, D_SETSTAT, DIALOG_STYLE_INPUT, "SETSTAT", "dialog/setstat.txt", "¬вод", "ќтмена");
	return 1;
}

CMD:fs(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /fs [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	SPD(params[0], D_FIGHTSTYLE, DIALOG_STYLE_LIST, "¬ыберите стиль бо€","Ѕќ —\n ”Ќ√-‘”\n—јћЅќ\n”Ћ»„Ќџ…","¬ыбрать","ќтмена");
	return 1;
}

CMD:ainvite(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /ainvite [id] [fracid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::FracID(params[0]) != 0) return Send(playerid, COLOR_GREY, "* Ётот игрок уже состоит в другой организации!");
	if(params[1] < 1 || params[1] > 20) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	if(params[1] == 8 && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	Pl::Info[params[0]][pMember] = params[1];
	Pl::Info[params[0]][pRank] = 1;
	Rac::SetPlayerInterior(params[0], 3);
	Rac::SetPlayerVirtualWorld(params[0], 7);
	Rac::SetPlayerPos(params[0],207.4872,-129.2266,1003.5078);
	Pl::Info[params[0]][pLocal] = OFFSET_BIZZ + GetIndexFromBizID(7);
	SelectCharPlace[params[0]] = 0;
	Pl::SetFracColor(params[0]);
	Iter::Add(TeamPlayers[params[1]], params[0]);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /ainvite к игроку %s[%d][%s]", sendername, playername, params[0], FracInfo[params[1]][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* ¬ы были прин€ты в %s админом %s", FracInfo[params[1]][fName], sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:invite(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /invite [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::FracID(params[0]) != 0) return Send(playerid, COLOR_GREY, "* Ётот игрок уже сотоит в другой организации!");
	if(Pl::Info[params[0]][pMedKarta] == 0) return Send(playerid, COLOR_GREY, "* ” него нету мед.карты!");
	if(IsLegalFrac(Pl::FracID(params[0])) && !Pl::Info[params[0]][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” этого человека нет паспорта!");
	getname(playerid -> sendername, params[0] -> playername);
	SetPVarInt(params[0], "InvateFrac", Pl::Info[playerid][pLeader]);
	format(string, sizeof string, "* ¬ы были приглашены в %s лидером %s (пишите /accept invite чтобы согласитс€)", FracInfo[Pl::Info[playerid][pLeader]][fName], sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы пригласили %s в %s.", playername, FracInfo[Pl::Info[playerid][pLeader]][fName]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:uninvite(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /invite [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pLeader] > 0) return Send(playerid, COLOR_GREY, "* ¬ы не можите уволить лидера!");
	if(Pl::FracID(playerid) != Pl::FracID(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не состоит в вашей организации!");
	Iter::Remove(TeamPlayers[Pl::Info[params[0]][pMember]], params[0]);
	Pl::Info[params[0]][pMember] = 0;
	Pl::Info[params[0]][pRank] = 0;
	switch(Pl::Info[params[0]][pSex]) {
	case 1: Pl::Info[params[0]][pChar] = 60;
	case 2: Pl::Info[params[0]][pChar] = 55;
	default: Pl::Info[params[0]][pChar] = 60;
	}
	MedicBill[params[0]] = false;
	Pl::Info[params[0]][pJob] = 0;
	Pl::Info[params[0]][pContractTime] = 0;
	Pl::SetSpawnInfo(params[0]);
	Rac::SpawnPlayer(params[0]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы выкинули %s из своей фракции.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы были уволены из фракции %s, лидером %s.", FracInfo[Pl::Info[playerid][pLeader]][fName], sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	Send(params[0], COLOR_LIGHTBLUE, "* ¬ы теперь гражданское лицо.");
	return 1;
}

CMD:unleader(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]S(не указана)[64]", playername, temp)) return Send(playerid, COLOR_GREY, "¬ведите: /unadmin [name] [reason]");
	params[0] = ReturnUser(playername);
	if(IsPlayerConnected(params[0])) {
		if(Pl::isLogged(params[0])) {
			format(string, sizeof string, "* Ётот игрок сейчас онлайн. »спользуйте: /makeleader %i 0", params[0]);
			Send(playerid, COLOR_GREY, string);
		}
	} else {
		format(string, sizeof string, "UPDATE `"#__TableUsers__"` SET `Leader`='0' WHERE BINARY `Name`='%s'", playername);
		new Cache:result = Db::query(connDb, string, true);
		if(cache_affected_rows()) {
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof string, "[AdmWarn] * %s применил команду /unleader к лидеру %s, причина: %s", sendername, playername, temp);
			SendToAdmin(COLOR_YELLOW, string, 4, 3);
		} else {
			Send(playerid, COLOR_GREY, "* “акого игрока не существует!");
		}
		cache_delete(result);
	}
	return 1;
}

CMD:unhelper(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPHelper(playerid, 3) && !Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]S(не указана)[64]", playername, temp)) return Send(playerid, COLOR_GREY, "¬ведите: /unhelper [name] [reason]");
	params[0] = ReturnUser(playername);
	if(IsPlayerConnected(params[0])) {
		if(Pl::isLogged(params[0])) {
			format(string, sizeof string, "* Ётот игрок сейчас онлайн. »спользуйте: /makehelper %i 0", params[0]);
			Send(playerid, COLOR_GREY, string);
		}
	} else {
		format(string, sizeof string, "UPDATE `"#__TableUsers__"` SET `Helper`='0' WHERE BINARY `Name`='%s'", playername);
		new Cache:result = Db::query(connDb, string, true);
		if(cache_affected_rows()) {
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof string, "[AdmWarn] * %s применил команду /unhelper к хелперу %s, причина: %s", sendername, playername, temp);
			SendToAdmin(COLOR_YELLOW, string, 4, 3);
		} else {
			Send(playerid, COLOR_GREY, "* “акого игрока не существует!");
		}
		cache_delete(result);
	}
	return 1;
}

CMD:unadmin(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPHelper(playerid, 3) && !Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]S(не указана)[64]", playername, temp)) return Send(playerid, COLOR_GREY, "¬ведите: /unadmin [name] [reason]");
	params[0] = ReturnUser(playername);
	if(IsPlayerConnected(params[0])) {
		if(Pl::isLogged(params[0])) {
			format(string, sizeof string, "* Ётот игрок сейчас онлайн. »спользуйте: /makeadmin %i 0", params[0]);
			Send(playerid, COLOR_GREY, string);
		}
	} else {
		format(string, sizeof string, "UPDATE `"#__TableUsers__"` SET `Admin`='0' WHERE BINARY `Name`='%s'", playername);
		new Cache:result = Db::query(connDb, string, true);
		if(cache_affected_rows()) {
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof string, "[AdmWarn] * %s применил команду /unhelper к админу %s, причина: %s", sendername, playername, temp);
			SendToAdmin(COLOR_YELLOW, string, 4, 3);
		} else {
			Send(playerid, COLOR_GREY, "* “акого игрока не существует!");
		}
		cache_delete(result);
	}
	return 1;
}

CMD:makeleader(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /makeleader [id] [fracid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pAdmin] && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* Ќельз€ мен€ть лидерку админу!");
	if(params[1] < 0 || params[1] > 20) return Send(playerid, COLOR_GREY, "* Ќе ниже 0, и не выше 20!");
	if(params[1] == 8 && !Pl::isAdmin(playerid, 5))  return Send(playerid, COLOR_GREY, "* Ќе ниже 0, и не выше 20!");
	if(Pl::FracID(params[0]) == params[1])  return Send(playerid, COLOR_GREY, "* Ётот игрок уже лидер!");
	getname(playerid -> sendername,params[0] -> playername);
	if(params[1] == 0) {
		if(Pl::Info[params[0]][pLeader]) {
			Iter::Remove(LeaderPlayers, params[0]);
			Iter::Remove(TeamPlayers[Pl::Info[params[0]][pLeader]], params[0]);
		}
		Pl::Info[params[0]][pMember] = 0;
		Pl::Info[params[0]][pLeader] = 0;
		Pl::Info[params[0]][pRank] = 0;
		switch(Pl::Info[params[0]][pSex]) {
		case 1: Pl::Info[params[0]][pChar] = 60;
		case 2: Pl::Info[params[0]][pChar] = 55;
		default: Pl::Info[params[0]][pChar] = 60;
		}
		MedicBill[params[0]] = false;
		Pl::SetSpawnInfo(params[0]);
		Rac::SpawnPlayer(params[0]);
		format(string, sizeof string, "* ¬ы были сн€ты с лидерки администратором %s", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	} else {
		if(!Pl::Info[params[0]][pLeader]) Iter::Add(LeaderPlayers, params[0]);
		Iter::Remove(TeamPlayers[Pl::FracID(params[0])], params[0]);
		Iter::Add(TeamPlayers[params[1]], params[0]);

		Pl::Info[params[0]][pLeader] = params[1];
		Pl::Info[params[0]][pMember] = 0;
		Pl::Info[params[0]][pRank] = RankNums[params[1]];

		Rac::SetPlayerInterior(params[0], 3);
		Rac::SetPlayerVirtualWorld(params[0], 7);
		Pl::Info[params[0]][pLocal] = OFFSET_BIZZ + GetIndexFromBizID(7);
		Rac::SetPlayerPos(params[0], 207.4872, -129.2266, 1003.5078);
		SetPlayerWeapons(params[0]);
		Pl::SetFracColor(params[0]);
		Pl::SetSpawnInfo(params[0]);

		format(string, sizeof string, "* ¬ы были назначены лидером фракции %s, администратором %s", FracInfo[params[1]][fName], sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	format(string, sizeof string, "[AdmWarn] * %s применил команду /makeleader к игроку %s[%s]",
	sendername, playername, FracInfo[params[1]][fName]);
	SendToAdmin(COLOR_YELLOW, string, 4, 3);

	return 1;
}

CMD:agiverank(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* ¬ы не лидер фракции!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /giverank [id] [ранг]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	new fracid = Pl::FracID(params[0]);
	if(fracid <= 0) return Send(playerid, COLOR_GREY, "* Ётот игрок не состоит в организаци€х!");
	if(params[1] <= 0 || params[1] > RankNums[fracid]) {
		format(string, sizeof string, "* ¬ этой фракции всего %d рангов!", RankNums[fracid]);
		Send(playerid, COLOR_GREY, string);
		return 1;
	}
	Pl::Info[params[0]][pRank] = params[1];
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "* ¬ы были повышены/понижены в ранге админом %s, ваш ранг: %i", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /agiverank к игроку %s[%d][%s]", sendername, playername, params[0], FracInfo[fracid][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:giverank(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GREY, "* ¬ы не лидер фракции!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /giverank [id] [ранг]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	new fracid = Pl::FracID(params[0]);
	if(fracid != Pl::Info[playerid][pLeader]) return Send(playerid, COLOR_GREY, "* Ётот игрок не состоит в вашей фракции!");
	if(params[1] <= 0 || params[1] > RankNums[fracid]) {
		format(string, sizeof string, "* ¬ вашей фракции всего %d рангов", RankNums[fracid]);
		Send(playerid, COLOR_GREY, string);
		return 1;
	}
	Pl::Info[params[0]][pRank] = params[1];
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "* ¬ы были повышены/понижены в ранге лидером %s, ваш ранг: %i", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы повысели %s. “еперь его ранг %i.", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:givetwarn(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "us[24]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /givetwarn [id] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");

	new fracid = Pl::FracID(playerid);
	if(fracid != Pl::FracID(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не состоит в вашей организации!");
	if(IsPlayerLeader(params[0]) == fracid) return Send(playerid, COLOR_GREY, "* ¬ы не можете дать выговор лидеру!");

	Pl::Info[params[0]][pRebuke]++;
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* %s выдал выговор %s. ѕричина: %s", sendername,playername, params[1]);
	sendToFamily(fracid, COLOR_RED, string);
	if(Pl::Info[params[0]][pRebuke] >= 4)
	{
		Pl::Info[params[0]][pMember] = 0;
		Pl::Info[params[0]][pRank] = 0;
		switch(Pl::Info[params[0]][pSex])
		{
		case 1: Pl::Info[params[0]][pChar] = 60;
		case 2: Pl::Info[params[0]][pChar] = 55;
		default: Pl::Info[params[0]][pChar] = 60;
		}
		MedicBill[params[0]] = false;
		Pl::Info[params[0]][pJob] = 0;
		Pl::Info[params[0]][pContractTime] = 0;
		Pl::Info[params[0]][pRebuke] = 0;
		SetPlayerSkin(params[0], Pl::Info[params[0]][pChar]);
		Pl::SetSpawnInfo(params[0]); Rac::SpawnPlayer(params[0]);

		format(string, sizeof string, "* ¬ы получили 4-й выговор от лидера %s и были автоматически уволены из фракции. ѕричина: %s", sendername, params[1]);
		Send(params[0], COLOR_LIGHTRED, string);
		format(string, sizeof string, "* ¬ы дали 4-й выговор игроку %s и он был автоматически уволен из вашей фракции. ѕричина: %s", playername, params[1]);
		Send(playerid, COLOR_LIGHTRED, string);
		Pl::Update(params[0]);
	} else {
		format(string, sizeof string, "* ¬ы получили выговор от лидера %s. ѕричина: %s", sendername, params[1]);
		Send(params[0], COLOR_LIGHTRED, string);
		format(string, sizeof string, "* ¬ы дали выговор игроку %s. ѕричина: %s", playername, params[1]);
		Send(playerid, COLOR_LIGHTRED, string);
	}
	return 1;
}

CMD:untwarn(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /untwarn [id]");
	if(Pl::FracID(playerid) != Pl::FracID(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не состоит в вашей организации!");
	if(Pl::Info[params[0]][pRebuke] <= 0) return Send(playerid, COLOR_GREY, "* ” этого игрока нет выговоров");
	Pl::Info[params[0]][pRebuke] --;
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* Ћидер %s сн€л с вас 1 выговор. ", sendername, params[1]);
	Send(params[0], COLOR_LIGHTRED, string);
	format(string, sizeof string, "* ¬ы сн€ли 1 выговор с подчиненного %s.", params[1], playername);
	Send(playerid, COLOR_LIGHTRED, string);
	return 1;
}

CMD:achangerank(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /aranklist [fracid]");
	if(params[0] < 1 || params[0] > 20) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	ShowRankList(playerid, params[0]);
	return 1;
}

CMD:setspawn(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /changespawn [fracid]");
	if(params[0] < 1 || params[0] > sizeof(SpawnInfo)) return Send(playerid, COLOR_GREY, "Ќеверный ID спавна!");
	GetPlayerPos(playerid, SpawnInfo[params[0]][spX], SpawnInfo[params[0]][spY], SpawnInfo[params[0]][spZ]);
	GetPlayerFacingAngle(playerid, SpawnInfo[params[0]][spA]);
	SpawnInfo[params[0]][spInt] = GetPlayerInterior(playerid);
	SpawnInfo[params[0]][spVirt] = GetPlayerVirtualWorld(playerid);
	format(query, sizeof query, "UPDATE `"#__TableSpawns__"` SET ");
	scf(query, string, "`interior`='%i',", SpawnInfo[params[0]][spInt]);
	scf(query, string, "`virtualworld`='%i',", SpawnInfo[params[0]][spVirt]);
	scf(query, string, "`spawn_x`='%.3f',", SpawnInfo[params[0]][spX]);
	scf(query, string, "`spawn_y`='%.3f',", SpawnInfo[params[0]][spY]);
	scf(query, string, "`spawn_z`='%.3f',", SpawnInfo[params[0]][spZ]);
	scf(query, string, "`spawn_a`='%.3f' ", SpawnInfo[params[0]][spA]);
	scf(query, string, "WHERE `ID` = '%i'", params[0]);
	Db::tquery(connDb, query, "", "");
	Send(playerid, COLOR_YELLOW, "* ћесто спавна было изменино!");
	return 1;
}

CMD:fraccolor(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params,"ih",params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /fraccolor [id] [color]");
	if(!IsValidFrac(params[0])) return Send(playerid, COLOR_GREY, "Invalid frac id!");
	FracInfo[params[0]][fColor] = params[1];
	UpdateFracInfo(params[0]);
	Send(playerid, COLOR_YELLOW, "* ÷вет фракции был изминен!");
	return 1;
}

CMD:fracspawn(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /changespawn [fracid]");
	if(!IsValidFrac(params[0])) return Send(playerid, COLOR_GREY, "Ќеверный ID фракции!");

	GetPlayerPos(playerid,
	FracInfo[params[0]][fSpawn][fSpawnPos][0],
	FracInfo[params[0]][fSpawn][fSpawnPos][1],
	FracInfo[params[0]][fSpawn][fSpawnPos][2]
	);
	GetPlayerFacingAngle(playerid, FracInfo[params[0]][fSpawn][fSpawnPos][3]);

	FracInfo[params[0]][fSpawn][fSpawnInt][0] = GetPlayerInterior(playerid);
	FracInfo[params[0]][fSpawn][fSpawnInt][1] = GetPlayerVirtualWorld(playerid);

	format(query, sizeof query, "UPDATE `"#__TableFracInfo__"` SET ");
	scf(query, string, "`fSpawn`='%i,%i,", FracInfo[params[0]][fSpawn][fSpawnInt][0], FracInfo[params[0]][fSpawn][fSpawnInt][1]);
	scf(query, string, "%.3f,%.3f,", FracInfo[params[0]][fSpawn][fSpawnPos][0], FracInfo[params[0]][fSpawn][fSpawnPos][1]);
	scf(query, string, "%.3f,%.3f'", FracInfo[params[0]][fSpawn][fSpawnPos][2], FracInfo[params[0]][fSpawn][fSpawnPos][3]);
	scf(query, string, " WHERE `fID` = '%i'", params[0]);
	Db::tquery(connDb, query, "", "");
	Send(playerid, COLOR_YELLOW, "* ћесто спавна было изменино!");
	return 1;
}

CMD:mark(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* —иди бл€ть!");
	TeleportDest[playerid][tpInt] = GetPlayerInterior(playerid);
	TeleportDest[playerid][tpVw] = GetPlayerVirtualWorld(playerid);
	TeleportDest[playerid][tpLocal] = Pl::Info[playerid][pLocal];
	GetPlayerFacingAngle(playerid, TeleportDest[playerid][tpPos][3]);
	GetPlayerPos(playerid, TeleportDest[playerid][tpPos][0], TeleportDest[playerid][tpPos][1], TeleportDest[playerid][tpPos][2]);
	return Send(playerid, COLOR_GRAD1, "* ¬ы установили маркер дл€ телепорта (используйте /gotomark дл€ телепорта туда)");
}

CMD:gotomark(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* —иди бл€ть!");
	if(GetPlayerState(playerid) == 2 && GetPlayerInterior(playerid)) return Send(playerid, COLOR_GREY, "* Ќельз€ телепортироватс€ в интерьер!");
	Rac::SetPlayerPos(playerid, TeleportDest[playerid][tpPos][0], TeleportDest[playerid][tpPos][1], TeleportDest[playerid][tpPos][2]);
	Rac::SetPlayerFacingAngle(playerid, TeleportDest[playerid][tpPos][3]);
	Pl::Info[playerid][pLocal] = TeleportDest[playerid][tpLocal];
	Rac::SetPlayerInterior(playerid, TeleportDest[playerid][tpInt]);
	Rac::SetPlayerVirtualWorld(playerid, TeleportDest[playerid][tpVw]);
	return Send(playerid, COLOR_LIGHTBLUE, "* ¬ы были телепортированы!");
}

CMD:tp(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* ¬ы заключенный!");
	SPD(playerid, D_GOTO, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты", "Ч ѕопул€рные места\nЧ –еспы банд\nЧ –еспы фракций", "SELECT", "CANCEL");
	return 1;
}

CMD:gotoc(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	new Float:pos[3];
	if(sscanf(params, "P<,>a<f>[3]I(0)I(0)", pos, params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /gotoc [interior] [vitualworld] [posX,posY,posZ]");
	Rac::SetPlayerPos(playerid, pos[0], pos[1], pos[2]);
	Rac::SetPlayerVirtualWorld(playerid, params[1]);
	Rac::SetPlayerInterior(playerid, params[0]);
	Send(playerid, COLOR_WHITE, "¬ы бвли телепортированы по своим координатам!");
	return 1;
}

CMD:goto(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* Ёто вевозможно!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /goto [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!TogTP[params[0]] && !Pl::isAdmin(playerid, 5)) return Send(playerid,COLOR_GREY,"* јдмин запретил к нему телепортироватьс€!");
	GetPlayerPos(params[0], posx, posy, posz);
	if(GetPlayerState(playerid) == 2) Rac::SetVehiclePos(GetPlayerVehicleID(playerid), posx, posy+4, posz);
	else Rac::SetPlayerPos(playerid,posx, posy+2, posz);
	Rac::SetPlayerInterior(playerid,GetPlayerInterior(params[0]));
	Rac::SetPlayerVirtualWorld(playerid,GetPlayerVirtualWorld(params[0]));
	Pl::Info[playerid][pLocal] = Pl::Info[params[0]][pLocal];
	Send(playerid, COLOR_LIGHTBLUE, "* ¬ы были телепортированы!");
	return 1;
}

CMD:gethere(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* —иди бл€ть!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /gethere [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed]) return Send(playerid, COLOR_GRAD1, "* Ёто вевозможно!");
	if(Pl::Info[params[0]][pAdmin] > Pl::Info[playerid][pAdmin] && !Pl::isAdmin(playerid, 5)) return Send(playerid,COLOR_GREY,"* —кажите админу чтобы он “елепортировалс€ к вам.");
	GetPlayerPos(playerid, posx, posy, posz);
	if (GetPlayerState(params[0]) == 2) Rac::SetVehiclePos(GetPlayerVehicleID(params[0]), posx, posy+3, posz);
	else Rac::SetPlayerPos(params[0],posx, posy+1, posz);
	Rac::SetPlayerInterior(params[0], GetPlayerInterior(playerid));
	Rac::SetPlayerVirtualWorld(params[0], GetPlayerVirtualWorld(playerid));
	Pl::Info[params[0]][pLocal] = Pl::Info[playerid][pLocal];
	Send(params[0], COLOR_LIGHTRED2, "* ¬ы были телепортированы администрацией!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /gethere к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);

	return 1;
}

CMD:getcar(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* —иди бл€ть!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /getcar [carid]");
	GetPlayerPos(playerid, posx, posy, posz);
	SetVehiclePos(params[0], posx+4, posy+4, posz);
	return 1;
}

CMD:gethousecar(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /getcar [carid]");
	if(!IsValidHouse(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID дома!");
	GetPlayerPos(playerid, posx, posy, posz);
	SetVehiclePos(HouseInfo[params[0]][hAuto], posx+4, posy+4, posz);
	return 1;
}

CMD:oldcar(playerid, params[]) { new string[144];
	format(string, sizeof string, "* ¬аш старый автомобиль был: %d", gLastCar[playerid]);
	Send(playerid, COLOR_GREY, string);
	return 1;
}

CMD:givegun(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(!sscanf(params, "uii", params[0], params[1], params[2])) {
		if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
		if(IsWrongWeponID(params[1]) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* Ќе правельный ID оружи€!");
		if(params[2] < 1 || params[2] > 999 && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* Ќе ниже 1 и не выше 999 патронов!");
		Rac::GivePlayerWeapon(params[0], params[1], params[2]);
		getname(playerid -> sendername, params[0] -> playername);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /givegun к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	} else {
		ShowDialog(playerid, D_GGUN, DIALOG_STYLE_INPUT, "GIVEGUN", "dialog/ggun.txt", "¬вод", "ќтмена");
	}
	return 1;
}

CMD:resetgun(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /resetgun [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /resetgun к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 1);
	Rac::ResetPlayerWeapons(params[0]);
	return 1;
}

CMD:sethp(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /sethp [id] [amount]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	Rac::SetPlayerHealth(params[0], params[1]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /sethp к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, SUPERMODER);
	return 1;
}

CMD:setarmour(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setarmour [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(!IsACop(params[0]) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* “олько дл€ закона!");
	Rac::SetPlayerArmour(params[0], params[1]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setarmour к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, SUPERMODER);
	return 1;
}

CMD:veh(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "iI(0)I(0)", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "¬ведите: /veh [model] [color1] [color2]");
	if(!(400 <= params[0] <= 611)) return Send(playerid, COLOR_GREY, "* ID транспортного средства не может быть ниже 400 или выше 611 !");
	if((params[0] == 425 || params[0] == 520 || params[0] == 432) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* ¬ы не можите создать этот транспорт!");
	if(Iter::Count(CreatedCars) >= 50) return Send(playerid, COLOR_GREY, "* —оздано максемальное кол-во транспорта!");
	new vehid, Float:x, Float:y, Float:z;
	GetPlayerCameraLookAt(playerid, 5.0, x, y, z);
	GetPlayerPos(playerid, z, z, z);
	vehid = Veh::Create(params[0], x, y, z, 0.0, params[1], params[2], 1200);
	Iter::Add(CreatedCars, vehid);
	SetVehicleNumber(vehid);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /veh. —озданный транспорт [ID: %i; Model: %s]", GetName(playerid), vehid, VehicleNames[GetVehicleModel(vehid)-400]);
	SendToAdmin(COLOR_YELLOW, string, 1, SUPERMODER);
	return 1;
}

CMD:setbenz(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не находитесь в транспорте!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /setbenz!");
	AutoInfo[GetPlayerVehicleID(playerid)][aFuel] = float(params[0]);
	return 1;
}

CMD:fuelcars(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	for(new veh; veh < MAX_VEHICLES; veh++) if(IsValidVehicle(veh)) AutoInfo[veh][aFuel] = MAX_GAS;
	format(string, sizeof string,"* јвдинистратор %s заправил весь транспорт на сервере", GetName(playerid));
	SendToAdmin(COLOR_LIGHTRED, string, 3);
	GameTextForAll("~w~BCE ABПOЦOАЕЗЕ ~g~Filled ~w~АСЗЕ ~p~ИAМPABЗEмС!",5000,1);
	Send(playerid, COLOR_LIGHTBLUE, "* ¬се машины были заправлены");
	return 1;
}

CMD:fixveh(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) {
		if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не находитесь в транспорте!");
		Rac::RepairVehicle(GetPlayerVehicleID(playerid)); Send(playerid, COLOR_LIGHTBLUE, "* “ранспорт был починен!");
	} else {
		if(!IsPlayerInAnyVehicle(params[0])) return Send(playerid, COLOR_GREY, "* ¬ы не находитесь в транспорте!");
		Rac::RepairVehicle(GetPlayerVehicleID(params[0]));

		getname(playerid -> sendername,params[0] -> playername);
		format(string, sizeof string, "* јдминистратор %s починил ваш транспорт!", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /fixveh к игроку %s[%s]",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	}
	return 1;
}

CMD:fillveh(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) {
		new veh = GetPlayerVehicleID(playerid);
		if(!veh) return Send(playerid, COLOR_GREY, "* ¬ы не находитесь в транспорте!");
		AutoInfo[veh][aFuel] = 99.0;
		updateBenzinTD(playerid, veh);
		Send(playerid, COLOR_LIGHTBLUE, "* “ранспорт был заправлен!");
	} else {
		new veh = GetPlayerVehicleID(params[0]);
		if(!veh) return Send(playerid, COLOR_GREY, "* “от игрок не находитс€ в транспорте!");
		AutoInfo[veh][aFuel] = 99.0;
		updateBenzinTD(playerid, veh);
		getname(playerid -> sendername,params[0] -> playername);
		format(string, sizeof string, "* јдминистратор %s починил ваш транспорт!", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /fillveh к игроку %s[%s]",
		sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	}
	return 1;
}

CMD:weatherall(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* ¬ам не доступна эта функци€");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /weatherall [номер погоды]");
	SetWeather(params[0]);
	return 1;
}

CMD:worldtime(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* ¬ам не доступна эта функци€");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /worldtime [0-11]");
	SetWorldTime(params[0]);
	return 1;
}

CMD:weather(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* ¬ам не доступна эта функци€");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /weather [номер погоды] (0 - 45)");
	if(params[0] < 0 || params[0] > 45) return SendClientMessage(playerid, COLOR_GREY, "* ѕогодное удостоверение личности не может быть ниже 0 или выше 45!");
	SetPlayerWeather(playerid, params[0]);
	Send(playerid, COLOR_LIGHTBLUE, "* ¬ы установили дл€ себ€ погоду.");
	return 1;
}

CMD:setmoney(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setmoney [номер погоды]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	params[3] = Rac::GetPlayerMoney(params[0]); Rac::SetPlayerMoney(params[0], params[1]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setmoney к игроку %s[%d]. Ѕыло:$%d; —тало: $%d",
	sendername, playername, params[0], params[3], Rac::GetPlayerMoney(params[0])); SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:givemoney(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* ¬ам не доступна эта функци€");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_WHITE, "¬ведите: /givemoney [id] [money]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Rac::GivePlayerMoney(params[0], params[1]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /givecash к игроку %s[%d].  ол-во: $%d", sendername, playername, params[0], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s дал вам $%i", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:slap(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pJailed] > 0) return Send(playerid, COLOR_GRAD1, "* —иди бл€ть!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /slap [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Rac::GivePlayerHealth(params[0], -5), SlapPlayer(params[0], 4.5), PlayerPlaySound(params[0], 1130, posx, posy, posz+5);
	if(params[0] != playerid)
	{
		getname(playerid -> sendername,params[0] -> playername);
		format(string, sizeof string, "[AdmWarn] * %s применил команду /slap к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	}
	return 1;
}

CMD:mute(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "uds[64]", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "¬ведите: /mute [id] [time] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	switch(Pl::Info[params[0]][pMuted]) {
	case 0 : {
			if(params[1] < 1 || params[1] > 60) return Send(playerid, COLOR_LIGHTRED, "* ћинуты 1, и максимум 60 минут!");
			Pl::Info[params[0]][pMuted] = 1;
			Pl::Info[params[0]][pMutedTime] = params[1]*60;
			format(string, sizeof string, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": %s получил молчанку от администратора %s. ѕричина: %s", GetName(params[0]), GetName(playerid), params[2]);
			SendToAll(COLOR_LIGHTRED, string);
		}
	case 1..2 : {
			Pl::Info[params[0]][pMuted] = 0;
			Pl::Info[params[0]][pMutedTime] = 0;
			format(string, sizeof string, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": јдминистратор %s сн€л молчанку с %s.", GetName(playerid), GetName(params[0]));
			SendToAll(COLOR_LIGHTRED, string);
		}
	}
	return 1;
}

CMD:hmute(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPHelper(playerid, 2)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "us[64]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /hmute [id] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pMuted] == 2) return Send(playerid, COLOR_GREY, "* ” игрока уже есть молчанка!");
	getname(playerid -> sendername,params[0] -> playername);
	Pl::Info[params[0]][pMuted] = 2;
	Pl::Info[params[0]][pMutedTime] = 180;
	format(string, sizeof string, "*[H] %s получил молчанку дл€ чата /vopros от хелпера %s, причина: %s", playername, sendername, params[1]);
	SendToHelper(COLOR_ORANGE, string);
	return 1;
}

CMD:exp(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /exp [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	if(Pl::Info[params[0]][pAdmin] > Pl::Info[playerid][pAdmin]) return Send(playerid, COLOR_LIGHTRED, "* ¬ы не можете подорвать администратора!");
	Rac::SetPlayerHealth(params[0], 10.0);
	GetPlayerPos(params[0], posx, posy, posz);
	CreateExplosion(posx, posy, posz, 7, 10);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /exp к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:gmtest(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /gmtest [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	if(Pl::Info[params[0]][pAdmin] > Pl::Info[playerid][pAdmin]) return Send(playerid, COLOR_LIGHTRED, "* ¬ы не можете подорвать администратора!");
	GMTest{params[0]} = true;
	GetPlayerPos(params[0], posx, posy, posz);
	CreateExplosion(posx, posy, posz, 7, 10);
	SetTimerEx("onGMTest", 1000, false, "i", params[0]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /gmtest к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:kick(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "us[64]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /kick [id] [reason]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": %s кикнут администратором %s, причина: %s", playername, sendername, params[1]);
	SendToAll(COLOR_LIGHTRED, string);
	printf("%s", string);
	Kick(params[0]);
	return 1;
}

CMD:skick(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "us[64]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /skick [id] [reason]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /skick к игроку %s[%i], причина: %s", sendername, playername, params[0], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	Kick(params[0]);
	return 1;
}

CMD:kickers(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "ds[64]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /kickers [lvl] [reason]");
	GetPlayerName(playerid, sendername, 24);
	foreach(new p: Player) {
		if(Pl::isLogged(p)) {
			if(Pl::Info[p][pLevel] == params[0]) {
				GetPlayerName(playerid, playername, 24);
				format(string, sizeof string, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC" %s кикнут администратором %s, причина: %s", playername, sendername, params[1]);
				SendToAll(COLOR_LIGHTRED, string);
				Kick(p);
			}
		}
	}
	return 1;
}

CMD:setlocal(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setlocal [id]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Pl::Info[params[0]][pLocal] = params[1];
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setlocal к игроку %s[%d]", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:setvw(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setvw [id] [virtualworld]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Rac::SetPlayerVirtualWorld(params[0], params[1]);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setvw к игроку %s[%d]", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:setint(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /setint [id] [interior]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Rac::SetPlayerInterior(params[0], params[1]);
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setint к игроку %s[%d]", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:spcars(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return SendClientMessage(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	for(new i; i < MAX_VEHICLES; i++) if(IsValidVehicle(i)) SetVehicleToRespawn(i);
	return 1;
}

CMD:vehid(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return SendClientMessage(playerid, COLOR_GREY, "* Ќедостаточно прав!");

	new vehicle;
	if(IsPlayerInAnyVehicle(playerid)) {
		vehicle = GetPlayerVehicleID(playerid);
		format(string, sizeof string, "Vehicle [Model: %i; ID: %i]", GetVehicleModel(vehicle), vehicle);
		Send(playerid, COLOR_YELLOW, string);
	} else {
		vehicle = ClosestVeh(playerid, 3.0);
		format(string, sizeof string, "Vehicle [Model: %i; ID: %i]", GetVehicleModel(vehicle), vehicle);
		Send(playerid, COLOR_YELLOW, string);
	}
	return 1;
}

CMD:spcar(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /spcar [carid]");
	if(params[0] < 1 || params[0] > MAX_VEHICLES) return Send(playerid, COLOR_GREY, "* “ранспорта с таким ID не существует!");
	SetVehicleToRespawn(params[0]);
	return 1;
}

CMD:dc(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY,"* Ќедостаточно прва!");
	if(sscanf(params, "i", params[0])) {
		if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY,"¬ведите: /dc [vehid]");
		new vehid = GetPlayerVehicleID(playerid);
		Iter::Remove(CreatedCars, vehid);
		Veh::Destroy(vehid);
		Send(playerid, COLOR_YELLOW, "* ћашина удалена!");
		return 1;
	}
	if(params[0] < 1 || params[0] > MAX_VEHICLES) return Send(playerid, COLOR_GREY, "* “ранспорта с таким ID не существует!");
	Iter::Remove(CreatedCars, params[0]); Veh::Destroy(params[0]);
	Send(playerid, COLOR_YELLOW, "* ћашина удалена!");

	return 1;
}

CMD:alldc(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid,COLOR_RED,"* Ќедостаточно прва!");
	new temp_veh;
	foreach(new veh : CreatedCars) {
		temp_veh = veh;
		Veh::Destroy(temp_veh);
	}
	Iter::Clear(CreatedCars);
	Send(playerid, COLOR_YELLOW, "* ћашины были унечтожены!");
	return 1;
}

CMD:warn(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GRAD2, "* Ќедостаточно прав!");
	if(sscanf(params, "us[64]", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /warn [id] [reason]");
	if(Pl::isAdmin(params[0], 1) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GRAD2, "* ¬ы не можите выдать варн админу!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* »грок не авторизирован!");
	Pl::Info[params[0]][pWarns] += 1;
	if(Pl::Info[params[0]][pWarns] >= 3) {
		format(string, sizeof string, "%s (3 Warns)", params[1]);
		Pl::Info[params[0]][pWarns] = 0;
		AddBanList(params[0], playerid, 3*1440, string, 1);
		return 1;
	}
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /warn к игроку %s[%d]. ѕричина: %s", sendername, playername, params[0], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s выдал ¬ам предупреждение. ѕричина: %s", sendername, params[1]);
	Send(params[0], COLOR_LIGHTRED, string);
	return 1;
}

CMD:clearwarn(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD2, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /clearwarn [id]");
	if(Pl::isAdmin(params[0], 1) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GRAD2, "* ¬ы не можите снимать варн с админа!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* »грок не авторизирован!");
	if(Pl::Info[params[0]][pWarns] <= 0) return Send(playerid, COLOR_GREY,"* ” игрока нет варнов!");
	Pl::Info[params[0]][pWarns] = 0;
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /clearwarn к игроку %s[%i].", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s сн€л с ¬ас все предупреждени€.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:cc(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD2, "* Ќедостаточно прав!");
	for(new i; i != 50; i++) SendToAll(COLOR_WHITE," ");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "* јдминистратор %s[%i] очистил все чаты сервера!", sendername, playerid);
	SendToAll(COLOR_USE, string);
	return 1;
}

CMD:banacc(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]s[24]", playername, temp)) return Send(playerid, COLOR_GREY, "¬ведите: /banacc [id] [reason]");
	params[0] = ReturnUser(playername);
	if(!IsPlayerConnected(params[0])) {
		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Banned` = '1' WHERE BINARY `Name` = '%s'", playername);
		new Cache:result = Db::query(connDb, query, true);
		if(cache_affected_rows()) {
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof string, "[AdmWarn] * %s заблокировал аккаунт %s, причина: %s", sendername, playername, temp);
			SendToAdmin(COLOR_YELLOW, string, 3, 3);
		} else {
			Send(playerid, COLOR_GREY, "* Ќет такого аккаунта!");
		}
		cache_delete(result);
	} else {
		getname(playerid->sendername, params[0]->playername);
		format(string, sizeof string, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": %s был заблокирован администратором %s, причина: %s", playername, sendername, temp);
		SendToAll(COLOR_LIGHTRED, string);
		Pl::Info[params[0]][pBanned] = 1;
		Kick(params[0]);
	}
	return 1;
}

CMD:unbanacc(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]s[24]", playername, temp)) return Send(playerid, COLOR_GREY, "¬ведите: /unbanacc [id] [reason]");
	params[0] = ReturnUser(playername);
	if(!IsPlayerConnected(params[0])) {
		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Banned` = '0' WHERE BINARY `Name` = '%s'", playername);
		new Cache:result = Db::query(connDb, query, true);
		if(cache_affected_rows()) {
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof string, "[AdmWarn] * %s разблокировал аккаунт %s. ѕричина: %s", sendername, playername, temp);
			SendToAdmin(COLOR_YELLOW, string, 3, 3);
		} else {
			Send(playerid, COLOR_GREY, "* Ќет такого аккаунта!");
		}
		cache_delete(result);
	} else {
		Send(playerid, COLOR_GREY, "* Ётот аккаунт не заблокирован!");
	}
	return 1;
}

CMD:ban(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "uis[64]", params[0], params[1], temp)) return Send(playerid, COLOR_GREY, "¬ведите: /ban [id] [days (1-360)] [reason]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	if(Pl::Info[params[0]][pID] == -1) return Send(playerid, COLOR_GREY, "* Ётот игрок не зарегистрирован!");
	if(Pl::isAdmin(params[0], 1) && !IsPlayerAdmin(playerid)) return Send(playerid, COLOR_GREY, "* Ќельз€ банить админа!");
	static const maxdays[] = {0, 10, 20, 60, 90, 360};
	if(!(1 <= params[1] <= maxdays[Pl::Info[playerid][pAdmin]])) {
		format(string, sizeof string, "*  ол-во дней бана может быть от 1 до %i!", maxdays[Pl::Info[playerid][pAdmin]]);
		Send(playerid, COLOR_GREY, string);
	} else {
		AddBanList(params[0], playerid, params[1]*1440, temp, 1);
	}
	return 1;
}

CMD:sban(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "uis[64]", params[0], params[1], temp)) return Send(playerid, COLOR_GREY, "¬ведите: /sban [id] [days (1-360)] [reason]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	if(Pl::Info[params[0]][pID] == -1) return Send(playerid, COLOR_GREY, "* Ётот игрок не зарегистрирован!");
	if(Pl::isAdmin(params[0], 1) && !IsPlayerAdmin(playerid)) return Send(playerid, COLOR_RED, "* Ќельз€ банить админа!");
	static const maxdays[] = {0, 10, 20, 60, 90, 360};
	if(!(1 <= params[1] <= maxdays[Pl::Info[playerid][pAdmin]])) {
		format(string, sizeof string, "*  ол-во дней бана может быть от 1 до %i!", maxdays[Pl::Info[playerid][pAdmin]]);
		Send(playerid, COLOR_GREY, string);
	} else {
		AddBanList(params[0], playerid, params[1]*1440, temp, -1);
	}
	return 1;
}

CMD:oban(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]is[64]", playername, params[0], temp)) return Send(playerid, COLOR_GREY, "¬ведите: /oban [id] [days (1-360)] [reason]");
	if(IsPlayerConnected(ReturnUser(playername))) return Send(playerid, COLOR_GREY, "* Ётот игрок подлючен!");
	static const maxdays[] = {0, 10, 20, 60, 90, 360};
	if(!(1 <= params[0] <= maxdays[Pl::Info[playerid][pAdmin]])) {
		format(string, sizeof string, "*  ол-во дней бана может быть от 1 до %i!", maxdays[Pl::Info[playerid][pAdmin]]);
		Send(playerid, COLOR_GREY, string);
	}

	new banid = GetIDFromName(playername);
	if(banid == -1) return Send(playerid, COLOR_GREY, "* Ќет такого игрока на сервере!");
	if(isBanned(banid)) return Send(playerid, COLOR_GREY, "* Ётот игрок уже забанен!");

	new unbandate, currdate = gettime(), reason[64];
	unbandate = currdate + (params[0]*1440)*60;
	Db::escape_string(temp, reason);
	GetPlayerName(playerid, sendername, 24);
	format(query, sizeof query, "INSERT INTO `"#__TableBanned__"` (`user_id`,`admin_id`,`date`,`unbandate`,`reason`) VALUES (");
	scf(query, src, "'%i','%i',", banid, Pl::Info[playerid][pID]);
	scf(query, src, "'%i','%i','%s')", currdate, unbandate, reason);
	Db::tquery(connDb, query, "", "");

	format(query, sizeof query, "[OFFBAN] јдмин %s забанил игрока %s, причина: %s", sendername, playername, reason);
	SendToAdmin(COLOR_LIGHTBLUE, query, 1, 3);
	return 1;
}

CMD:unban(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[24]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /unban [Name]");
	ShowPlayerBanList(playerid, params[0]);
	return 1;
}

CMD:reloadbans(playerid, params[]) {
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	SendRconCommand("reloadbans");
	return Send(playerid,COLOR_LIGHTBLUE, "* File \"samp.ban\" successfully reloaded!");
}

CMD:getip(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /getip [id]");
	if(!IsPlayerConnected(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
	if(Pl::isAdmin(params[0], 5) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* ¬ы не может узнавать IP адрес этого игрока");
	format(string, sizeof string, "* %s[ID: %i] IP: %s", GetName(params[0]), params[0], GetPIP(params[0]));
	return Send(playerid,COLOR_LIGHTBLUE,string);
}

CMD:banip(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "s[16]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /banip [ip]");
	format(string,sizeof string,"banip %s", params[0]);
	SendRconCommand(string);
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[AdmWarn] * %s забанил IP-адрес %s", sendername, params[0]);
	SendToAdmin(COLOR_LIGHTRED, string, 1, 3);
	return 1;
}

CMD:unbanip(playerid, params[]) { new string[144], sendername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "s[16]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /unbanip [ip]");
	format(string,sizeof string,"unbanip %s", params[0]);
	SendRconCommand(string);
	SendRconCommand("reloadbans");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[AdmWarn] * %s разбанил IP-адрес %s", sendername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	return 1;
}

CMD:gotocar(playerid, params[]) {
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GRAD1, "¬ведите: /gotocar [carid]");
	GetVehiclePos(params[0], posx, posy, posz);
	if(GetPlayerState(playerid) == 2) Rac::SetVehiclePos(GetPlayerVehicleID(playerid), posx+3, posy+3, posz);
	else Rac::SetPlayerPos(playerid, posx+3, posy+3, posz);
	Rac::SetPlayerVirtualWorld(playerid, 0); Rac::SetPlayerInterior(playerid, 0);
	Send(playerid, COLOR_GRAD1, " ¬ы были телепортированы");
	return 1;
}

CMD:freeze(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /freeze [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::isAdmin(params[0], 1) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GREY, "* јдминистратор не может быть заморожен!");
	getname(playerid -> sendername,params[0] -> playername);
	if(params[0] != playerid) {
		format(string, sizeof string, "[AdmWarn] * %s применил команду /freeze к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	}
	Rac::TogglePlayerControllable(params[0], 0);
	format(string, sizeof string, "* ¬ы были заморожены администратором %s", sendername);
	Send(params[0], COLOR_LIGHTRED, string);
	return 1;
}

CMD:unfreeze(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /unfreeze [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Rac::TogglePlayerControllable(params[0], 1);
	getname(playerid->sendername,params[0]->playername);
	if(params[0] != playerid) {
		format(string, sizeof string, "[AdmWarn] * %s применил команду /unfreeze к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
		SendToAdmin(COLOR_YELLOW, string, 1, 3);
	}
	format(string, sizeof string, "* ¬ы были разморожены администратором %s", sendername);
	Send(params[0],COLOR_LIGHTRED,string);
	return 1;
}

CMD:gmx(playerid, params[]) { 
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	SendToAll(COLOR_LIGHTGREEN, "¬Ќ»ћјЌ»≈! ѕроисходит рестарт сервера!");
	SetTimerEx("GameModeInitExitFunc", 10000, false, "i", 0);
	return 1;
}

CMD:makeadmin(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, 4) && !IsPlayerAdmin(playerid)) return Send(playerid, COLOR_GRAD1, "* Ќедостаточно прав!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /makeadmin [id/Name] [level(1-4)]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[1] > 3 && !IsPlayerAdmin(playerid)) return Send(playerid, COLOR_GREY, "* ”ровень админа может быть от 0 до 3!");
	if(!params[1] && Pl::Info[params[0]][pAdmin]) Iter::Remove(AdminPlayers, params[0]);
	else if(params[1] && !Pl::Info[params[0]][pAdmin]) Iter::Add(AdminPlayers, params[0]);
	Pl::Info[params[0]][pAdmin] = params[1];
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* You have been promoted to a level %d admin by %s.", params[1], sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* You are promoted %s to admin level %d.", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:gangtop(playerid, params[]) { new string[144];
	if(!IsAGang(playerid) && !Pl::isAdmin(playerid, 1)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	Send(playerid, COLOR_WHITE, "_____________________|GANG TOP|_____________________");
	for(new i; i < sizeof(GangInfo); i++) {
		format(string, sizeof string,
		"%i. %s  [”важение: %i; Ѕизнесы: %i;  азна: $%i; ќнлайн: %i]",
		i+1,
		GetGangName(GangInfo[i][fID]),
		GangInfo[i][gRespect],
		GangBiznes{GangInfo[i][fID]},
		GetFracMoney(GangInfo[i][fID]),
		Iter::Count(TeamPlayers[GangInfo[i][fID]])
		);
		Send(playerid, GetFracColor(GangInfo[i][fID]), string);
	}
	return 1;
}

CMD:help(playerid, params[]) {
	ShowDialog(playerid, D_HELP,DIALOG_STYLE_LIST,""#__SERVER_PREFIX""#__SERVER_NAME_LC": ѕомощь", "dialog/help.txt", "¬џЅ–ј“№", "«акрыть");
	return 1;
}

CMD:ganginfo(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY,  "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY,  "¬ведите: /ganginfo [fracid]");
	for(new g; g < sizeof(GangInfo); g++) {
		if(GangInfo[g][fID] == params[0]) {
			DestroyDynamic3DTextLabel(GangInfo[g][gText]);
			GetPlayerPos(playerid, GangInfo[g][gPosX], GangInfo[g][gPosY], GangInfo[g][gPosZ]);
			format(temp, sizeof(temp), "*** GANG INFO ***\n\n.::%s::.\nЅизнесы: %d\n”важение: %d\n Ѕанк: $%d\n«ахват с %d ранга",
			GetGangName(GangInfo[g][fID]), GangBiznes{GangInfo[g][fID]}, GangInfo[g][gRespect], GetFracMoney(GangInfo[g][fID]), GetZRank(GangInfo[g][fID]));
			GangInfo[g][gText] = Add3DText(temp, GetFracColor(GangInfo[g][fID]), GangInfo[g][gPosX], GangInfo[g][gPosY], GangInfo[g][gPosZ], 15.0);
			break;
		}
	}
	return 1;
}

CMD:setskill(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "udd", params[0], params[1], params[2])) {
		Send(playerid, COLOR_WHITE, "| Skill Info |");
		Send(playerid, COLOR_GREY,  "| 1: ƒетектив      | 6: –епортер");
		Send(playerid, COLOR_GREY,  "| 2: јдвокат       | 7: ћеханник");
		Send(playerid, COLOR_GREY,  "| 3: Ўлюха         | 8: ѕродователь тачек");
		Send(playerid, COLOR_GREY,  "| 4: Ќаркоторговец | 9: Ѕоксер");
		Send(playerid, COLOR_GREY,  "| 5: ”гонщик тачек | 10: –ыбак");
		Send(playerid, COLOR_WHITE, "||");
		Send(playerid, COLOR_WHITE, "¬ведите: /setskill [playerid] [number] [уровень]");
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не в игре!");
	if( params[2] < 1 || params[2] > 5 ) return Send(playerid, COLOR_GREY, "* «начение скилла может быть от 1 и до 5!");
	switch(params[1]) {
	case 1: {
			Pl::Info[params[0]][pSkill][0] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл детектива теперь %d", Pl::Info[params[0]][pSkill][0]);
		}
	case 2: {
			Pl::Info[params[0]][pSkill][2] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл адвоката теперь %d",Pl::Info[params[0]][pSkill][2]);
		}
	case 3: {
			Pl::Info[params[0]][pSkill][1] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл шлюхи теперь %d",Pl::Info[params[0]][pSkill][1]);
		}
	case 4: {
			Pl::Info[params[0]][pSkill][7] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл наркодиллера теперь %d",Pl::Info[params[0]][pSkill][7]);
		}
	case 5: {
			Pl::Info[params[0]][pSkill][4] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл угонщика теперь %d",Pl::Info[params[0]][pSkill][4]);
		}
	case 6: {
			Pl::Info[params[0]][pSkill][3] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл механника теперь %d",Pl::Info[params[0]][pSkill][3]);
		}
	case 7: {
			Pl::Info[params[0]][pSkill][6] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл репортера теперь %d",Pl::Info[params[0]][pSkill][6]);
		}
	case 8: {
			Pl::Info[params[0]][pSkill][5] = ( params[2] * 100 );
			format(string,sizeof string," ≈го скилл продовальника тачек теперь %d",Pl::Info[params[0]][pSkill][5]);
		}
	default: format(string,sizeof string," Ќеверный ID скила!");
	}
	Send(playerid, COLOR_GREY, string);
	return 1;
}

CMD:skill(playerid, params[]) {
	ShowDialog(playerid, D_SKILL, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": SKILL", "dialog/skill.txt", "¬ыбор","ќтмена");
	return 1;
}

CMD:gl(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 11) return Send(playerid, COLOR_GREY, " ¬ы не лицензер.");
	if(Pl::Info[playerid][pRank] < 2) return Send(playerid, COLOR_GREY, "* ¬ыдавть лицензии можно только с 2-го ранга!");
	if(sscanf(params, "s[15]u", params[1], params[0])) {
		Send(playerid, COLOR_WHITE, "¬ведите: /givelicense [license] [id/Name]");
		Send(playerid, COLOR_WHITE, "ƒоступные лицензии: Driving, Flying, Sailing, Weapon, Fishing.");
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	if(!Pl::Info[params[0]][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” этого человека нет паспорта!");
	getname(playerid -> sendername,params[0] -> playername);

	if(strcmp(params[1], "driving", true) == 0) {
		AshQueue(playerid, 1);
		Pl::Info[params[0]][pTest] = 0;
		Pl::Info[params[0]][pLic][0] = 1;
		format(string, sizeof string, "* ¬ы дали водительские права %s.", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* Ћицензер %s дал вам водительские права", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	} else {
		if(Pl::Info[playerid][pRank] > 2) {
			if(strcmp(params[1], "flying", true) == 0) {
				Pl::Info[params[0]][pLic][1] = 1;
				format(string, sizeof string, "* ¬ы дали лицензию на полеты %s.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				format(string, sizeof string, "* Ћицензер %s дал вам лицензию на полеты.", sendername);
				Send(params[0], COLOR_LIGHTBLUE, string);
			}
			else if(strcmp(params[1], "sailing", true) == 0) {
				Pl::Info[params[0]][pLic][2] = 1;
				format(string, sizeof string, "* ¬ы дали лицензию на лодку %s.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				format(string, sizeof string, "* Ћицензер %s дал лизензию на лодку.", sendername);
				Send(params[0], COLOR_LIGHTBLUE, string);
			}
			else if(strcmp(params[1], "weapon", true) == 0) {
				format(string, sizeof string, "* ¬ы дали ему лицензию на оружие %s.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				format(string, sizeof string, "* Ћицензер %s дал вам лицензию на оружие.", sendername);
				Send(params[0], COLOR_LIGHTBLUE, string);
				Pl::Info[params[0]][pLic][3] = 1;
			}
			else if(strcmp(params[1], "fishing", true) == 0) {
				format(string, sizeof string, "* ¬ы дали ему лицензию на оружие %s.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				format(string, sizeof string, "* Ћицензер %s дал вам лицензию на рыбалку.", sendername);
				Send(params[0], COLOR_LIGHTBLUE, string);
				Pl::Info[params[0]][pLic][4] = 1;
			}
		} else {
			Send(playerid, COLOR_GREY, "* ¬ы можете выдавать только права!");
		}
	}
	return 1;
}

CMD:startlesson(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 11) return Send(playerid, COLOR_GREY, "¬ы не Ћицензер!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /startlesson [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(TakingLesson[params[0]]) return Send(playerid, COLOR_GREY, "* ”рок уже начат!");
	TakingLesson[params[0]] = true;

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы начали урок у %s's", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* Ћицензер %s начал ваш урок по вождению", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:stoplesson(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 11) return Send(playerid, COLOR_GREY, "¬ы не Ћицензер!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /startlesson [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(!TakingLesson[params[0]]) return Send(playerid, COLOR_GREY, "* ”рок не был начат!");
	TakingLesson[params[0]] = false;

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы закончели урок у %s's", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* Ћицензер %s закончил ваш урок по вождению", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:ram(playerid, params[]) {
	if(!IsACop(playerid) && !Pl::isAdmin(playerid, 4)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	foreach(new i : Houses) {
		if(IsPlayerInRangeOfPoint(playerid,3.0,HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2])) {
			EnterHouse(playerid, i);
			GameTextForPlayer(playerid, "~r~Breached the door", 5000, 1);
		}
	}
	return 1;
}

CMD:fracs(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	Send(playerid, COLOR_WHITE, "______________|FRAC|______________");
	for(new i; i < sizeof FracID; i++) {
		format(string, sizeof string,
		"%i. %s [ азна: $%i; ќнлайн: %i]",
		i+1,
		FracInfo[FracID[i]][fName],
		GetFracMoney(FracID[i]),
		Iter::Count(TeamPlayers[FracID[i]])
		);
		Send(playerid, GetFracColor(FracID[i]), string);
	}
	return 1;
}

CMD:fracbank(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /checkbank [fracid]");
	if(!IsValidFrac(params[0])) return Send(playerid, COLOR_GREY, "* Ќеверный ID фракции!");
	format(string, sizeof string, "* Ѕанк %s состовл€ет: $%i", FracInfo[params[0]][fName], GetFracMoney(params[0]));
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:checktax(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pLeader] != 7) return Send(playerid, COLOR_GREY, "* ¬ы не мэр!");
	format(string, sizeof string, "* √осударственный бюджет состовл€ет: %i$", GetFracMoney(7));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:givetax(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pLeader] != 7) return Send(playerid, COLOR_GREY, "* ¬ы не мэр!");
	if(sscanf(params, "ii", params[0], params[1])) {
		Send(playerid, COLOR_GREY, "¬ведите: /givetax [ID фракции] [—умма]");
		Send(playerid, COLOR_GREEN, ">>> ID фракций на сервера: <<");
		for(new i; i < sizeof Teams; i++) {
			format(string, sizeof string, "%i) %s", Teams[i], FracInfo[Teams[i]][fName]);
			Send(playerid, COLOR_YELLOW, string);
		}
	} else {
		if(!IsATeamF(params[0])) return Send(playerid, COLOR_GREY, "* ‘ракци€ не член департамента!");
		if(!(10000 <= params[1] <= 10000000)) return Send(playerid, COLOR_GREY, "* —умма должна быть от $10000 до $10000000");
		if(params[1] > GetFracMoney(TEAM_GOV)) return Send(playerid, COLOR_GREY, "* ¬ казне нет столько денег!");
		GiveFracMoney(TEAM_GOV, -params[1]);
		GiveFracMoney(params[0], params[1]);
		format(string, sizeof string, "* √убернатор перевел $%i на счет %s", params[1], FracInfo[params[0]][fName]);
		sendToTeam(COLOR_ALLDEPT, string, Teams);
	}
	return 1;
}

CMD:settax(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pLeader] != 7) return Send(playerid, COLOR_GREY, "* ¬ы не мэр!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /settax [ammount]");
	if(params[0] < 1 || params[0] > 20) return Send(playerid, COLOR_GREY, "* Ќалог, возможен, от 1 и до 20 процентов!");
	Gm::Info[Gm::TaxValue] = params[0];
	SaveStuff();
	format(string, sizeof string, "* Ќаложен налог - %i процентов от зарплаты, на каждего жител€ штата.", Gm::Info[Gm::TaxValue]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:spawnchange(playerid, params[]) { new string[144];
	if(!IsValidHouse(Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "” ¬ас нет дома или вы не арендуете");
	SpawnChange[playerid] = !SpawnChange[playerid];
	Pl::SetSpawnInfo(playerid);
	format(string, sizeof string, "* ¬ы теперь будете спавнитс€ %s", (SpawnChange[playerid])?("на респавне своей фракции!"):("в своем или арендованном доме!"));
	Send(playerid, COLOR_GREY, string);
	return 1;
}

CMD:report(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(sscanf(params, "s[90]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /report [текст]");
	if(Pl::Info[playerid][pReport] > 0) return Send(playerid, COLOR_LIGHTRED, "* Ќе флуди!");
	Pl::Info[playerid][pReport] = 280;
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "*∆алоба от %s[%d]: %s", sendername, playerid, params[0]);
	SendToAdmin(COLOR_LIGHTRED, string , 1, 2);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:spawn(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /spawn [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /spawn к игроку %s[%s]", sendername, playername, FracInfo[Pl::FracID(params[0])][fName]);
	SendToAdmin(COLOR_YELLOW, string, 3, 3); Rac::SpawnPlayer(params[0]);

	return 1;
}

CMD:forceskin(playerid, params[]) {
	if(!Pl::isAdmin(playerid, MODER2LVL)) return Send(playerid, COLOR_GREY, "Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /forceskin [id/Name]");
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");

	new bidx = GetIndexFromBizID(7);
	Rac::SetPlayerInterior(params[0], 3);
	Rac::SetPlayerVirtualWorld(params[0], BizzInfo[bidx][bVirtual]);
	Pl::Info[params[0]][pLocal] = OFFSET_BIZZ + bidx;
	Rac::SetPlayerPos(params[0], 207.4872,-129.2266,1003.5078);
	Container::At( Pl::FracID(params[0]), Container::First, SelectCharPlace[params[0]], ChosenSkin[params[0]]);
	SetPlayerSkin(params[0], ChosenSkin[params[0]]);
	ShowMenuForPlayer(ClothesMenu, params[0]);
	Rac::TogglePlayerControllable(params[0], 0);

	return 1;
}

CMD:take(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid) && Pl::FracID(playerid) != 11) return Send(playerid, COLOR_GREY, "* Ќедастаточно прав!");
	if(sscanf(params, "s[16]u", temp, params[0])) {
		Send(playerid, COLOR_WHITE, "|_______________ {0080ff}TAKE{ffffff} _______________|");
		Send(playerid, COLOR_WHITE, "* »спользуйте: /take [id] [name]");
		Send(playerid, COLOR_GREY, "*  Ћицензии: drivinglic, flyinglic, sailinglic, weaponlic");
		if(Pl::FracID(playerid) != 11) {
			Send(playerid, COLOR_GREY, "*  ƒругое: drugs, maps, weapons.");
		}
		Send(playerid, COLOR_WHITE, "|_______________________________|");
		return 1;
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GRAD2, "* Ётот игрок не залогинен!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы слишком долеко друг от друга!");
	getname(playerid -> sendername,params[0] -> playername);

	new xx[16];
	format(xx, 16, "%s", (IsACop(playerid))?("ќфицер"):("»нструктор"));
	if(strcmp(temp,"drivinglic",true) == 0) {
		if(Pl::Info[params[0]][pLic][0] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет прав!");
		Pl::Info[params[0]][pLic][0] = 0;
		format(string, sizeof string, "* ¬ы лишили %s водительских прав **", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s %s лишил(а) вас водительских прав **", xx, sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	else if(strcmp(temp,"flyinglic",true) == 0) {
		if(Pl::Info[params[0]][pLic][1] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет лицензии пелота!");
		Pl::Info[params[0]][pLic][1] = 0;
		format(string, sizeof string, "* ¬ы лишили %s лицензии на полЄты **", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s %s лишил(а) вас лицензии на ѕолЄты **", xx, sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	else if(strcmp(temp,"sailinglic",true) == 0) {
		if(Pl::Info[params[0]][pLic][2] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет лицензии на управление водным транспортом!");
		Pl::Info[params[0]][pLic][2] = 0;
		format(string, sizeof string, "* ¬ы лишили %s лицензии на ¬одный “ранспорт **", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s %s лишил(а) вас лицензии на ¬одный “ранспорт **", xx, sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	else if(strcmp(temp,"gunlic",true) == 0) {
		if(Pl::Info[params[0]][pLic][3] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет лицензии на оружи€!");
		Pl::Info[params[0]][pLic][3] = 0;
		format(string, sizeof string, "* ¬ы лишили %s лицензии на Ќашение оружи€ **", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s %s лишил(а) вас лицензии на Ќашение оружи€ **", xx, sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
	} else if(Pl::FracID(playerid) != 11) {
		if(strcmp(temp,"drugs",true) == 0) {
			if(Pl::Info[params[0]][pDrugs] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет наркотиков!");
			Pl::Info[params[0]][pDrugs] = 0;
			format(string, sizeof string, "* ¬ы конфисковали у %s наркотические вещества **", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s %s конфисковал(а) ваши наркотики **", xx, sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);
		}
		else if(strcmp(temp,"mats",true) == 0) {
			if(Pl::Info[params[0]][pMats] <= 0) return Send(playerid, COLOR_GREY, "* ” игрока нет материалов!");
			Pl::Info[params[0]][pMats] = 0;
			format(string, sizeof string, "* ¬ы конфисковали у %s его материалы **", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s %s конфисковал(а) ваши материалы **", xx, sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);
		}
		else if(strcmp(temp,"weapons",true) == 0) {
			Rac::ResetPlayerWeapons(params[0]);
			format(string, sizeof string, "* ¬ы конфисковали у %s его оружие **", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s %s конфисковал(а) ваше оружие **", xx, sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);
		} else {
			Send(playerid, COLOR_WHITE, "|_______________ {0080ff}TAKE{ffffff} _______________|");
			Send(playerid, COLOR_WHITE, "* »спользуйте: /take [id] [name]");
			Send(playerid, COLOR_GREY, "*  Ћицензии: drivinglic, flyinglic, sailinglic, gunlic");
			Send(playerid, COLOR_GREY, "*  ƒругое: drugs, maps, weapons.");
			Send(playerid, COLOR_WHITE, "|______________________________|");
		}
	} else {
		Send(playerid, COLOR_WHITE, "| {0080ff}TAKE{ffffff} |");
		Send(playerid, COLOR_WHITE, "* »спользуйте: /take [id] [name]");
		Send(playerid, COLOR_GREY, "*  Ћицензии: drivinglic, flyinglic, sailinglic, weaponlic");
		Send(playerid, COLOR_WHITE, "|______________________________|");
	}
	return 1;
}

CMD:music(playerid, params[]) {
	if(Pl::Info[playerid][pCDPlayer] <= 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет CD-плейера!");
	dialog[0] = '\0';
	for(new i; i < sizeof(RadioInfo); i++) {
		scf(dialog, temp, "Х %s\n", RadioInfo[i][rName]);
	}
	return SPD(playerid, D_RADIO+1, DIALOG_STYLE_LIST, "FM Player", dialog, "SELECT", "CANCEL");
}

CMD:service(playerid, params[]) {
	SPD(playerid, D_SERVICE, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": SERVICE", "“акси\nћедик\nћеханик", "SELECT", "CANCEL");
	return true;
}

CMD:tie(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAMafia(playerid) && !IsAGang(playerid) && Pl::FracID(playerid) != 8) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pRank] < 3) return Send(playerid, COLOR_GREY, "* ¬аш ранг должен быть не меньше 3-го!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /tie [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете св€зать себ€!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы должны быть в одной машине!");
	if(!IsPlayerInRangeOfPlayer(playerid, 4.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");
	if(PlayerTied[params[0]]) return Send(playerid, COLOR_GREY, "* Ётот игрок уже св€зан!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы были св€заны %s.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы св€зали %s.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s св€зывает %s.", sendername, playername);
	ProxDetector(15.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Rac::TogglePlayerControllable(params[0], 0); PlayerTied[params[0]] = true;
	GameTextForPlayer(params[0], "~r~Tied", 3000, 3);

	return 1;
}

CMD:untie(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAMafia(playerid) && !IsAGang(playerid) && Pl::FracID(playerid) != 8) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pRank] < 3) return Send(playerid, COLOR_GREY, "* ¬аш ранг должен быть не меньше 3-го!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /untie [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете разв€зать себ€!");
	if(!PlayerTied[params[0]]) return Send(playerid, COLOR_GREY, "* Ётот игрок не св€зан!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы должны быть в одной машине!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы были разв€заны %s.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы разв€занны %s.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s разв€зал %s", sendername, playername);
	ProxDetector(10.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Rac::TogglePlayerControllable(params[0], 1); PlayerTied[params[0]] = false;
	GameTextForPlayer(params[0], "~g~Untied", 3000, 3);

	return 1;
}

CMD:steal(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAMafia(playerid) && !IsAGang(playerid) && Pl::FracID(playerid) != 8) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pRank] < 3) return Send(playerid, COLOR_GREY, "* ¬аш ранг должен быть не меньше 3-го!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /steal [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* Ќельз€ ограбить себ€!");
	if(!PlayerTied[params[0]]) return Send(playerid, COLOR_GREY, "* »грок не св€зан!");
	if(GrabPer[params[0]]) return Send(playerid, COLOR_GREY, "* Ётого игрока уже грабили!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы должны быть в одной машине!");
	if(20000 > Rac::GetPlayerMoney(params[0])) return  Send(playerid,COLOR_GREY,"* ≈го нельз€ обворовать!");

	new rmoney = Rac::GetPlayerMoney(params[0])/4;
	Rac::GivePlayerMoney(params[0], -rmoney);
	Rac::GivePlayerMoney(playerid, rmoney);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* %s украл у вас %d$", sendername,rmoney);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы украли у %s %d$.", playername,rmoney);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s обворовал %s", sendername, playername);
	ProxDetector(10.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	GrabPer[params[0]] = true;
	return 1;
}

CMD:gag(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAMafia(playerid) && !IsAGang(playerid) && Pl::FracID(playerid) != 8) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pRank] < 3) return Send(playerid, COLOR_GREY, "* ¬аш ранг должен быть не меньше 3-го!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /gag [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* Ќельз€ вставить кл€п себе!");
	if(!PlayerTied[params[0]]) return Send(playerid, COLOR_GREY, "* »грок не св€зан!");
	if(Gag[params[0]]) return Send(playerid, COLOR_GREY, "* ” этого игрока уже есть кл€п во рту!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы должны быть в одной машине!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* %s запихнул вам кл€п в рот", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы запихнули кл€п в рот %s.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s запихивает кл€п в рот %s", sendername, playername);
	ProxDetector(10.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Gag[params[0]]=true; GameTextForPlayer(params[0], "~r~Gaged", 3000, 3);
	return 1;
}

CMD:ungag(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsAMafia(playerid) && !IsAGang(playerid) && Pl::FracID(playerid) != 8) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(Pl::Info[playerid][pRank] < 3) return Send(playerid, COLOR_GREY, "* ¬аш ранг должен быть не меньше 3-го!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /ungag [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* Ќельз€ вставить кл€п себе!");
	if(!PlayerTied[params[0]]) return Send(playerid, COLOR_GREY, "* »грок не св€зан!");
	if(!Gag[params[0]]) return Send(playerid, COLOR_GREY, "* ” этого игрока нет кл€па во рту!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы должны быть в одной машине!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* %s вытащил из вашего рта кл€п", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы вытащили кл€п изо рта %s.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s вытаскивает кл€п изо рта %s ", sendername, playername);
	ProxDetector(10.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Gag[params[0]]=false; GameTextForPlayer(params[0], "~g~Ungaged", 3000, 3);
	return 1;
}

CMD:towcar(playerid, params[]) { new string[144];
	new house = Pl::Info[playerid][pHouseKey];
	if(!IsPlayerHouseOwner(playerid, house)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
	new bidx = GetIndexFromBizID(Bizz_HouseService);
	if(BizzInfo[bidx][bProds] == 0) return GameTextForPlayer(playerid, "~r~Out Of Stock", 5000, 1);
	if(Rac::GetPlayerMoney(playerid) < BizzInfo[bidx][bEnterCost]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет столько денег!");
	if(GetVehiclePassengers(HouseInfo[house][hAuto])) return GameTextForPlayer(playerid, "~w~Car is~n~in ~r~use", 5000, 1);

	SetVehicleToRespawn(HouseInfo[house][hAuto]);
	Rac::GivePlayerMoney(playerid,-BizzInfo[bidx][bEnterCost]);
	GiveBizzProfit(bidx, BizzInfo[bidx][bEnterCost]);
	BizzInfo[bidx][bProds]--;
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	format(string, sizeof string, "~w~Car~n~~g~Towed Home~n~~r~-$%d", BizzInfo[bidx][bEnterCost]);
	GameTextForPlayer(playerid, string, 5000, 1);

	return 1;
}

CMD:fare(playerid, params[]) { new string[144];
	if(Pl::FracID(playerid) != 10 && Pl::Info[playerid][pJob] != 9) return Send(playerid,COLOR_GREY,"* ¬ы не “аксист / ¬одетель јвтобуса!");
	new Veh = GetPlayerVehicleID(playerid);
	if(TransportDuty[playerid] > 0) {
		TaxiDrivers --;
		TransportDuty[playerid] = 0;
		DestroyDynamic3DTextLabel(AttachText[Veh]);
		DestroyDynamicRaceCP(checkpointb[playerid]);
		Rac::GivePlayerMoney(playerid, TransportMoney[playerid]);
		format(string, sizeof string, "* ¬ы заработали $%d", TransportMoney[playerid]);
		Send(playerid, COLOR_LIGHTBLUE, string);
		TransportValue[playerid] = 0;
		TransportMoney[playerid] = 0;
	}
	else if(IsATaxiCar(Veh)) {
		if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY, "* ¬ы не водитель!");
		if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /fare [price]");
		if(params[0] < 1 || params[0] > 1000) return Send(playerid, COLOR_GREY, " * ѕлата не должна быть меньше $1 и не должна превышать $1000!");
		TaxiDrivers ++;
		TransportDuty[playerid] = 1;
		TransportValue[playerid] = params[0];
		GetPlayerName(playerid, plname, 24);
		DestroyDynamic3DTextLabel(AttachText[Veh]);
		format(string, sizeof string, "її S.A.T.C.C ЂЂ\n«а рулем: %s\n“ариф: $%d", plname, TransportValue[playerid]);
		AttachText[Veh] = Add3DText(string, COLOR_TAXI_PRICE, 0.0, 0.0, 1.3, 20.0, INVALID_PLAYER_ID, Veh, 0, 0, 0, -1);
	}
	else if(IsABusCar(Veh)) {
		if(GetPlayerState(playerid) != 2) return Send(playerid, COLOR_GREY, "* ¬ы не водитель!");
		if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /fare [price]");
		if(params[0] < 1 || params[0] > 1000) return Send(playerid, COLOR_GREY, " * ѕлата не должна быть меньше $1 и не должна превышать $1000!");

		BusDrivers ++;
		TransportDuty[playerid] = 2;
		TransportValue[playerid] = params[0];

		DestroyDynamicRaceCP(checkpointb[playerid]);
		DestroyDynamic3DTextLabel(AttachText[Veh]);

		dialog[0]='\0';
		for(new i; i < sizeof BusRoute; i++) {
			scf(dialog, string, "%s "#_GREY_ARROW" %s\n", BusRoute[i][0][stopName], BusRoute[i][BusRouteCount[i]-1][stopName]);
		}
		SPD(playerid, D_FARE, DIALOG_STYLE_LIST, "¬ыбирете маршрут", dialog, "SELECT", "CANCEL");
	}
	return 1;
}

CMD:licenses(playerid, params[]) { new string[144];
	static const lic[][] = { "ќтсутствует", "»меютс€" };
	Send(playerid, COLOR_WHITE, "____________| Licenses |____________");
	sendf(playerid, string, COLOR_GREY, "** ¬одительские права: *%s.", lic[Pl::Info[playerid][pLic][0]]);
	sendf(playerid, string, COLOR_GREY, "** Ћицензи€ на полеты в штате: *%s.", lic[Pl::Info[playerid][pLic][1]]);
	sendf(playerid, string, COLOR_GREY, "** Ћицензи€ на морской транспорт: *%s.", lic[Pl::Info[playerid][pLic][2]]);
	sendf(playerid, string, COLOR_GREY, "** Ћицензи€ на оружие: *%s.", lic[Pl::Info[playerid][pLic][3]]);
	sendf(playerid, string, COLOR_GREY, "** Ћицензи€ на рыбалку: *%s.", lic[Pl::Info[playerid][pLic][4]]);
	Send(playerid, COLOR_WHITE, "||");
	return 1;
}

CMD:sl(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /sl [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете показать лицензии себе. »спользуйте: /licenses!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* »грок не около вас!");
	getname(playerid -> sendername, params[0] -> playername);

	static const lic[][] = { "ќтсутствует", "»меютс€" };
	sendf(params[0], string, COLOR_WHITE, "____________| Ћицензии %s |____________", sendername);
	sendf(params[0], string, COLOR_GREY, "** ¬одительские права: *%s.", lic[Pl::Info[playerid][pLic][0]]);
	sendf(params[0], string, COLOR_GREY, "** Ћицензи€ на полеты в штате: *%s.", lic[Pl::Info[playerid][pLic][1]]);
	sendf(params[0], string, COLOR_GREY, "** Ћицензи€ на морской транспорт: *%s.", lic[Pl::Info[playerid][pLic][2]]);
	sendf(params[0], string, COLOR_GREY, "** Ћицензи€ на оружие: *%s.", lic[Pl::Info[playerid][pLic][3]]);
	sendf(params[0], string, COLOR_GREY, "** Ћицензи€ на рыбалку: *%s.", lic[Pl::Info[playerid][pLic][4]]);
	sendf(params[0], string, COLOR_LIGHTBLUE, "* %s показал(а) вам свои лицензии.", sendername);
	sendf(playerid,  string, COLOR_LIGHTBLUE, "* ¬ы показали свои лицензии %s.", playername);
	return 1;
}

CMD:pas(playerid, params[]) { new string[144];
	if(!Pl::Info[playerid][pPasport][0]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет паспорта!");
	if(sscanf(params, "u", params[0])) return ShowPass(playerid, playerid, D_NONE);
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не р€дом с вами!");
	ShowPass(playerid, params[0], D_NONE);
	if(playerid != params[0]) {
		format(string, sizeof string, "* %s показал свой паспорт вам.", GetName(playerid));
		Send(params[0], COLOR_LIGHTBLUE, string);
	}
	return 1;
}

CMD:frisk(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_WHITE, "¬ведите: /frisk [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "¬ы не можете ќбыскать себ€!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около ¬ас!");

	dialog[0]='\0';
	strcat(dialog, Pl::Info[params[0]][pDrugs] 	 > 0 ? (""#_GREY_ARROW" Ќаркотики\n") : (""#_GREY_ARROW" ѕусто\n"));
	strcat(dialog, Pl::Info[params[0]][pMats]      > 0 ? (""#_GREY_ARROW" ћатериалы\n") : (""#_GREY_ARROW" ѕусто\n"));
	strcat(dialog, Pl::Info[params[0]][pCDPlayer]  > 0 ? (""#_GREY_ARROW" CD-плейер\n") : (""#_GREY_ARROW" ѕусто\n"));
	strcat(dialog, Pl::Info[params[0]][pPhoneBook] > 0 ? (""#_GREY_ARROW" “елефонна€ книга\n") : (""#_GREY_ARROW" ѕусто\n"));
	scf(dialog, string, ""#_GREY_ARROW" Ќаличные: %d$\n", Rac::GetPlayerMoney(params[0]));
	strcat(dialog, "{888888}ї\n{888888}їїїїїїїїїїїїї[{FFFFFF}ќружие{888888}]їїїїїїїїїїїї\n");

	new weapon, ammo, WeapName[40];
	for(new i = 0; i < 12; i++) {
		GetPlayerWeaponData(params[0], i, weapon, ammo);
		if(weapon != 0) {
			GetWeaponName(weapon, WeapName, sizeof WeapName);
			scf(dialog, string,""#_GREY_ARROW" %s | ѕатроны: %i\n",WeapName, ammo);
		}
	}
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, " арманы %s", playername);
	SPD(playerid, D_NONE, DIALOG_STYLE_LIST, string, dialog, "CANCEL", "");

	format(string, sizeof string, "* %s обыскал %s", sendername, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	return 1;
}

CMD:sellcar(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pJob] != 8) return Send(playerid,COLOR_GREY,"* ¬ы не јгент по продаже легковых автомобилей!");
	if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid,COLOR_GREY,"* ¬ы не находитесь в атомобиле!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /sellvcar [playerid] [price]");
	if(params[1] < 1 || params[1] > 99999) return Send(playerid, COLOR_GREY, "* ÷ена не ниже 1$ и не выше 99999$ !");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете продать себе автомобиль!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");
	if(CarCalls[params[0]] > 0) return Send(playerid, COLOR_GREY, "* Ётот игрок уже купил автомобиль, он должен использовать /callcar сначала !");
	format(string, sizeof string, "* ¬ы собираетесь продавать %s игроку машину за $%d .", GetName(params[0]), params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* јгент по продаже легковых автомобилей %s хочет продать ¬ам свой автомобиль за $%d, (тип /accept car) покупка.", GetName(playerid), params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	CarOffer[params[0]] = playerid;
	CarPrice[params[0]] = params[1];
	CarID[params[0]] = GetPlayerVehicleID(playerid);
	return 1;
}

CMD:mats(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pJob] != 7) return Send(playerid, COLOR_GREY, "* ¬ы не гандилер!");
	if(sscanf(params, "s[10]I(0)", temp, params[0])) {
		Send(playerid, COLOR_WHITE, "¬ведите: /mats [name]");
		Send(playerid, COLOR_WHITE, "* ƒоступные названи€: Get, Deliver.");
	} else {
		if(strcmp(temp, "get", false) == 0) {
			if(params[0] < 1 || params[0] > 10) return Send(playerid, COLOR_GREY, "* „исло ѕакета не может быть ниже 1 или выше 10!");
			if(!IsPlayerInRangeOfPoint(playerid,3.0,597.3430,-1248.6998,18.2804)) return Send(playerid, COLOR_GREY, "* ¬ы не в «дании ѕакетов ћатериалов в Ћос —антусе!");
			if(MatsHolding[playerid] >= 10) return Send(playerid, COLOR_GREY, "* ћаксимум можно вз€ть 10 пакетов!");
			new price = (params[0] * 100);
			if(Rac::GetPlayerMoney(playerid) < price) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денеег!");
			new bidx = GetIndexFromBizID(Bizz_RifaSklad);
			Rac::GivePlayerMoney(playerid, -price);
			MatsHolding[playerid] = params[0];
			GiveBizzProfit(bidx, price+1000);
			format(string, sizeof string, "* ¬ы купили %d пакетов материалов за $%d.", params[0], price);
			Send(playerid, COLOR_LIGHTBLUE, string);

		} else if(strcmp(temp, "deliver", false) == 0) {
			if(!IsPlayerInRangeOfPoint(playerid,3.0,-2115.7246,-78.0859,35.3203)) return Send(playerid, COLOR_GREY, "* ¬ы не на ‘абрике материалов в —ан ‘иеро!");
			if(MatsHolding[playerid] <= 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет матов!");
			new bidx = GetIndexFromBizID(Bizz_RifaSklad);
			new payout = (50 * MatsHolding[playerid]);
			if(BizzInfo[bidx][bProds] < payout) return Send(playerid, COLOR_GREY, "* Ќа фабрике в данный момент нет материалов!");
			format(string, sizeof string, "* ‘абрика дала ¬ам %d материалов дл€ ваших %d пакетов материалов.", payout, MatsHolding[playerid]);
			BizzInfo[bidx][bProds] -= payout;
			Pl::Info[playerid][pMats] += payout;
			MatsHolding[playerid] = 0;
			Send(playerid, COLOR_LIGHTBLUE, string);

		} else {
			Send(playerid, COLOR_WHITE, "* ƒоступные названи€: Get, Deliver.");
		}
	}
	return 1;
}

CMD:buymats(playerid, params[]) { new string[144];
	if(Pl::FracID(playerid) != 17) return Send(playerid, COLOR_GREY, "* ¬ы не можите покупать материалы!");
	new tmpcar = GetPlayerVehicleID(playerid);
	if(GetVehicleModel(tmpcar) != 482) return Send(playerid, COLOR_GREY, "* Ётот транспорт не приднозначен дл€ перивозки материалов!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /buymats [кол-во матов]");
	if(!IsPlayerInRangeOfPoint(playerid,25.0, 2801.3, -2356.3, 13.3)) return Send(playerid, COLOR_GREY, "* ¬ы не в доках Ћос —антоса!");
	if(!IsATruckrifa(tmpcar)) return Send(playerid, COLOR_GREY, "* Ёта машина не предназначина дл€ перевозки материалов!");
	if(AutoInfo[tmpcar][aMats] >= AutoInfo[tmpcar][aMaxMats]) return Send(playerid, COLOR_GREY, "* Ёта машина перегружена!");
	if(GetPlayerState(playerid) != 2) {
		format(string, sizeof string, "* ћатериалы: %d/%d.", AutoInfo[tmpcar][aMats], AutoInfo[tmpcar][aMaxMats]);
		return Send(playerid, COLOR_LIGHTGREEN, string);
	}
	if(params[0] > 2000) return Send(playerid,COLOR_GREY,"* Ѕольше 2000 материалов возить нельз€!");
	params[2] = params[0]*10;
	if(Rac::GetPlayerMoney(playerid) < params[2]) return Send(playerid,COLOR_GREY,"* ” ¬ас нехватает денег!");
	if(AutoInfo[tmpcar][aMats]+params[0] > AutoInfo[tmpcar][aMaxMats]) return Send(playerid,COLOR_GREY,"* «а один раз можно везти 2000 материалов!");
	AutoInfo[tmpcar][aMats] += params[0];
	format(string, sizeof string, "* ћатериалы: %d/%d.", AutoInfo[tmpcar][aMats], AutoInfo[tmpcar][aMaxMats]);
	Send(playerid, COLOR_GREEN, string);
	format(string, sizeof string, "* ¬ы вз€ли %d материалов за $%d.", AutoInfo[tmpcar][aMats], params[2]);
	Send(playerid, COLOR_GREEN, string);
	Rac::GivePlayerMoney(playerid,-params[2]);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	return 1;
}

CMD:sellmats(playerid, params[]) { new string[144];
	if(Pl::FracID(playerid) != 17) return Send(playerid, COLOR_GREY, "* ¬ы не можите продавать материалы!");
	if(!IsPlayerInRangeOfPoint(playerid,25.0,-2115.4,-175.8,35.3)) return Send(playerid, COLOR_GREY, "* ¬ы  не в месте продажи материалов!");
	new tmpcar = GetPlayerVehicleID(playerid);
	if(GetPlayerState(playerid) != 2) return Send(playerid,COLOR_LIGHTRED2,"* ¬ы не водитель!");
	if(AutoInfo[tmpcar][aMats] <= 0) return Send(playerid,COLOR_LIGHTRED2,"* ¬ вашей машине нету материалов!");
	new bidx = GetIndexFromBizID(Bizz_RifaSklad);
	if(BizzInfo[bidx][bProds] >= BizzInfo[bidx][bMaxProds]) return Send(playerid, COLOR_GREY, "* ‘абрика переполнена!");
	new cash = AutoInfo[tmpcar][aMats]*17;
	BizzInfo[bidx][bProds] += AutoInfo[tmpcar][aMats];
	format(string, sizeof string, "* ¬ы продали %d материалов фабрике за $%d", AutoInfo[tmpcar][aMats], cash);
	Send(playerid, COLOR_GREEN, string);
	Rac::GivePlayerMoney(playerid, cash);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	AutoInfo[tmpcar][aMats] = 0;
	return 1;
}

CMD:buyprods(playerid, params[]) { new string[144];
	if(sscanf(params, "i", params[0])) {
		Send(playerid, COLOR_GREY, "¬ведите: /buyprods [amount]");
	} else {
		if(params[0] < 1 || params[0] > 150) {
			Send(playerid, COLOR_GREY, "* Ќельз€ купить меньше 1-го продукта или более 150-ти");
		} else {
			new vehid = GetPlayerVehicleID(playerid);
			if(vehid && GetPlayerState(playerid) == 2) {
				if(IsACompTruck(vehid)) {
					if(PlayerHaul[vehid-comptruck[0]][pLoad] < PlayerHaul[vehid-comptruck[0]][pCapasity]) {
						foreach(new i : Biznes) {
							if(IsPlayerInSquare2D(playerid, 50.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], 0)) {
								if(BizzInfo[i][bID] == Bizz_ProdSkladLS || BizzInfo[i][bID] == Bizz_ProdSkladSF) {
									new check = PlayerHaul[vehid-comptruck[0]][pLoad] + params[0];
									if(check > PlayerHaul[vehid-comptruck[0]][pCapasity]) {
										Send(playerid, COLOR_GREY, "* —только не влезит в грузовик!");
									} else {
										new cost = params[0]*50;
										if(Rac::GetPlayerMoney(playerid) >= cost) {
											PlayerHaul[vehid-comptruck[0]][pLoad] += params[0];
											format(string, sizeof string, "* ¬ы купили %d продуктов за $%d.", params[0], cost);
											Send(playerid, COLOR_GREEN, string);
											Rac::GivePlayerMoney(playerid,-cost);
											PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
										} else {
											format(string, sizeof string, "¬ы не можете позволить себе %d продуктов за $%d!", params[0], cost);
											Send(playerid, COLOR_GREEN, string);
										}
									}
									return 1;
								}
							}
						}
					} else {
						Send(playerid,COLOR_GREY,"* √рузовик полон!");
					}
				} else {
					Send(playerid,COLOR_GREY,"* ¬ы должны быть в грузовике дл€ развоза продуктов");
				}
			} else {
				Send(playerid,COLOR_GREY,"* ¬ы должны быть в грузовике дл€ развоза продуктов");
			}
		}
	}
	return 1;
}

CMD:sellprods(playerid, params[]) { new string[144];
	new vehid = GetPlayerVehicleID(playerid);
	if(vehid && GetPlayerState(playerid) == 2) {
		if(IsACompTruck(vehid)) {
			if(PlayerHaul[vehid-comptruck[0]][pLoad] <= 0) {
				GameTextForPlayer(playerid, "~r~Truck is empty, return to the stock house", 5000, 1);
			} else {
				foreach(new i : Biznes) {
					if(IsPlayerInRangeOfPoint(playerid, 10.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2])) {
						if(BizzInfo[i][bID] != 56 && BizzInfo[i][bID] != 74 && BizzInfo[i][bID] != 47) {
							new cashmade;
							for(new l = PlayerHaul[vehid-comptruck[0]][pLoad]; l > 0; l--) {
								if(BizzInfo[i][bProds] == BizzInfo[i][bMaxProds]) {
									GameTextForPlayer(playerid, "~r~Our stores are full", 5000, 1);
									format(string, sizeof string, "«аработано: $%d.", cashmade);
									Send(playerid, COLOR_GREEN, string);
									PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
									return 1;
								}
								if(BizzInfo[i][bPriceProd] > BizzInfo[i][bSafe]) {
									GameTextForPlayer(playerid, "~r~We Cant Afford The Deal", 5000, 1);
									format(string, sizeof string, "«аработано: $%d.", cashmade);
									Send(playerid, COLOR_GREEN, string);
									PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
									return 1;
								}
								BizzInfo[i][bProds]++;
								PlayerHaul[vehid-comptruck[0]][pLoad]--;
								cashmade = cashmade+BizzInfo[i][bPriceProd];
								Rac::GivePlayerMoney(playerid,BizzInfo[i][bPriceProd]);
								BizzInfo[i][bSafe] -= BizzInfo[i][bPriceProd];
								if(PlayerHaul[vehid-comptruck[0]][pLoad] == 0) {
									GameTextForPlayer(playerid, "~r~Truck is empty, return to the stock house", 5000, 1);
									format(string, sizeof string, "«аработано: $%d.", cashmade);
									Send(playerid, COLOR_GREEN, string);
									PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
									return 1;
								}
							}
						}
						return 1;
					}
				}
			}
		} else {
			Send(playerid,COLOR_GREY,"* ¬ы должны быть в грузовике дл€ развоза продуктов");
		}
	} else {
		Send(playerid,COLOR_GREY,"* ¬ы должны быть в грузовике дл€ развоза продуктов");
	}
	return 1;
}

CMD:loadmats(playerid, params[]) { new string[144];
	new bidx = GetIndexFromBizID(Bizz_RifaSklad);
	format(string, sizeof string, "* Ќа фабрике %i/%i материалов.",
	BizzInfo[bidx][bProds], BizzInfo[bidx][bMaxProds]);
	Send(playerid, COLOR_GREEN, string);
	return 1;
}

CMD:loadmac(playerid, params[]) { new string[144];
	if(!isPlayerInPickup(playerid,barn[0])) return Send(playerid,COLOR_LIGHTRED2,"* ¬ы не у амбара!");
	format(string, sizeof string, "* ¬ амбаре %d грамм", Gm::Info[Gm::AmbarDrugs]);
	Send(playerid,COLOR_LIGHTBLUE,string);
	format(string, sizeof string, "* ¬ притоне %d грамм", Gm::Info[Gm::PritonDrugs]);
	Send(playerid,COLOR_LIGHTBLUE,string);

	return 1;
}

CMD:sellgun(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::Info[playerid][pJob] != 7) return Send(playerid,COLOR_GREY,"* ¬ы не √андилер!");
	if(sscanf(params, "s[15]u", temp, params[0])) {
		return ShowDialog(playerid, D_NONE, 0, "Х SellGun Х Info", "dialog/sellgun.txt", "OK", "");
	}
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* ¬ы долеко от этого игрока!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете продать оружие себе!");
	new weapon, ammo, price;
	getname(playerid->sendername,params[0]->playername);
	if(!GetGunInfo(temp, weapon, ammo, price)) return Send(playerid,COLOR_GREY,"* Ќедействительное название оружи€!");
	if(price > Pl::Info[playerid][pMats]) return Send(playerid,COLOR_GREY,"* Ќедостаточно материалов дл€ этого оружи€!");
	Rac::GivePlayerWeapon(params[0], weapon, ammo);
	Pl::Info[playerid][pMats] -= price;

	format(string, sizeof string, "* ¬ы дали %s, %s с %i боеприпасами, дл€ %i материалов.", playername, temp, ammo, price);
	Send(playerid, COLOR_GREY, string);
	PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
	format(string, sizeof string, "* ¬ы получили %s с %i боеприпасами от %s.", temp, ammo, sendername);
	Send(params[0], COLOR_GREY, string);
	PlayerPlaySound(params[0], 1052, 0.0, 0.0, 0.0);
	format(string, sizeof string, "* %s вз€л оружие из материалов, и передал в руки %s.", sendername, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);

	return 1;
}

CMD:get(playerid, params[]) { new string[144];
	if(sscanf(params, "s[16]I(0)", params[1], params[0])) {
		Send(playerid, COLOR_WHITE, " {0080ff}ѕолучить{ffffff} ");
		Send(playerid, COLOR_GREY, "¬ведите: /get [name]");
		Send(playerid, COLOR_GREY, " ƒоступные названи€: Drugs, Fuel");
	} else {
		if(strcmp(params[1], "drugs", false) == 0) {
			if(Pl::Info[playerid][pJob] != 4) return Send(playerid, COLOR_GREY, "* ¬ы не наркодилер!");
			if(Pl::Info[playerid][pDrugs] > 15) return Send(playerid, COLOR_GREY, "* ” ¬ас уже есть наркотики, продаете их сначала!");
			if(!IsPlayerInRangeOfPoint(playerid, 2.0, 323.0342,1118.5804,1083.8828)) return Send(playerid, COLOR_GREY, "* ¬ы не в притоне!");
			if((Gm::Info[Gm::PritonDrugs] - params[0]) < 0) return Send(playerid, COLOR_GREY,"* ¬ притоне нехватает наркотиков.");
			new tel, price;
			switch(Pl::Info[playerid][pSkill][7]) {
			case 0..50 : {
					tel = 200;
					if(params[0] < 1 || params[0] > 6) return Send(playerid, COLOR_GREY, "* ¬ы можете с собой носить от 1 до 6 граммов наркотиков");
				}
			case 51..100 : {
					tel = 150;
					if(params[0] < 1 || params[0] > 12) return Send(playerid, COLOR_GREY, "* ¬ы можете с собой носить от 1 до 12 граммов наркотиков!");
				}
			case 101..200 : {
					tel = 100;
					if(params[0] < 1 || params[0] > 20) return Send(playerid, COLOR_GREY, "* ¬ы можете с собой носить от 1 до 20 граммов наркотиков");
				}
			case 201..400 : {
					tel = 50;
					if(params[0] < 1 || params[0] > 30) return Send(playerid, COLOR_GREY, "* ¬ы можете с собой носить от 1 до 30 граммов наркотиков");
				}
			case 401 : {
					tel = 10;
					if(params[0] < 1 || params[0] > 99) return Send(playerid, COLOR_GREY, "* ¬ы можете с собой носить от 1 до 99 граммов наркотиков");

				}
			}
			price = ( params[0] * tel );
			if(Rac::GetPlayerMoney(playerid) < price) return Send(playerid, COLOR_GREY, "* ” ¬ас нехватает денег");
			format(string, sizeof string, "* ¬ы купили %d грамм за $%d.", params[0], price);
			Send(playerid, COLOR_LIGHTBLUE, string);
			Rac::GivePlayerMoney(playerid, -price);
			Pl::Info[playerid][pDrugs] = Pl::Info[playerid][pDrugs] + params[0];
			Gm::Info[Gm::PritonDrugs] -= params[0];

		} else if(strcmp(params[1], "fuel", false) == 0) {
			new gas;
			if((gas = GetClosestGas(playerid)) == -1) return Send(playerid,COLOR_GREY,"* ¬ы не на бензоколонке!");
			if(Rac::GetPlayerMoney(playerid) < 40) return Send(playerid,COLOR_GREY,"* ” ¬ас не хватает денег!");
			new bidx = GetIndexFromBizID(RefillInfo[gas][brBizID]);
			if(BizzInfo[bidx][bProds] <= 0) return GameTextForPlayer(playerid, "~r~Out of stock", 5000, 1);
			BizzInfo[bidx][bProds]--;
			GiveBizzProfit(bidx, 40);
			Pl::Info[playerid][pFuel] = 20;
			Rac::GivePlayerMoney(playerid, -40);
			Send(playerid, COLOR_LIGHTBLUE, "* ¬ы вз€ли 20 литровую канистру бензина за $40");
		} else {
			Send(playerid, COLOR_WHITE, " {0080ff}ѕолучить{ffffff} ");
			Send(playerid, COLOR_GREY, "¬ведите: /get [name]");
			Send(playerid, COLOR_GREY, " ƒоступные названи€: Drugs, Fuel");
		}
	}
	return 1;
}

CMD:fillcar(playerid, params[]) {
	if(Pl::Info[playerid][pFuel] <= 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет конистры с бензином!");
	if(AutoInfo[gLastCar[playerid]][aFuel] > 81.0) return Send(playerid, COLOR_GREY, "* ¬аш јвтомобиль заправлен, удачного пути!");
	Send(playerid, COLOR_LIGHTBLUE, "¬ы заполнили ваш автомобиль на 20 процентов");
	AutoInfo[gLastCar[playerid]][aFuel] += 20.0;
	Pl::Info[playerid][pFuel] = 0;
	return 1;
}

CMD:henter(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /houseenter [houseid]");
	if(!IsValidHouse(params[0])) return Send(playerid,COLOR_RED,"* Ќеверный ид дома");
	GetPlayerPos(playerid, HouseInfo[params[0]][hEnter][0], HouseInfo[params[0]][hEnter][1], HouseInfo[params[0]][hEnter][2]);
	GetPlayerFacingAngle(playerid, HouseInfo[params[0]][hEnter][3]);

	DestroyDynamicPickup(HouseInfo[params[0]][hPickup]);
	DestroyDynamicMapIcon(HouseInfo[params[0]][hMapIcon]);
	if(HouseInfo[params[0]][hOwned] == 1) {
		HouseInfo[params[0]][hPickup] = AddPickup(1318, 23, HouseInfo[params[0]][hEnter][0], HouseInfo[params[0]][hEnter][1], HouseInfo[params[0]][hEnter][2]);
		HouseInfo[params[0]][hMapIcon] = CreateDynamicMapIcon(HouseInfo[params[0]][hEnter][0], HouseInfo[params[0]][hEnter][1], HouseInfo[params[0]][hEnter][2],32,0,-1,-1,-1,350.0);
	} else {
		HouseInfo[params[0]][hPickup] = AddPickup(1273, 23, HouseInfo[params[0]][hEnter][0], HouseInfo[params[0]][hEnter][1], HouseInfo[params[0]][hEnter][2]);
		HouseInfo[params[0]][hMapIcon] = CreateDynamicMapIcon(HouseInfo[params[0]][hEnter][0], HouseInfo[params[0]][hEnter][1], HouseInfo[params[0]][hEnter][2],31,0,-1,-1,-1,350.0);
	}
	format(string,sizeof string,"* ¬ход дома є%i был перенесен в %.3f, %.3f, %.3f координаты.", params[0], HouseInfo[params[0]][hExit][0], HouseInfo[params[0]][hExit][1], HouseInfo[params[0]][hExit][2]);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:hexit(playerid, params[]) { new string[144];
	if(!Pl::isLogged(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не залогинены!");
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "* ¬ведите: /houseeexit [houseid]");
	if(!IsValidHouse(params[0])) return Send(playerid,COLOR_RED,"* Ќеверный ID дома");

	GetPlayerPos(playerid, HouseInfo[params[0]][hExit][0], HouseInfo[params[0]][hExit][1], HouseInfo[params[0]][hExit][2]);
	GetPlayerFacingAngle(playerid, HouseInfo[params[0]][hExit][3]);
	HouseInfo[params[0]][hInt] = GetPlayerInterior(playerid);
	SetPlayerVirtualWorld(playerid, params[0]);
	format(string,sizeof string,"* ¬ыход дома є%i был перенесен в %.3f, %.3f, %.3f координаты.", params[0], HouseInfo[params[0]][hExit][0], HouseInfo[params[0]][hExit][1], HouseInfo[params[0]][hExit][2]);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:bizicon(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "iiI(0)", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "* ¬ведите: /bizenter [bizid] [iconid]");
	if(!IsValidBiz(params[0])) return Send(playerid,COLOR_WHITE,"* Ќеправильный id бизнеса!");
	new bidx = GetIndexFromBizID(params[0]);
	BizzInfo[bidx][bIcon][params[2]] = params[1];
	UpdateBizzPickups(bidx);
	Send(playerid, COLOR_YELLOW, "* »конка была изменина!");
	return 1;
}

CMD:bizenter(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "* ¬ведите: /bizenter [bizid]");
	if(!IsValidBiz(params[0])) return Send(playerid,COLOR_WHITE,"* Ќеправильный id бизнеса!");

	new bidx = GetIndexFromBizID(params[0]);
	GetPlayerPos(playerid, BizzInfo[bidx][bEnter][0], BizzInfo[bidx][bEnter][1], BizzInfo[bidx][bEnter][2]);
	GetPlayerFacingAngle(playerid, BizzInfo[bidx][bEnter][3]);

	// ѕресоздаем гангзону
	Gz::Destroy(BizzInfo[bidx][bZone]);
	GetSquarePos(BizzInfo[bidx][bEnter][0], BizzInfo[bidx][bEnter][1], MAX_ZONE_SIZE, BizzInfo[bidx][bzMinX], BizzInfo[bidx][bzMinY], BizzInfo[bidx][bzMaxX], BizzInfo[bidx][bzMaxY]);
	BizzInfo[bidx][bZone] = Gz::Create(BizzInfo[bidx][bzMinX], BizzInfo[bidx][bzMinY], BizzInfo[bidx][bzMaxX], BizzInfo[bidx][bzMaxY]);
	Gz::ShowForAll(BizzInfo[bidx][bZone], GetFracColor(BizzInfo[bidx][bFrac]));

	// ѕересоздаем пикап и иконку
	UpdateBizzPickups(bidx);
	format(string,sizeof string,"* ¬ход в %d бизнес был перенесен!", BizzInfo[bidx][bID]);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:bizexit(playerid, params[]) {
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "d", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /bizexit [id]!");
	if(!IsValidBiz(params[0])) return Send(playerid,COLOR_WHITE,"* Ќеправильный id бизнеса!");

	new l = GetIndexFromBizID(params[0]);
	GetPlayerPos(playerid, BizzInfo[l][bExit][0], BizzInfo[l][bExit][1], BizzInfo[l][bExit][2]);
	GetPlayerFacingAngle(playerid, BizzInfo[l][bExit][3]);
	BizzInfo[l][bInterior] = GetPlayerInterior(playerid);
	DestroyDynamicPickup(BizzInfo[l][bPickupExit]);
	BizzInfo[l][bPickupExit] = AddPickup(1318, 23, BizzInfo[l][bExit][0], BizzInfo[l][bExit][1], BizzInfo[l][bExit][2], BizzInfo[l][bVirtual]);
	Rac::SetPlayerVirtualWorld(playerid, BizzInfo[l][bVirtual]);
	Send(playerid, COLOR_GREY, "* ѕикап выхода из бизнеса был перенесен!");
	return 1;
}

CMD:bizgang(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "i", params[0])) return Send(playerid, COLOR_GREY, "* ¬ведите: /bizgang [gangid]");
	if(!IsAGangF(params[0])) return Send(playerid,COLOR_LIGHTRED,"Ќеправильный ид банды!");
	foreach(new i : Biznes) {
		if(IsPlayerInSquare2D(playerid, MAX_ZONE_SIZE, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], 0) && !BizzInfo[i][bOnBattle]) {
			GangBiznes{params[0]} ++;
			GangBiznes{BizzInfo[i][bFrac]} --;
			BizzInfo[i][bFrac] = params[0];
			Gz::StopFlashForAll(BizzInfo[i][bZone]);
			Gz::HideForAll(BizzInfo[i][bZone]);
			Gz::ShowForAll(BizzInfo[i][bZone], GetFracColor(params[0]));
			UpdateGangInfo();

			format(string, sizeof string, "* “еперь бизнез будут крышивать %s.", GetGangName(params[0]));
			Send(playerid, COLOR_YELLOW, string);

			return 1;
		}
	}
	return 1;
}

CMD:zahvat(playerid, params[]) { new string[144], sendername[24];
	if(IsAGang(playerid) && GetPlayerState(playerid) == 1) {
		new frac = Pl::FracID(playerid);
		if(Pl::Info[playerid][pRank] < GetZRank(frac) && !IsPlayerLeader(playerid)) {
			format(string, sizeof string, "* ƒл€ захвата бизнеса вам нужен %i-й ранг!", GetZRank(frac));
			Send(playerid, COLOR_LIGHTRED, string);
		} else if(GangOnBattle[frac] != INVALID_BIZ_ID) {
			Send(playerid, COLOR_GREY, "* ¬аша банда уже учавствует в захвате!");
		} else {
			new i = GetClosestBiz(playerid, 3.0);
			if(!IsValidBiz(i)) return Send(playerid, COLOR_GREY, "* Ќет бизнесов поблизости!");
			if(BizzInfo[i][bOnBattle] == 1) return Send(playerid, COLOR_GREY, "* Ѕизнес уже атакован!");
			if(BizzInfo[i][bFrac] == frac) return Send(playerid, COLOR_GREY, "* ¬ы не можете захватывать свой бизнес!");
			if(GangOnBattle[BizzInfo[i][bFrac]] != INVALID_BIZ_ID) {
				format(string, sizeof string, "* Ѕанда %s уже сражаетс€ за другой бизнес!", GetGangName(BizzInfo[i][bFrac]));
				Send(playerid, COLOR_GREY, string);
			} else {
				GangOnBattle[frac] = i;
				ZahvatKills{frac} = 0;
				ZahvatScore[frac] = 0;
				BizzInfo[i][bAttack] = frac;
				BizzInfo[i][bDefend] = BizzInfo[i][bFrac];
				BizzInfo[i][bOnBattle] = 1;
				BizzInfo[i][bZahvatTime] = 240;
				GangOnBattle[BizzInfo[i][bFrac]] = i;
				ZahvatKills{BizzInfo[i][bFrac]} = 0;
				ZahvatScore[BizzInfo[i][bFrac]] = 0;
				CreateZahvatTD(BizzInfo[i][bZahvatTD]);
				SetZahvatMapIcon(i, frac, BizzInfo[i][bFrac]);
				Gz::FlashForAll(BizzInfo[i][bZone], GetFracColor(frac));
				//Td::ShowForFrac(BizzInfo[i][bZahvatTD], BizzInfo[i][bAttack], BizzInfo[i][bDefend]);
				BizzInfo[i][bZahvatTimer] = SetTimerEx("onZahvatBizz", 900, true, "iii", i, frac, BizzInfo[i][bFrac]);
				BizzInfo[i][bZahvatArea] = CreateDynamicSphere(BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], MAX_ZONE_SIZE, 0);
				GetPlayerName(playerid, sendername, 24);
				format(string, sizeof string, "[GANG NEWS] %s[%s] начал захват бизнеса %s, банды[%s]", sendername, GetGangName(frac), BizzInfo[i][bDescription], GetGangName(BizzInfo[i][bFrac]));
				sendToFamily(frac, GetFracColor(frac), string);
				format(string, sizeof string, "[GANG NEWS] „ужие псы напали на вашу территорию [%s], покажите им кто тут хоз€ин!", BizzInfo[i][bDescription]);
				sendToFamily(BizzInfo[i][bFrac], GetFracColor(BizzInfo[i][bFrac]), string);
			}
		}
	}
	return 1;
}

CMD:togwhisper(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, 2) && Pl::Info[playerid][pVip] < 1 && IsPlayerLeader(playerid) <= 0) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	HidePM[playerid] = !HidePM[playerid];
	format(string, sizeof string, "* Ћичные сообщени€ %s!", (HidePM[playerid])?("отключены"):("включены"));
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:vopros(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid) || Pl::Info[playerid][pMuted] == 2) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(sscanf(params, "s[90]", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /вопрос [текст]");
	if(gettime() < VoprosTime[playerid]) return Send(playerid, COLOR_GREY, "* Ќе флуди!");
	VoprosTime[playerid] = gettime()+30;
	SetPVarInt(playerid, "AnsweredHelper", -1);
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "*¬опрос от %s[%d]: %s", sendername, playerid, params[0]);
	SendToHelper(0x10F441AA, string);
	Send(playerid, COLOR_LIGHTRED, string);
	Send(playerid, COLOR_YELLOW, "* ¬аш вопрос отправлен хелперам!");
	return 1;
}

CMD:hduty(playerid, params[]) { new string[144], sendername[24];
	if(!IsPHelper(playerid, 1)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	HelperDuty[playerid] = !HelperDuty[playerid];
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "(( [H] ’елпер %s %s ))", sendername, (HelperDuty[playerid])?("ждет ваши вопросы! (/вопрос)"):("не активен."));
	SendToAll(COLOR_OOC,string);
	return 1;
}

CMD:ans(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(!IsPHelper(playerid, 1)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(!IsAHelperDuty(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не на дежурсиве!");
	if(sscanf(params, "us[90]", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /ans [id/Name] [ответ]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	new answerd = GetPVarInt(params[0], "AnsweredHelper");
	if(answerd == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* Ётот игрок не задавал вопросов!");
	if(answerd != -1 && answerd != playerid) return Send(playerid, COLOR_GREY, "* Ётому игроку уже отвечает хелпер!");
	SetPVarInt(params[0], "AnsweredHelper", playerid);
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "*[H] %s ответил: %s", sendername, params[1]);
	Send(params[0], COLOR_ORANGE, string);
	format(string, sizeof string, "*[H] %s ответил %s[%d]: %s",sendername, playername, params[0], params[1]);
	SendToHelper(COLOR_ORANGE, string);
	return 1;
}

CMD:hc(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid,COLOR_GREY,"* ” ¬ас молчанка!");
	if(!IsPHelper(playerid, 1)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(!IsAHelperDuty(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не на дежурсиве!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GRAD1, "¬ведите: /hc [текст]");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "*%i %s %s: %s", Pl::Info[playerid][pHelper], GetHelperRank(Pl::Info[playerid][pHelper]), sendername, params);
	SendToHelper(COLOR_GREEN, string);
	return 1;
}

CMD:makehelper(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsPHelper(playerid, 3) && !Pl::isAdmin(playerid, 4)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD1, "¬ведите: /makehelper [id] [lvl]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(params[1] < 0 || params[1] > 3) return Send(playerid, COLOR_GREY, "Ќе меньше '0' и не больше '3'.");
	if(params[1] == 0 && Pl::Info[params[0]][pHelper] > 0) Iter::Remove(HelperPlayers, params[0]);
	else if(Pl::Info[params[0]][pHelper] == 0 && params[1] > 0) Iter::Add(HelperPlayers, params[0]);
	getname(playerid -> sendername, params[0] -> playername);
	Pl::Info[params[0]][pHelper] = params[1];
	format(string, sizeof string, "You have been promoted to a level %d helper by %s.", params[1], sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "You are promoted %s to helper level %d.", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:origin(playerid, params[]) {
	SPD(playerid, D_SPAWN, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ORIGIN", "Jefferson Motel\nRock Hotel", "SELECT", "CANCEL");
	return 1;
}

CMD:hirecar(playerid, params[]) { new string[144];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	new vehicle = ClosestVeh(playerid, 3.0);
	if(vehicle == INVALID_VEHICLE_ID) return Send(playerid, COLOR_GREY, "* — вами р€дом нет машин!");
	HireCar[playerid] = vehicle;
	format(string, sizeof string, "* ¬ы сделали ключи дл€ машины %i.", vehicle);
	Send(playerid, COLOR_GRAD4, string);
	Send(playerid, COLOR_WHITE, "* »спользуйте: /lock.");
	return 1;
}

CMD:jack(playerid, params[]) {
	if(Pl::Info[playerid][pJob] == 5)
	{
		if(JobWaitTime[playerid] != 0) return Send(playerid, COLOR_GREY, "* ћашины можно взламывать раз в 3 минуты!");
		if(GetPlayerState(playerid) == 1 && GetPlayerInterior(playerid) == 0)
		{
			new c = ClosestVeh(playerid, 3.0);
			if(c != INVALID_VEHICLE_ID) {
				if(!gCarLock{c}) return Send(playerid, COLOR_GREY, "* Ёта машины уже открыта!");
				ToggleVehicleDoor(c, true);
				JobWaitTime[playerid] = 180;
				PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
				GameTextForPlayer(playerid, "~w~Vehicle ~r~Hacked", 5000, 4);

				params[0] = GetClosestPlayer(playerid, 20.0);
				if(Pl::isLogged(params[0])) {
				    Pl::Info[playerid][pWantedL] += 1;
					SetPlayerCriminal(playerid, 255, "”гон “—");
				}
			}
		}
	}
	return 1;
}

CMD:lock(playerid, params[]) {
	new carid = GetPlayerVehicleID(playerid);
	new houseid = Pl::Info[playerid][pHouseKey];
	if(carid == 0) carid = ClosestVeh(playerid, 3.0);
	if(carid != INVALID_VEHICLE_ID) {
		if(HireCar[playerid] == carid) {
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
			SetPlayerChatBubble(playerid, !gCarLock{carid} ? ("закрыл транспорт") : ("открыл транспорт"), COLOR_YELLOW, 50.0, 5000);
			GameTextForPlayer(playerid, !gCarLock{carid} ? ("~w~Vehicle ~r~Locked") : ("~w~Vehicle ~g~Unlocked"), 5000, 6);
			ToggleVehicleDoor(carid, gCarLock{carid});
		} else if(IsValidHouse(houseid) && HouseInfo[houseid][hAuto] == carid) {
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
			SetPlayerChatBubble(playerid, !gCarLock{carid} ? ("закрыл транспорт") : ("открыл транспорт"), COLOR_YELLOW, 50.0, 5000);
			GameTextForPlayer(playerid, !gCarLock{carid} ? ("~w~Vehicle ~r~Locked") : ("~w~Vehicle ~g~Unlocked"), 5000, 6);
			ToggleVehicleDoor(carid, gCarLock{carid});
		} else {
			new slot = GetIdxExtraVehicleFromVehicleID(playerid, carid);
			if(slot != -1 && ExtraVehicles[playerid][slot][evOwner] == Pl::Info[playerid][pID]) {
				PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
				SetPlayerChatBubble(playerid, !gCarLock{carid} ? ("закрыл транспорт") : ("открыл транспорт"), COLOR_YELLOW, 50.0, 5000);
				GameTextForPlayer(playerid,  !gCarLock{carid} ? ("~w~Vehicle ~r~Locked") : ("~w~Vehicle ~g~Unlocked"), 5000, 6);
				ToggleVehicleDoor(carid, gCarLock{carid});
			} else {
				Send(playerid, COLOR_GREY, "* ” ¬ас нет ключа от этого автомобил€");
			}
		}
	}
	else Send(playerid, COLOR_GREY, "Ќет машин поблизости");

	return 1;
}

CMD:tazer(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	if(IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* Ќельз€ использовать это в автомобиле!");
	if(PlayerUseTazed[playerid]) return Send(playerid, COLOR_GREY,"* ѕользоватс€ тазером можно раз в 8 секунд");
	params[0] = GetClosestPlayer(playerid, 4.0);
	if(params[0] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ќколо вас нет никого!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(IsACop(params[0])) return Send(playerid, COLOR_GREY, "Ќельз€ заэлектрошокить закон!!");
	if(IsPlayerInAnyVehicle(params[0])) return Send(playerid, COLOR_GREY, "* ѕодозреваемый находитс€ в автомобиле, выведити его сначала!");

	getname(playerid -> sendername,params[0] -> playername);
	SetPlayerAttachedObject(playerid, 0, 18642, 6, 0.055994, 0.018028, 0.045403, 348.699523, 154.366394, 0.000000, 1.000000, 1.000000, 1.000000 );
	if(Pl::Info[params[0]][pMaskOn])
	{
		format(string, sizeof string, "* ¬ы ударили электрошоком по неизвесному он паролизован на 8 секунд.");
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* ¬ы ударины электрошоком и паролизованы %s на 8 секунд.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s выстрелил электрошоком в неизвесного и он был паролизован,.", sendername);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	}
	else
	{
		format(string, sizeof string, "* ¬ы ударили электрошоком по %s он паролизован на 8 секунд.", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* ¬ы ударины электрошоком и паролизованы %s на 8 секунд.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* %s выстрелил электрошоком в %s и он был паролизован,.", sendername, playername);
		ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	}
	PlayerUseTazed[playerid] = true;
	GameTextForPlayer(params[0], "~r~Tazed", 3000, 3);
	Rac::TogglePlayerControllable(params[0], 0);
	SetTimerEx("TazerTime", 1000*8, false, "i", playerid);
	SetTimerEx(""#Rac::"TogglePlayerControllable", 1000 * 8 , false, "ii", params[0], 1);
	return 1;
}

CMD:unmask(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	params[0] = GetClosestPlayer(playerid, 3.0);
	if(params[0] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ќколо вас нет никого!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!Pl::Info[params[0]][pMaskOn]) return Send(playerid, COLOR_GREY, "ќколо вас нет никого в маске!");

	HideNameTag( params[0], false );
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* %s сн€л с вас маску", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы сн€ли маску с %s", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s снимает маску с %s", sendername, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);

	return 1;
}

CMD:jailed(playerid, params[]) { new string[144];
	switch(Pl::FracID(playerid)) {
	case 1..3 : {
			Send(playerid, COLOR_WHITE, " {0080ff}«аключенные в камере {ffffff}_");
			foreach(new i: Player) {
				if(Pl::Info[i][pJailed] == 1) {
					format(string, sizeof string, "* «аключенный: %s | ќсталось времени: %d", GetName(i), Pl::Info[i][pJailTime]);
					Send(playerid, COLOR_LIGHTBLUE, string);
				}
			}
		}
	}
	return 1;
}

CMD:cuff(playerid, params[]) { new string[144];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не коп!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /cuff [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "*¬ы неможете надеть наручники на самого себ€!");
	if(IsACop(params[0])) return Send(playerid, COLOR_GREY, "*¬ы неможете надевать наручники на законников!");
	if(Pl::CuffedTime[params[0]] > 0) return Send(playerid, COLOR_GREY, "* Ќа игрока уже надеты наручники !");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* »грок слишком далеко!");
	SetPlayerAttachedObject(params[0], 0, 19418, 6, -0.011000, 0.028000, -0.022000, -15.600012, -33.699977, -81.700035, 0.891999, 1.000000, 1.168000);
	SetPlayerSpecialAction(params[0], SPECIAL_ACTION_CUFFED);
	format(string, sizeof string, "* ќфицер %s надел на вас наручники", GetName(playerid));
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы надели наручники на %s.", GetName(params[0]));
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ќфицер %s надевает наручники на %s", GetName(playerid), GetName(params[0]));
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	GameTextForPlayer(params[0], "~r~Cuffed", 3000, 3);
	Pl::CuffedTime[params[0]] = 240;
	return 1;
}

CMD:uncuff(playerid, params[]) { new string[144];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не коп!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /uncuff [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы неможете сн€ть наручники на самого себ€!");
	if(IsACop(params[0])) return Send(playerid, COLOR_GREY, "* ¬ы неможете надевать наручники на законников!");
	if(Pl::CuffedTime[params[0]] <= 0) return Send(playerid, COLOR_GREY, "* Ќа игрока не надеты наручники!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* »грок слишком далеко!");
	RemovePlayerAttachedObject(params[0], 0);
	SetPlayerSpecialAction(params[0], SPECIAL_ACTION_NONE);
	format(string, sizeof string, "* ќфицер %s сн€л с вас наручники", GetName(playerid));
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы снили наручники с %s", GetName(params[0]));
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ќфицер %s снимает наручники с %s", GetName(playerid), GetName(params[0]));
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	GameTextForPlayer(params[0], "~g~Uncuffed", 2500, 3);
	Pl::CuffedTime[params[0]] = 0;
	return 1;
}

CMD:find(playerid, params[]) {
	if(Pl::Info[playerid][pJob] != 1) return Send(playerid, COLOR_GREY, "* ¬ы не детектив!");
	if(UsedFind[playerid] != 0) return Send(playerid, COLOR_GREY, "* ¬ы уже искали кого-то, подождите!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /find [id]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете отыскать самого себ€!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ќеправильное им€/ID!");

	FindTime[playerid] = 10;
	UsedFind[playerid] = (60-(Pl::Info[playerid][pSkill][0]/10));
	GetPlayerPos(params[0], posx, posy, posz);
	SetPlayerCheckpointEx(playerid, FIND_ICON, posx, posy, posz, 60, 0, -1, -1, true);

	if(Pl::Info[playerid][pSkill][0] < 500) {
		switch(++Pl::Info[playerid][pSkill][0]) {
		case 50 : Send(playerid, COLOR_YELLOW, "* ¬аш навык детектива теперь 2 уровн€, скоро ¬ы сможете находить членов фракций.");
		case 100 : Send(playerid, COLOR_YELLOW, "* ¬аш навык детектива теперь 3 уровн€, скоро ¬ы сможете находить членов фракций.");
		case 200 : Send(playerid, COLOR_YELLOW, "* ¬аш навык детектива теперь 4 уровн€, теперь ¬ы сможете находить членов фракций.");
		case 400 : Send(playerid, COLOR_YELLOW, "* ¬аш навык детектива теперь 5 уровн€, теперь ¬ы сможете находить членов фракций.");
		}
	}

	return 1;
}

CMD:giveorder(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid,COLOR_GREY,"* ¬ы не законник!");
	if(Pl::Info[playerid][pRank] < 8) return Send(playerid,COLOR_GREY,"* “олько с 8 ранга!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /giveoder [playerid]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsALawyer(params[0])) return Send(playerid, COLOR_GREY,"* Ётот человек не адвокат!");
	if(ApprovedLawyer[params[0]]) return Send(playerid, COLOR_GREY,"* ” него уже есть ордер!");
	ApprovedLawyer[params[0]] = 1;
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "* ¬ы выдали ордер на освобождение из тюрьмы %s игроку", playername);
	Send(playerid, COLOR_LIGHTBLUE,string);
	format(string, sizeof string, "* ќфицер %s выдал вам ордер на освобождение игрока(»спользуйте /free)", sendername);
	Send(params[0], COLOR_LIGHTBLUE,string);

	return 1;
}

CMD:free(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsALawyer(playerid)) return Send(playerid, COLOR_GREY,"* ¬ы не адвокат!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /free [playerid]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "¬ы не можете ќсвободить себ€!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed] != 1) return Send(playerid, COLOR_GREY, "* »грок не в тюрьме!");
	if(ApprovedLawyer[playerid] != 1) return Send(playerid, COLOR_GREY, "* ” ¬ас нет ордера на освобождение!");

	Pl::Info[playerid][pSkill][2] ++;
	if(Pl::Info[playerid][pSkill][2] == 50)
	{ Send(playerid, COLOR_YELLOW, "* ¬аш јдвокат —килл - теперь ”ровень 2, ¬ы заработаете больше ƒенег, и более быстрый ѕерезар€жают ¬рем€."); }
	else if(Pl::Info[playerid][pSkill][2] == 100)
	{ Send(playerid, COLOR_YELLOW, "* ¬аш јдвокат —килл - теперь ”ровень 3, ¬ы заработаете больше ƒенег, и более быстрый ѕерезар€жают ¬рем€."); }
	else if(Pl::Info[playerid][pSkill][2] == 200)
	{ Send(playerid, COLOR_YELLOW, "* ¬аш јдвокат —килл - теперь ”ровень 4, ¬ы заработаете больше ƒенег, и более быстрый ѕерезар€жают ¬рем€."); }
	else if(Pl::Info[playerid][pSkill][2] == 400)
	{ Send(playerid, COLOR_YELLOW, "* ¬аш јдвокат —килл - теперь ”ровень 5, ¬ы заработаете больше ƒенег, и более быстрый ѕерезар€жают ¬рем€."); }

	ApprovedLawyer[playerid] = 0;
	WantLawyer[params[0]] = 0;
	CallLawyer[params[0]] = 0;
	JailPrice[params[0]] = 0;

	UnJail(params[0], 1);
	Pl::Info[params[0]][pJailTime] = 0;
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "* ¬ы освободили %s из тюрьмы.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы были освобождены из тюрьмы, јдвокатом %s.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}
CMD:release(playerid, params[]) { new string[144], sendername[24], playername[24], fracid;
	fracid = Pl::Info[playerid][pLeader];
	if(fracid != 1 || fracid != 2 || fracid != 3 || fracid != 7) return Send(playerid, COLOR_GREY,"* ¬ы не состоите в ѕќ!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /free [playerid]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "¬ы не можете ќсвободить себ€!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(Pl::Info[params[0]][pJailed] != 1) return Send(playerid, COLOR_GREY, "* »грок не в тюрьме!");

	WantLawyer[params[0]] = 0;
	CallLawyer[params[0]] = 0;
	JailPrice[params[0]] = 0;

	UnJail(params[0], 1);
	Pl::Info[params[0]][pJailTime] = 0;
	getname(playerid->sendername,params[0]->playername);
	format(string, sizeof string, "* ¬ы освободили %s из тюрьмы.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы были освобождены из тюрьмы, лидером %s.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}


CMD:cancel(playerid, params[]) { new string[144], sendername[24];
	if(sscanf(params, "s[15]U(65535)", temp, params[0]))
	{
		Send(playerid, COLOR_WHITE, "| јннулировать |");
		Send(playerid, COLOR_WHITE, "{ffffff}¬ведите: /cancel [name]");
		Send(playerid, COLOR_GREY, "ƒоступные названи€: Sex, Drugs, Repair, Lawyer, Live, Refill, Car, Taxi, Bus");
		Send(playerid, COLOR_GREY, "ƒоступные названи€: Medic, Mechanic, Ticket, Nick, Mc");
		Send(playerid, COLOR_WHITE, "||");
		return 1;
	}
	GetPlayerName(playerid, sendername, 24);
	if(strcmp(temp, "house", true) == 0) {
		SetPVarInt(playerid, "HouseSeller", INVALID_PLAYER_ID);
		SetPVarInt(playerid, "HouseBuyer", INVALID_PLAYER_ID);
		SetPVarInt(playerid, "HousePrice", 0);
		
	} else if(strcmp(temp,"mc",true) == 0) {
		SetPVarInt(playerid, "MedSeller", INVALID_PLAYER_ID);
		SetPVarInt(playerid, "MedBuyer", INVALID_PLAYER_ID);
		SetPVarInt(playerid, "MedPrice", 0);
		SetPVarInt(playerid, "MedDiag", 0);
        SetPVarInt(playerid, "MedHour", 0);

	} else if(strcmp(temp,"sex",true) == 0) {
		SexOffer[playerid] = INVALID_PLAYER_ID;
		SexPrice[playerid] = 0;

	} else if(strcmp(temp,"drugs",true) == 0) {
		DrugOffer[playerid] = INVALID_PLAYER_ID;
		DrugPrice[playerid] = 0;
		DrugGram[playerid] = 0;

	} else if(strcmp(temp,"repair",true) == 0) {
		RepairOffer[playerid] = INVALID_PLAYER_ID;
		RepairPrice[playerid] = 0;
		RepairCar[playerid] = 0;

	} else if(strcmp(temp,"live",true) == 0) {
		LiveOffer[playerid] = INVALID_PLAYER_ID;

	} else if(strcmp(temp,"refill",true) == 0) {
		RefillOffer[playerid] = INVALID_PLAYER_ID;
		RefillPrice[playerid] = 0;

	} else if(strcmp(temp,"car",true) == 0) {
		CarOffer[playerid] = INVALID_PLAYER_ID;
		CarPrice[playerid] = 0;
		CarID[playerid] = 0;

	} else if(strcmp(temp,"ticket",true) == 0) {
		TicketOffer[playerid] = INVALID_PLAYER_ID;
		TicketMoney[playerid] = 0;

	} else if(strcmp(temp,"medic",true) == 0) {
		if(Iter::Count(MedicCalls)) {
			if(Iter::Contains(MedicCalls, playerid)) {
				Iter::Remove(MedicCalls, playerid);
				format(string, sizeof string, "*  лиент %s, отменил вызов.", GetName(playerid));
				sendToFamily(4, COLOR_AZTECAS, string);
				Send(playerid, COLOR_GREY, "* ¬ы отменили вызов!");
			}
		} else if(Iter::Count(TeamPlayers[4])) {
			foreach(new med : TeamPlayers[4]) {
				if(MedicCallTime[med][0] == playerid) {
					MedicCallTime[med][1] = 300;
					format(string, sizeof string, "*  лиент %s, отменил вызов.", GetName(playerid));
					Send(med, COLOR_AZTECAS, string), Send(playerid, COLOR_GREY, "* ¬ы отменили вызов!");
					break;
				}
			}
		} else {
			Send(playerid, COLOR_GREY, "* ¬ы не вызывали медика!");
		}

	} else if(strcmp(temp,"mechanic",true) == 0) {
		if(Iter::Count(MechanicCalls)) {
			if(Iter::Contains(MechanicCalls, playerid)) {
				Iter::Remove(MechanicCalls, playerid);
				format(string, sizeof string, "*  лиент %s, отменил вызов.", GetName(playerid));
				SendJobMessage(6, COLOR_AZTECAS, string);
				Send(playerid, COLOR_GREY, "* ¬ы отменили вызов!");
			}
		} else if(Iter::Count(JobPlayers[6]) > 0) {
			foreach(new meh : JobPlayers[6]) {
				if(MechanicCallTime[meh][0] == playerid) {
					MechanicCallTime[meh][1] = 300;
					format(string, sizeof string, "*  лиент %s, отменил вызов.", GetName(playerid));
					Send(meh, COLOR_AZTECAS, string), Send(playerid, COLOR_GREY, "* ¬ы отменили вызов!");
					break;
				}
			}
		} else {
			Send(playerid, COLOR_GREY, "* ¬ы не вызывали механика!");
		}

	} else if(strcmp(temp,"taxi",true) == 0) {
		if(TaxiCall != INVALID_PLAYER_ID) {
			if(TransportDuty[playerid] == 1 && TaxiCallTime[playerid] > 0) {
				TaxiAccepted[playerid] = INVALID_PLAYER_ID;
				GameTextForPlayer(playerid, "~w~You have~n~~r~Canceled the call", 5000, 1);
				TaxiCallTime[playerid] = 0;
				DestroyDynamicCP(checkpoints[playerid]);
				TaxiCall = INVALID_PLAYER_ID;
			} else {
				if(IsPlayerConnected(TaxiCall)) if(TaxiCall == playerid) TaxiCall = INVALID_PLAYER_ID;
				foreach(new i: Player) {
					if(Pl::isLogged(i)) {
						if(TaxiAccepted[i] != INVALID_PLAYER_ID) {
							if(TaxiAccepted[i] == playerid) {
								TaxiAccepted[i] = INVALID_PLAYER_ID;
								GameTextForPlayer(i, "~w~Taxi Caller~n~~r~Canceled the call", 5000, 1);
								TaxiCallTime[i] = 0;
								DestroyDynamicCP(checkpoints[playerid]);
							}
						}
					}
				}
			}
		}

	} else if(strcmp(temp,"bus",true) == 0) {
		if(BusCall != INVALID_PLAYER_ID) {
			if(TransportDuty[playerid] == 2 && BusCallTime[playerid] > 0) {
				BusAccepted[playerid] = INVALID_PLAYER_ID;
				GameTextForPlayer(playerid, "~w~You have~n~~r~Canceled the call", 5000, 1);
				BusCallTime[playerid] = 0;
				DestroyDynamicCP(checkpoints[playerid]);
				BusCall = INVALID_PLAYER_ID;
			} else {
				if(IsPlayerConnected(BusCall)) if(BusCall == playerid) BusCall = INVALID_PLAYER_ID;
				foreach(new i: Player) {
					if(Pl::isLogged(i)) {
						if(BusAccepted[i] != INVALID_PLAYER_ID) {
							if(BusAccepted[i] == playerid) {
								BusAccepted[i] = INVALID_PLAYER_ID;
								GameTextForPlayer(i, "~w~Bus Caller~n~~r~Canceled the call", 5000, 1);
								BusCallTime[i] = 0;
								DestroyDynamicCP(checkpoints[playerid]);
							}
						}
					}
				}
			}
		}
	} else {
		return 1;
	}
	format(string, sizeof string, "* ¬ы отменили: %s.", temp);
	Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:accept(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::isLogged(playerid)) {
		if(sscanf(params, "s[32]U(65535)", temp, params[0])) {
			Send(playerid, COLOR_WHITE, "| ѕринимать |");
			Send(playerid, COLOR_WHITE, "* ¬ведите: accept [name]");
			Send(playerid, COLOR_GREY, "ƒоступные названи€: Sex, Drugs, Repair, Lawyer, Live, Refill,House,Mc");
			Send(playerid, COLOR_GREY, "ƒоступные названи€: Car, Taxi, Bus, Boxing, Medic, Mechanic, Ticket, Nick");
			Send(playerid, COLOR_WHITE, "||");
			return 1;
		}
		if(strcmp(temp, "mc",true) == 0)
		{
			new seller = GetPVarInt(playerid, "MedSeller");
			if(!Pl::isLogged(seller)) return Send(playerid, COLOR_GREY, "* ¬ам не предлагали купить мед.карту!");
			new price = GetPVarInt(playerid, "MedPrice");
			new diagnoz = GetPVarInt(playerid, "MedDiag");
            new medhour = GetPVarInt(playerid, "MedHour");
			if(price > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас недостаточно средств!");
			Rac::GivePlayerMoney(playerid, -price);
			Rac::GivePlayerMoney(seller, price);
			getname(playerid -> sendername, seller -> playername);
			Pl::Info[playerid][pMedKarta] = diagnoz;
			Pl::Info[playerid][pMedHour] = medhour;
			PlayerPlaySound(seller, 1052, 0.0, 0.0, 0.0);
			PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
			Send(playerid, COLOR_YELLOW, "* ћед.карта была успешно преобретена!");
			Send(seller, COLOR_YELLOW, "* ћед.карта была успешно продана!");
		}
		else if(strcmp(temp, "house",true) == 0) {
			if(!IsPlayerInBiz(playerid, 60.0, Bizz_EstateAgency)) return Send(playerid, COLOR_GREY, "* ¬ы должны находитс€ в агенстве недвижимости!");
			switch(GetPVarInt(playerid, "HouseType")) {
			case 0 : {
					if(IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас уже есть дом!");
					new seller = GetPVarInt(playerid, "HouseSeller");
					if(!Pl::isLogged(seller)) return Send(playerid, COLOR_GREY, "* ¬ам не предлагали купить дом!");
					if(!IsPlayerInBiz(seller, 60.0, Bizz_EstateAgency)) return Send(playerid, COLOR_GREY, "* ¬се участники сделки должны находитс€ в агентстве недвижимости!");
					new price = GetPVarInt(playerid, "HousePrice");
					if(price > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас недостаточно средств!");
					new biz   = GetIndexFromBizID(Bizz_EstateAgency);
					GiveBizzProfit(biz, PERCENT(price, 10));

					Rac::GivePlayerMoney(playerid, -price);
					Rac::GivePlayerMoney(seller, price);
					printf("p_house:%i", Pl::Info[playerid][pHouseKey]);
					printf("s_house:%i", Pl::Info[seller][pHouseKey]);
					new house = Pl::Info[seller][pHouseKey];
					ClearHouse(house);
					HouseInfo[house][hOwned] = 1;
					getname(playerid -> sendername, seller -> playername);
					strmid(HouseInfo[house][hOwner], sendername, 0, 24, 24);
					UpdateHousePickups(house);
					UpdateHouse(house);
					Pl::Info[seller][pHouseKey] = INVALID_HOUSE_ID;
					Pl::Info[playerid][pHouseKey] = house;
					PlayerPlaySound(seller, 1052, 0.0, 0.0, 0.0);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					Send(playerid, COLOR_YELLOW, "* —делка была успешно проведена!");
					Send(seller, COLOR_YELLOW, "* —делка была успешно проведена!");

					getname(playerid -> sendername, seller -> playername);
					format(string, sizeof string, "[Debug] %s продал дом %s. Price: $%i; SellPrice: $%i; Safe: $%i",
					playername, sendername, HouseInfo[house][hPrice], price, HouseInfo[house][hSafe][0]);
					SendLog(LOG_HOUSE, string);
				}

			case 1 : {
					if(!IsPlayerHouseOwner(playerid, Pl::Info[playerid][pHouseKey])) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
					new seller = GetPVarInt(playerid, "HouseSeller");
					if(!Pl::isLogged(seller)) return Send(playerid, COLOR_GREY, "* ¬ам не предлагали обмен домами!");
					if(!IsPlayerInBiz(seller, 60.0, Bizz_EstateAgency)) return Send(playerid, COLOR_GREY, "* ¬се участники сделки должны находитс€ в агентстве недвижимости!");
					new price = GetPVarInt(playerid, "HousePrice");
					if(price > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас недостаточно средств дл€ доплаты!");

					new biz   = GetIndexFromBizID(Bizz_EstateAgency);
					GiveBizzProfit(biz, PERCENT(price, 10));

					Rac::GivePlayerMoney(playerid, -price);
					Rac::GivePlayerMoney(seller, price);

					new h1 = Pl::Info[seller][pHouseKey];
					new h2 = Pl::Info[playerid][pHouseKey];
					ClearHouse(h1), ClearHouse(h2);
					HouseInfo[h1][hOwned] = HouseInfo[h2][hOwned] = 1;
					getname(playerid -> sendername, seller -> playername);
					strmid(HouseInfo[h1][hOwner], sendername, 0, 24, 24);
					strmid(HouseInfo[h2][hOwner], playername, 0, 24, 24);
					UpdateHousePickups(h1), UpdateHousePickups(h2);
					UpdateHouse(h1), UpdateHouse(h2);
					Pl::Info[seller][pHouseKey] = h2;
					Pl::Info[playerid][pHouseKey] = h1;
					PlayerPlaySound(seller, 1052, 0.0, 0.0, 0.0);
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					Send(playerid, COLOR_YELLOW, "* —делка была успешно проведена!");
					Send(seller, COLOR_YELLOW, "* —делка была успешно проведена!");

					getname(playerid -> sendername, seller -> playername);
					format(string, sizeof string, "[Debug] %s обмен€лс€ домом с %s. Price: $%i|%i; Surcharge: $%i; Safe: $%i|%i",
					playername, sendername, HouseInfo[h1][hPrice], HouseInfo[h2][hPrice], price, HouseInfo[h1][hSafe][0], HouseInfo[h2][hSafe][0]);
					SendLog(LOG_HOUSE, string);
				}
			}
		}
		else if(strcmp(temp, "invite",true) == 0) {
			new frac = GetPVarInt(playerid, "InvateFrac");
			if(!IsValidFrac(frac)) return Send(playerid, COLOR_GREY, "* ¬ас не приглашали во фракцию!");
			Pl::Info[playerid][pMember] = frac;
			Pl::Info[playerid][pRank] = 1;
			Rac::SetPlayerInterior(playerid, 3);
			Rac::SetPlayerVirtualWorld(playerid, 7);
			Pl::Info[playerid][pLocal] = OFFSET_BIZZ + GetIndexFromBizID(7);
			Rac::SetPlayerPos(playerid, 207.4872,-129.2266,1003.5078);
			SelectCharPlace[playerid] = 0;
			Pl::SetFracColor(playerid);
			SetPVarInt(playerid, "InvateFrac", 0);
			Iter::Add(TeamPlayers[frac], playerid);
			Container::At(Pl::FracID(playerid), Container::First, SelectCharPlace[playerid], ChosenSkin[playerid]);
			SetPlayerSkin(playerid, ChosenSkin[playerid]);
			Pl::Info[playerid][pChar] = ChosenSkin[playerid];
			format(string, sizeof string, "* ¬ы были прин€ты в %s", FracInfo[frac][fName]);
			Send(playerid, COLOR_LIGHTBLUE, string);
		}

		else if(strcmp(temp,"car",true) == 0) {
			if(CarOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* Ќикто не предложил покупать јвтомобиль!");
			if(!Pl::isLogged(CarOffer[playerid])) return 1;
			if(Rac::GetPlayerMoney(playerid) < CarPrice[playerid]) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
			if(!IsPlayerInVehicle(CarOffer[playerid], CarID[playerid])) return Send(playerid, COLOR_GREY, "* јгент по продаже легковых автомобилей не находитс€ в продоваемом јвтомобиле!");
			new points;
			new level = Pl::Info[CarOffer[playerid]][pSkill][5];
			if(level == 50)
			{ Send(CarOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык јгента по продаже легковых автомобилей - теперь ”ровень 2, »гроки, которые покупают јвтомобили от ¬ас, могут назвать это чаще."); }
			else if(level == 100)
			{ Send(CarOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык јгента по продаже легковых автомобилей - теперь ”ровень 3, »гроки, которые покупают јвтомобили от ¬ас, могут назвать это чаще."); }
			else if(level == 200)
			{ Send(CarOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык јгента по продаже легковых автомобилей - теперь ”ровень 4, »гроки, которые покупают јвтомобили от ¬ас, могут назвать это чаще."); }
			else if(level == 400)
			{ Send(CarOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык јгента по продаже легковых автомобилей - теперь ”ровень 5, »гроки, которые покупают јвтомобили от ¬ас, могут назвать это чаще."); }
			if(level >= 0 && level <= 50) { points = 1; }
			else if(level >= 51 && level <= 100) { points = 2; }
			else if(level >= 101 && level <= 200) { points = 3; }
			else if(level >= 201 && level <= 400) { points = 4; }
			else if(level >= 401) { points = 4; }
			format(string, sizeof string, "* ¬ы купили јвтомобиль за $%d, от јгента по продаже легковых автомобилей %s. (¬ы можете использовать /callcar %d врем€)",CarPrice[playerid], GetName(CarOffer[playerid]), points);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬ы продали свой јвтомобиль %s дл€ $%d, игрок может использовать /callcar %d врем€.", GetName(playerid), CarPrice[playerid], points);
			Send(CarOffer[playerid], COLOR_LIGHTBLUE, string);
			Pl::Info[CarOffer[playerid]][pPayCheck] += CarPrice[playerid];
			Rac::GivePlayerMoney(playerid, -CarPrice[playerid]);
			Rac::RemovePlayerFromVehicle(CarOffer[playerid]);
			Rac::TogglePlayerControllable(CarOffer[playerid], 1);
			CarCalls[playerid] = points;
			CarOffer[playerid] = INVALID_PLAYER_ID;
			CarPrice[playerid] = 0;

		} else if(strcmp(temp,"ticket",true) == 0) {
			if(!Pl::isLogged(TicketOffer[playerid])) return 1;
			if(TicketOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не выписывали штраф!");
			if(!IsPlayerInRangeOfPlayer(playerid, 5.0, TicketOffer[playerid])) return Send(playerid, COLOR_GREY, "* ќфицер не около вас!");
			if(TicketMoney[playerid] > Rac::GetPlayerMoney(TicketOffer[playerid])) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег на оплату штрафа.");
			format(string, sizeof string, "* ¬ы заплатили штар $%d офицеру %s.", TicketMoney[playerid], GetName(TicketOffer[playerid]));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s заплатил штраф $%d.", GetName(playerid), TicketMoney[playerid]);
			Send(TicketOffer[playerid], COLOR_LIGHTBLUE, string);
			Rac::GivePlayerMoney(playerid, -TicketMoney[playerid]);
			Rac::GivePlayerMoney(TicketOffer[playerid], TicketMoney[playerid]);
			TicketOffer[playerid] = INVALID_PLAYER_ID;
			TicketMoney[playerid] = 0;

		} else if(strcmp(temp,"taxi",true) == 0) {
			if(TransportDuty[playerid] != 1) return Send(playerid, COLOR_GREY, "* ¬ы не таксист!");
			if(TaxiCallTime[playerid] > 0) return Send(playerid, COLOR_GREY, "* ¬ы уже прин€ли вызов!");
			if(TaxiCall == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* Ќикто еще не вызывал такси!");
			if(!Pl::isLogged(TaxiCall)) return 1;
			format(string, sizeof string, "* ¬ы прин€ли вызов от %s, ¬ы будете видеть маркер, пока не достигнете его.", GetName(TaxiCall));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* “аксист %s прин€л ваш вызов, пожалуйста ждите на своем насто€щем положении.", GetName(playerid));
			Send(TaxiCall, COLOR_LIGHTBLUE, string);
			GameTextForPlayer(playerid, "~w~Taxi Caller~n~~r~Goto redmarker", 5000, 1);
			TaxiCallTime[playerid] = 1;
			TaxiAccepted[playerid] = TaxiCall;
			TaxiCall = INVALID_PLAYER_ID;

		} else if(strcmp(temp,"bus",true) == 0) {
			if(TransportDuty[playerid] != 2) return Send(playerid, COLOR_GREY, "¬ы не водитель автобуса!");
			if(BusCallTime[playerid] > 0) return Send(playerid, COLOR_GREY, "* ¬ы уже прин€ли вызов!");
			if(BusCall == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* Ќикто еще не вызывал автобус!");
			if(!Pl::isLogged(BusCall)) return 1;
			format(string, sizeof string, "* ¬ы прин€ли вызов от %s, ¬ы будете видеть маркер, пока не достигнете его.", GetName(BusCall));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬одитель јвтобуса %s прин€л ваш вызов, пожалуйста ждите в своем насто€щем положении.", GetName(playerid));
			Send(BusCall, COLOR_LIGHTBLUE, string);
			new Float:X,Float:Y,Float:Z;
			GetPlayerPos(BusCall, X, Y, Z);
			DestroyDynamicCP(checkpoints[playerid]);
			checkpoints[playerid] = CreateDynamicCP(X, Y, Z,8.0,-1,-1,playerid,99999.9);
			GameTextForPlayer(playerid, "~w~Bus Caller~n~~r~Goto redmarker", 5000, 1);
			BusCallTime[playerid] = 1;
			BusAccepted[playerid] = BusCall;
			BusCall = INVALID_PLAYER_ID;

		} else if(strcmp(temp,"medic",true) == 0) {
			if(Pl::FracID(playerid) != 4) return Send(playerid, COLOR_GREY, "* ¬ы не медик!");
			if(MedicCallTime[playerid][0] != 0xffff) return Send(playerid, COLOR_GREY, "* ¬ы уже прин€ли вызов!");
			if(!Iter::Count(MedicCalls)) return Send(playerid, COLOR_GREY, "* Ќикто еще не вызывал медика!");
			foreach(new caller : MedicCalls) {
				MedicCallTime[playerid][0] = caller;
				MedicCallTime[playerid][1] = 1;
				Iter::Remove(MedicCalls, caller);
				new Float:X,Float:Y,Float:Z;
				GetPlayerPos(caller, X, Y, Z);
				pickupd[playerid][1] = CreateDynamicMapIcon(X, Y, Z, 20, 0, 0, 0, playerid, 99999.9);
				Streamer::SetIntData(4, pickupd[playerid][1], E_STREAMER_STYLE, MAPICON_GLOBAL_CHECKPOINT);
				GameTextForPlayer(playerid, "~w~Medic Caller~n~~r~Goto redmarker", 5000, 1);
				getname(playerid->sendername,caller->playername);
				format(string, sizeof string, "* ¬ы прин€ли вызов от %s, у вас есть 300 секунд, чтобы добратьс€ до него.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Send(playerid, COLOR_LIGHTBLUE, "* ѕосле этих 300 секунд красный маркер будет удален.");
				format(string, sizeof string, "* %s %s прин€л ваш вызов. ќн будет в течении 300 секунд", RankInfo[Pl::FracID(playerid)][Pl::Info[playerid][pRank]], sendername);
				Send(caller, COLOR_LIGHTBLUE, string);
				return 1;
			}

		} else if(strcmp(temp,"mechanic",true) == 0) {
			if(Pl::Info[playerid][pJob] != 6) return Send(playerid, COLOR_GREY, "* ¬ы не автомеханик!");
			if(MechanicCallTime[playerid][0] != 0xffff) return Send(playerid, COLOR_GREY, "* ¬ы уже прин€ли другой вызов!");
			if(!Iter::Count(MechanicCalls)) return Send(playerid, COLOR_GREY, "* ¬ насто€щие врем€ нет вызовов!");
			foreach(new caller : MechanicCalls) {
				MechanicCallTime[playerid][0] = caller;
				MechanicCallTime[playerid][1] = 1;
				Iter::Remove(MechanicCalls, caller);
				new Float:X,Float:Y,Float:Z;
				GetPlayerPos(caller, X, Y, Z);
				pickupd[playerid][1] = CreateDynamicMapIcon(X, Y, Z, 20, 0, 0, 0, playerid, 99999.9);
				Streamer::SetIntData(4, pickupd[playerid][1], E_STREAMER_STYLE, MAPICON_GLOBAL_CHECKPOINT);
				GameTextForPlayer(playerid, "~w~Mechanic Caller~n~~r~Goto redmarker", 5000, 1);
				getname(playerid -> sendername, caller -> playername);
				format(string, sizeof string, "* ¬ы прин€ли вызов от %s, у вас есть 300 секунд, чтобы добратьс€ туда.", playername);
				Send(playerid, COLOR_LIGHTBLUE, string);
				Send(playerid, COLOR_LIGHTBLUE, "* ѕосле этих 300 секунд красный маркер будет удален.");
				format(string, sizeof string, "* јвтомеханик %s прин€л ваш вызов, пожалуйста ждите в своем насто€щем положении.", sendername);
				Send(caller, COLOR_LIGHTBLUE, string);
				format(string, sizeof string, "** %s прин€л вызов и следует к %s.", sendername, playername);
				SendJobMessage(6, COLOR_AZTECAS, string);
				break ;
			}

		} else if(strcmp(temp,"refill",true) == 0) {
			if(RefillOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не предлогали заправить транспорт!");
			if(!Pl::isLogged(RefillOffer[playerid])) return 1;
			if(RefillPrice[playerid] > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");

			new Float:fuel, car = gLastCar[playerid];
			switch(++Pl::Info[RefillOffer[playerid]][pSkill][3]) {
			case 50 : Send(RefillOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 2, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
			case 100 : Send(RefillOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 3, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
			case 200 : Send(RefillOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 4, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
			case 400 : Send(RefillOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 5, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
			}
			switch(Pl::Info[RefillOffer[playerid]][pSkill][3]) {
			case 0..50		: fuel = 15.0;
			case 51..100	: fuel = 25.0;
			case 101..200	: fuel = 35.0;
			case 201..300 	: fuel = 45.0;
			case 301..400 	: fuel = 55.0;
			case 401..501 	: fuel = 65.0;
			}

			format(string, sizeof string, "* ¬ы снова наполн€ли свой автомобиль с %d%, за $%d на машине ћеханический %s.", fuel, RefillPrice[playerid], GetName(RefillOffer[playerid]));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬ы снова наполн€ли %s's автомобиль с %d%, $%d был добавлен к ¬ашей «арплате.", GetName(playerid), fuel, RefillPrice[playerid]);
			Send(RefillOffer[playerid], COLOR_LIGHTBLUE, string);
			Pl::Info[RefillOffer[playerid]][pPayCheck] += RefillPrice[playerid];
			Rac::GivePlayerMoney(playerid, -RefillPrice[playerid]);
			if(AutoInfo[car][aFuel] < 110) {
				AutoInfo[car][aFuel] += fuel;
			}
			RefillOffer[playerid] = INVALID_PLAYER_ID;
			RefillPrice[playerid] = 0;

		} else if(strcmp(temp,"live",true) == 0) {
			if(LiveOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не придлогали дать интервью!");
			if(!Pl::isLogged(LiveOffer[playerid])) return 1;
			if(!IsPlayerInRangeOfPlayer(playerid, 3.0, LiveOffer[playerid])) return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от репортера!");
			Send(playerid, COLOR_LIGHTBLUE, "* ¬ы заморожены до окончани€ интервью");
			Send(LiveOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы заморожены до окончани€ интервью (используйте /live again).");
			Rac::TogglePlayerControllable(playerid, 0); Rac::TogglePlayerControllable(LiveOffer[playerid], 0);
			TalkingLive[playerid] = LiveOffer[playerid];
			TalkingLive[LiveOffer[playerid]] = playerid;
			LiveOffer[playerid] = INVALID_PLAYER_ID;

		} else if(strcmp(temp,"drugs",true) == 0) {
			if(DrugOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не придлогали наркотики!");
			if(DrugPrice[playerid] > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
			if(Pl::Info[playerid][pDrugs] > 9) return Send(playerid, COLOR_GREY, "* ” ¬ас уже слишком много наркотиков!");
			if(!Pl::isLogged(DrugOffer[playerid])) return 1;
			format(string, sizeof string, "* ¬ы купили %d грамм за $%d от “орговца наркотиками %s.", DrugGram[playerid], DrugPrice[playerid], GetName(DrugOffer[playerid]));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s купил ¬аш %d грамм, $%d был добавлен к ¬ашей «арплате.", GetName(playerid), DrugGram[playerid], DrugPrice[playerid]);
			Send(DrugOffer[playerid], COLOR_LIGHTBLUE, string);
			Pl::Info[DrugOffer[playerid]][pPayCheck] += DrugPrice[playerid];
			Pl::Info[DrugOffer[playerid]][pSkill][7] ++;
			Rac::GivePlayerMoney(playerid, -DrugPrice[playerid]);
			Pl::Info[playerid][pDrugs] += DrugGram[playerid];
			Pl::Info[DrugOffer[playerid]][pDrugs] -= DrugGram[playerid];
			if(Pl::Info[DrugOffer[playerid]][pSkill][7] == 50)
			{ Send(DrugOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык “орговца наркотиками - теперь ”ровень 2, ¬ы можете купить больше √раммов и Ѕолее дешевый."); }
			else if(Pl::Info[DrugOffer[playerid]][pSkill][7] == 100)
			{ Send(DrugOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык “орговца наркотиками - теперь ”ровень 3, ¬ы можете купить больше √раммов и Ѕолее дешевый."); }
			else if(Pl::Info[DrugOffer[playerid]][pSkill][7] == 200)
			{ Send(DrugOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык “орговца наркотиками - теперь ”ровень 4, ¬ы можете купить больше √раммов и Ѕолее дешевый."); }
			else if(Pl::Info[DrugOffer[playerid]][pSkill][7] == 400)
			{ Send(DrugOffer[playerid], COLOR_YELLOW, "* ¬аш Ќавык “орговца наркотиками - теперь ”ровень 5, ¬ы можете купить больше √раммов и Ѕолее дешевый."); }
			DrugOffer[playerid] = INVALID_PLAYER_ID; DrugPrice[playerid] = 0; DrugGram[playerid] = 0;

		} else if(strcmp(temp,"sex",true) == 0) {
			if(SexOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не придлагали секс!");
			if(Rac::GetPlayerMoney(playerid) > SexPrice[playerid]) return Send(playerid, COLOR_GREY, "* ¬ы не сможите заплатить шлюхе!");
			if(!Pl::isLogged(SexOffer[playerid])) return 1;
			new Car = GetPlayerVehicleID(playerid);
			if(!IsPlayerInAnyVehicle(playerid) && !IsPlayerInVehicle(SexOffer[playerid], Car)) return Send(playerid, COLOR_GREY, "* ¬ы нили шлюха не находитесь в машине!");
			format(string, sizeof string, "* ” ¬ас был секс со Ўлюхой %s, дл€ $%d.", GetName(SexOffer[playerid]), SexPrice[playerid]);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s имел секс с ¬ами, $%d был добавлен к ¬ашей «арплате.", GetName(playerid), SexPrice[playerid]);
			Send(SexOffer[playerid], COLOR_LIGHTBLUE, string);
			Pl::Info[SexOffer[playerid]][pPayCheck] += SexPrice[playerid];
			Rac::GivePlayerMoney(playerid, -SexPrice[playerid]);
			Pl::Info[SexOffer[playerid]][pSkill][1] ++;
			if(Pl::Info[SexOffer[playerid]][pSkill][1] == 50)
			{ Send(SexOffer[playerid], COLOR_YELLOW, "* наш —ексуальный Ќавык - теперь ”ровень 2, ¬ы предлагаете лучший ѕол (здоровье), и меньше случайно натыкаетс€ на —“јЌƒ."); }
			else if(Pl::Info[SexOffer[playerid]][pSkill][1] == 100)
			{ Send(SexOffer[playerid], COLOR_YELLOW, "* наш —ексуальный Ќавык - теперь ”ровень 3, ¬ы предлагаете лучший ѕол (здоровье), и меньше случайно натыкаетс€ на —“јЌƒ."); }
			else if(Pl::Info[SexOffer[playerid]][pSkill][1] == 200)
			{ Send(SexOffer[playerid], COLOR_YELLOW, "* наш —ексуальный Ќавык - теперь ”ровень 4, ¬ы предлагаете лучший ѕол (здоровье), и меньше случайно натыкаетс€ на —“јЌƒ."); }
			else if(Pl::Info[SexOffer[playerid]][pSkill][1] == 400)
			{ Send(SexOffer[playerid], COLOR_YELLOW, "* наш —ексуальный Ќавык - теперь ”ровень 5, ¬ы предлагаете лучший ѕол (здоровье), и меньше случайно натыкаетс€ на —“јЌƒ."); }
			if(Condom[playerid] < 1) {
				new rand, level = Pl::Info[SexOffer[playerid]][pSkill][1];
				if(level >= 0 && level <= 50) {
					if(Rac::GetPlayerHealth(playerid) < 150) Rac::GivePlayerHealth(playerid, 30.0);
					rand = random(sizeof(STD1));
					STDPlayer[playerid] = STD1[rand];
					STDPlayer[SexOffer[playerid]] = STD1[rand];
					switch(STDPlayer[SexOffer[playerid]]) {
					case 0: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 30 здоровь€ име€ секс.");
					case 1: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 30 здоровь€ + ’ломидию из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента ’ломидией.");
					case 2: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 30 здоровь€ + √онорею из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента √онореей.");
					case 3: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 30 здоровь€ + —ифилис из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента —ифилисом");
					}
				} else if(level >= 51 && level <= 100) {
					if(Rac::GetPlayerHealth(playerid) < 150) Rac::GivePlayerHealth(playerid, 60.0);
					rand = random(sizeof(STD2)); STDPlayer[playerid] = STD2[rand];
					STDPlayer[SexOffer[playerid]] = STD2[rand];
					switch(STDPlayer[SexOffer[playerid]]) {
					case 0: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ име€ секс.");
					case 1: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + ’ломидию из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента ’ломидией.");
					case 2: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + √онорею из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента √онореей.");
					case 3: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + —ифилис из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента —ифилисом");
					}
				} else if(level >= 101 && level <= 200) {
					if(Rac::GetPlayerHealth(playerid) < 150) Rac::GivePlayerHealth(playerid, 90.0);
					rand = random(sizeof(STD3)); STDPlayer[playerid] = STD3[rand];
					STDPlayer[SexOffer[playerid]] = STD3[rand];
					switch(STDPlayer[SexOffer[playerid]]) {
					case 0: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ име€ секс.");
					case 1: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + ’ломидию из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента ’ломидией.");
					case 2: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + √онорею из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента √онореей.");
					case 3: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + —ифилис из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента —ифилисом");
					}
				} else if(level >= 201 && level <= 400) {
					if(Rac::GetPlayerHealth(playerid) < 150) Rac::GivePlayerHealth(playerid, 120.0);
					rand = random(sizeof(STD4)); STDPlayer[playerid] = STD4[rand];
					STDPlayer[SexOffer[playerid]] = STD4[rand];
					switch(STDPlayer[SexOffer[playerid]])
					{
					case 0: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ име€ секс.");
					case 1: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + ’ломидию из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента ’ломидией.");
					case 2: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + √онорею из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента √онореей.");
					case 3: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы получили 60 здоровь€ + —ифилис из-за секса."), Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ¬ы зарозили своего клиента —ифилисом");
					}
				} else if(level >= 401) {
					if(Rac::GetPlayerHealth(playerid) < 150) Rac::GivePlayerHealth(playerid, 150.0);
					Send(playerid, COLOR_LIGHTBLUE, "* ¬аш уровень квалификации Ўлюхи очень высок, что вы дали своему клиенту очень высокое здоровье.");
					Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* ”ровень квалификации Ўлюхи очень высок, ¬ы получили высокое здоровье и никакой болезни");
				}
			} else {
				Send(SexOffer[playerid], COLOR_LIGHTBLUE, "* »грок использовал ѕрезерватив.");
				Send(playerid, COLOR_LIGHTBLUE, "* ¬ы использовали ѕрезерватив.");
				Condom[playerid] --;
			}
			SexOffer[playerid] = INVALID_PLAYER_ID;

		} else if(strcmp(temp,"repair",true) == 0) {
			if(RepairOffer[playerid] == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ¬ам не предлагали починить автомобиль!");
			if(RepairPrice[playerid] > Rac::GetPlayerMoney(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватит денег на починку!");
			if(!IsPlayerInAnyVehicle(playerid)) return 1;
			if(!Pl::isLogged(RepairOffer[playerid])) return 1;
			RepairCar[playerid] = GetPlayerVehicleID(playerid);
			Rac::RepairVehicle(GetPlayerVehicleID(RepairCar[playerid]));
			format(string, sizeof string, "* ¬ы восстановили свой автомобиль за $%d на машине ћеханик %s.", RepairPrice[playerid], GetName(RepairOffer[playerid]));
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬ы установили %s's автомобиль, $%d был добавлен к ¬ашей «арплате.", GetName(playerid), RepairPrice[playerid]);
			Send(RepairOffer[playerid], COLOR_LIGHTBLUE, string);
			Pl::Info[RepairOffer[playerid]][pSkill][3] ++;
			if(Pl::Info[RepairOffer[playerid]][pSkill][3] == 50)
			{ Send(RepairOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 2, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков."); }
			else if(Pl::Info[RepairOffer[playerid]][pSkill][3] == 100)
			{ Send(RepairOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 3, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков."); }
			else if(Pl::Info[RepairOffer[playerid]][pSkill][3] == 200)
			{ Send(RepairOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 4, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков."); }
			else if(Pl::Info[RepairOffer[playerid]][pSkill][3] == 400)
			{ Send(RepairOffer[playerid], COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 5, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков."); }
			Pl::Info[RepairOffer[playerid]][pPayCheck] += RepairPrice[playerid];
			Rac::GivePlayerMoney(playerid, -RepairPrice[playerid]);
			RepairOffer[playerid] = INVALID_PLAYER_ID;
			RepairPrice[playerid] = 0;
		}
	}
	return 1;
}

CMD:refill(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::Info[playerid][pJob] != 6) return Send(playerid, COLOR_GREY, "¬ы не работаете ћехаником!");
	if(sscanf(params, "ui", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /refill [playerid] [price]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsAMehCar(GetPlayerVehicleID(playerid))) return Send(playerid,COLOR_GREY,"¬ы не в тачке механика");
	if(params[1] < 1 || params[1] > 5000) return Send(playerid, COLOR_GREY, "÷ена не должна быть меньше 1, или выше 5000!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[1]) && !IsPlayerInAnyVehicle(params[1])) return Send(playerid, COLOR_GREY, "* Ётот инрок слишком далеко от вас");
	RefillOffer[params[0]] = playerid;
	RefillPrice[params[0]] = params[1];
	getname(playerid -> sendername, params[0] -> playername);
	format(string, sizeof string, "* ¬ы предложили %s заправить его автомобиль за $%d .", sendername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ћеханик %s предлагает заправить ваш автомобиль за $%d (пишите /accept refill чтобы согласитьс€)", playername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:at(playerid, params[]) {
	if(GetVehicleModel(GetPlayerVehicleID(playerid)) != 525) return Send(playerid, COLOR_GREY, "* ¬ы не в машине механика!");
	new veh = GetPlayerVehicleID(playerid);
	if(IsTrailerAttachedToVehicle(veh)) return Send(playerid, COLOR_GREY, "* ћашина подцеплена!");
	new trailer = GetPlayerBootVehicle(playerid, veh);
	if(trailer == INVALID_VEHICLE_ID) return Send(playerid, COLOR_GREY,"* Ќет машин поблизости!");
	if(IsTrailerAttachedToVehicle(trailer)) return Send(playerid, COLOR_GREY, "* ћашина уже прицеплена!");
	AttachTrailerToVehicle(trailer, veh);
	Send(playerid, COLOR_YELLOW, "* ћашина подцеплена!");
	return 1;
}

CMD:dt(playerid, params[]) {
	if(GetVehicleModel(GetPlayerVehicleID(playerid)) != 525) return Send(playerid, COLOR_GREY, "* ¬ы не в машине механика!");
	new veh = GetPlayerVehicleID(playerid);
	if(!IsTrailerAttachedToVehicle(veh)) return Send(playerid, COLOR_GREY, "* ћашина не прицеплена!");
	DetachTrailerFromVehicle(veh); Send(playerid, COLOR_YELLOW, "* ћашина отцеплена!");
	return 1;
}

CMD:repair(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::Info[playerid][pJob] != 6) return Send(playerid, COLOR_GREY, "¬ы не јвтомобильный ћеханик!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "* ¬ведите: /repair [playerid] [price]");
	if(params[1] < 1 || params[1] > 1000) return Send(playerid, COLOR_GREY, "÷ена не должна быть меньше 1, или выше 1000!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0]) && !IsPlayerInAnyVehicle(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас!");
	if(IsAMehCar(GetPlayerVehicleID(playerid))) {
		getname(playerid->sendername,params[0]->playername);
		format(string, sizeof string, "* ¬ы предложили %s починить его автомобиль за $%d .", playername, params[1]);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* ћеханик %s предлагает починить ваш автомобиль за $%d, (пишите /accept repair чтобы согласитьс€)", sendername, params[1]);
		Send(params[0], COLOR_LIGHTBLUE, string);
		RepairOffer[params[0]] = playerid;
		RepairPrice[params[0]] = params[1];
	}
	return 1;
}

CMD:callcar(playerid, params[]) { new string[144];
	if(!CarCalls[playerid]) Send(playerid, COLOR_GREY, "Ќедействительное действие !");
	GetPlayerPos(playerid, posx, posy, posz);
	SetVehiclePos(CarID[playerid],posx, posy+4, posz);
	Send(playerid, COLOR_LIGHTBLUE, "*  упленный јвтомобиль прибыл.");
	format(string, sizeof string, "* ¬ы можете назвать свой  упленный јвтомобиль в течение %d времен больше.", CarCalls[playerid]);
	Send(playerid, COLOR_LIGHTBLUE, string); CarCalls[playerid] -= 1;
	return 1;
}

CMD:f(playerid, params[]) { new string[144], sendername[24];
	if(IsPMuted(playerid)) return Send(playerid, COLOR_CYAN, "¬ы не можете говорить!");
	if(isnull(params) || params[0] == ' ') return Send(playerid, COLOR_GREY, "¬ведите: /f [текст]");
	if(!IsAFamily(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не член семьи!");
	GetPlayerName(playerid, sendername, 24);
	format(string, sizeof string, "[F] %s %s: %s.**", RankInfo[Pl::FracID(playerid)][Pl::Info[playerid][pRank]], sendername, params[0]);
	sendToFamily(Pl::FracID(playerid), COLOR_AZTECAS, string);
	return 1;
}

CMD:news(playerid, params[]) {
	if(IsPMuted(playerid)) return Send(playerid, COLOR_GREY, "* ” ¬ас молчанка!");
	if(Pl::FracID(playerid) != 9) return Send(playerid, COLOR_GREY, "* ¬ы не репартер!");
	if(!OnAir[playerid]) {
		if(OnAirMax >= 2) return Send(playerid, COLOR_GREY, "* ¬ эфире уже видут другие люди!");
		new veh = GetPlayerVehicleID(playerid);
		if((!veh &&IsANews(veh)) || IsPlayerInRangeOfPoint(playerid,5.0,353.4343,272.8408,1008.6656)) {
			Send(playerid, COLOR_GREY, "¬ы не находитесь в фургоне новостей, вертолете или в студии!");
		} else {
			OnAirMax++;
			OnAir[playerid] = true;
			Send(playerid,COLOR_LIGHTBLUE,"* ¬ы начали эфир! √оворите просто в чат, и ваши сообщени€ будут новост€ми");
		}
	} else {
		OnAirMax--;
		OnAir[playerid] = false;
		Send(playerid,COLOR_LIGHTBLUE,"* ¬ы закончили эфир!");
	}
	return 1;
}

CMD:live(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::FracID(playerid) != 9) return Send(playerid, COLOR_GREY, "* ¬ы не репортер!");
	if(TalkingLive[playerid] != INVALID_PLAYER_ID) {
		Send(playerid, COLOR_LIGHTBLUE, "* »нтервью окончено");
		Send(TalkingLive[playerid], COLOR_LIGHTBLUE, "* »нтервью окончено");
		Rac::TogglePlayerControllable(playerid, 1);
		Rac::TogglePlayerControllable(TalkingLive[playerid], 1);
		TalkingLive[TalkingLive[playerid]] = INVALID_PLAYER_ID;
		TalkingLive[playerid] = INVALID_PLAYER_ID;
	} else {
		if(Pl::Info[playerid][pRank] <= 4) return Send(playerid, COLOR_GREY, "¬аш ранг репортера низок, чтобы брать интервью!");
		if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /live [id/Name]");
		if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете брать у самого себ€ интервью");
		if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) Send(playerid, COLOR_GREY, "* ¬ы далеко от этого игрока!");
		Rac::TogglePlayerControllable(playerid, 0);
		Rac::TogglePlayerControllable(params[0], 0);
		getname(playerid -> sendername,params[0] -> playername);
		format(string, sizeof string, "* ¬ы предложили интервью %s.", playername);
		Send(playerid, COLOR_LIGHTBLUE, string);
		format(string, sizeof string, "* –епортер %s предлагает вам дать интервью (/accept live) прин€ть.", sendername);
		Send(params[0], COLOR_LIGHTBLUE, string);
		LiveOffer[params[0]] = playerid;
	}
	return 1;
}

CMD:selldrugs(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::Info[playerid][pJob] != 4) Send(playerid, COLOR_GREY, "¬ы не Ќаркодилер!");
	if(sscanf(params, "uii", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "¬ведите: /selldrugs [playerid] [ammount] [price]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* «ачем вам покупать нарко у самого себ€?");
	if(params[1] < 1 || params[1] > 99) return Send(playerid, COLOR_GREY, "* √раммы не должны быть меньше 1, или выше 99!");
	if(params[2] < 1 || params[2] > 99999) return Send(playerid, COLOR_GREY, "* ÷ена не должна быть не меньше 1, или выше 99999!");
	if(params[1] > Pl::Info[playerid][pDrugs]) return Send(playerid, COLOR_GREY, "* ¬ы не имеете столько наркотиков!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не р€дом с вами!");

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы предложили %s купить %d грамм за $%d", playername, params[1], params[2]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* Ќаркоторговец %s предлагает вам купить %d грамм за $%d (пишите /accept drugs чтобы согласитьс€)", sendername, params[1], params[2]);
	Send(params[0], COLOR_LIGHTBLUE, string); DrugOffer[params[0]] = playerid;
	DrugPrice[params[0]] = params[2]; DrugGram[params[0]] = params[1];

	return 1;
}

CMD:usedrugs(playerid, params[]) {
	if(Pl::Info[playerid][pDrugs] > 0) {
		Pl::Stoned[playerid] += 1;
		DrugIntoxic[playerid] = DrugIntoxic[playerid] + 60;
		SetPlayerDrunkLevel(playerid, GetPlayerDrunkLevel(playerid)+2000);
		Pl::Info[playerid][pDrugs] -= 2;
		if(Pl::Info[playerid][pDrugs] < 0) {
			Pl::Info[playerid][pDrugs] = 0;
		}
		Rac::GivePlayerHealth(playerid, 20.0);
		SetPlayerChatBubble(playerid, "прин€л наркотик", COLOR_PURPLE, 40.0, 4000);
		Send(playerid, COLOR_PURPLE, "* ¬ы использовали 2 грамма наркотика!");
		if(Pl::Stoned[playerid] >= 2) {
			GameTextForPlayer(playerid, "~w~You are~n~~p~Stoned", 4000, 1);
		}
		if(STDPlayer[playerid]) {
			STDPlayer[playerid] = 0;
			Send(playerid, COLOR_LIGHTBLUE, "* ¬ы больше не болеете сифилисом из-за Ќаркотиков!");
		}
	} else {
		Send(playerid, COLOR_GREY, "* ” ¬ас нет нарко!");
	}
	return 1;
}

CMD:setmats(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return 1;
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_WHITE, "¬ведите: /makemats [playerid] [кол-во]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /setmats к игроку %s[%s]. Ѕыло: %i; —тало: %i",
	sendername, playername, FracInfo[Pl::FracID(params[0])][fName], Pl::Info[params[0]][pMats], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3); Pl::Info[params[0]][pMats] = params[1];
	return 1;
}

CMD:setdrugs(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return 1;
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_WHITE, "¬ведите: /makedrugs [playerid] [кол-во]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /makedrugs к игроку %s[%s]. Ѕыло: %i; —тало: %i",
	sendername, playername, FracInfo[Pl::FracID(params[0])][fName], Pl::Info[params[0]][pDrugs], params[1]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3); Pl::Info[params[0]][pDrugs] = params[1];
	return 1;
}

CMD:gd(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GRAD2, "¬ведите: /givedrugs [playerid] [ammount]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "Ќельз€ себе отдать нарко!");
	if(params[1] < 1 || params[1] > 99) return Send(playerid, COLOR_GREY, "* √раммы не должны быть меньше 1, или выше 99!");
	if(Pl::Info[playerid][pDrugs] < params[1]) return Send(playerid,COLOR_GREY,"* ” ¬ас нет столько нарко!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* “от игрок не около ¬ас!");
	Pl::Info[playerid][pDrugs] -= params[1];
	Pl::Info[params[0]][pDrugs] += params[1];
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы отдали %s %d грамм нарко", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s отдал вам %d грамм нарко", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* %s передает %s наркотики", sendername, playername);
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);

	return 1;
}

CMD:outdrugs(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pDrugs] <= 0) return Send(playerid, COLOR_GREY, "” ¬ас нет нарко!");
	format(string, sizeof string, "* %s выкидывает все наркотики.", GetName(playerid));
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Pl::Info[playerid][pDrugs] = 0;
	return 1;
}

CMD:outmats(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pMats] <= 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет материалов!");
	format(string, sizeof string, "* %s выкидывает все материалы.", GetName(playerid));
	ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
	Pl::Info[playerid][pMats] = 0;
	return 1;
}

CMD:healme(playerid, params[]) {
	if(Pl::Info[playerid][pLocal] != 0) {
		new house = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
		if(IsValidHouse(house)) {
			if(IsPlayerInRangeOfPoint(playerid, 9.0, HouseInfo[house][hExit][0], HouseInfo[house][hExit][1], HouseInfo[house][hExit][2])
					&& HouseInfo[house][hVirtual] == GetPlayerVirtualWorld(playerid)) {
				SPD(playerid, D_HEALME, 0, "„то использовать?", "јптечку\nЅроню", "SELECT", "CANCEL");
			}
		}
	} else {
		if(IsPlayerInRangeOfPoint(playerid,3,1173.2563,-1323.3102,15.3943)||
				IsPlayerInRangeOfPoint(playerid,3,2029.5945,-1404.6426,17.2512)) return Send(playerid, COLOR_GREY, "¬ы не в Ѕольнице !");
		if(STDPlayer[playerid] <= 0) return Send(playerid, COLOR_GREY, "¬ы не больны!");
		switch(STDPlayer[playerid]) {
		case 1: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы были вылечены от ’ломидии.");
		case 2: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы были вылечены от √онореи.");
		case 3: Send(playerid, COLOR_LIGHTBLUE, "* ¬ы были вылечены от —ифилиса.");
		}
		STDPlayer[playerid] = 0; Rac::GivePlayerMoney(playerid, -1000);
		Send(playerid, COLOR_CYAN, "ƒоктор: ¬аш медицинский счет составил 1000$. ¬сего хорошего!");
	}
	return 1;
}

CMD:kickjob(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER1LVL)) return Send(playerid,COLOR_GREY,"* ¬ам не доступна эта функци€");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /kickjob [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	Iter::Remove(JobPlayers[Pl::Info[params[0]][pJob]], playerid);
	Pl::Info[params[0]][pJob] = 0;
	Pl::Info[params[0]][pContractTime] = 0;
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /kickjob к игроку %s[%d]", sendername, playername, params[0]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s уволил вас с работы!", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);

	return 1;
}

CMD:uval(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid,COLOR_GREY,"* ¬ам не доступна эта функци€");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GRAD2, "¬ведите: /uval [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!Pl::Info[params[0]][pMember]) return Send(playerid, COLOR_GREY, "* Ётот не состоит не где!");
	new fracid = Pl::Info[params[0]][pMember];
	Pl::Info[params[0]][pMember] = 0;
	Pl::Info[params[0]][pRank] = 0;
	switch(Pl::Info[params[0]][pSex]) {
	case 1: Pl::Info[params[0]][pChar] = 72;
	case 2: Pl::Info[params[0]][pChar] = 55;
	default: Pl::Info[params[0]][pChar] = 79;
	}
	MedicBill[params[0]] = false;
	Pl::SetSpawnInfo(playerid);
	Rac::SpawnPlayer(params[0]);
	Iter::Remove(TeamPlayers[fracid], params[0]);
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "[AdmWarn] * %s применил команду /uval к игроку %s[%d][%s]", sendername, playername, params[0], FracInfo[fracid][fName]);
	SendToAdmin(COLOR_YELLOW, string, 1, 3);
	format(string, sizeof string, "* јдминистратор %s уволил вас из фракции!", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:eject(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(GetPlayerState(playerid) != 2) return Send(playerid,COLOR_GREY,"* ¬ы не за рулем!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬ведите: /eject [playerid]");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "¬ы не можете изгнать себ€!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInVehiclePlayer(playerid, params[0])) return Send(playerid, COLOR_GREY, "* “от игрок не находитс€ в вашем автомобиле!");

	new Float:x, Float:y, Float:z;
	GetCoordVehicleParams(GetPlayerVehicleID(playerid), 1, x, y, z);
	SetPlayerPos(params[0], x, y, z);

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы выкинули %s из автомобил€!", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ¬ы были выкинуты из автомобил€ %s!", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:sex(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(Pl::Info[playerid][pJob] == 3) return Send(playerid, COLOR_GREY, "¬ы не Ўлюха!");
	if(!IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не в автомобиле!");
	if(sscanf(params, "ud", params[0], params[1])) return Send(playerid, COLOR_GREY, "¬ведите: /sex [playerid] [price]");
	if(params[1] < 1 || params[1] > 99999) return Send(playerid, COLOR_GREY, "* ÷ена не должна быть меньше 1, или выше 99999!");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можите ублажать сами себ€!");
	if(!IsPlayerInRangeOfPlayer(playerid, 8.0, params[0])) return Send(playerid, COLOR_GREY, "* “от игрок не около ¬ас!");
	if(!IsPlayerInAnyVehicle(playerid) && !IsPlayerInVehicle(params[0], GetPlayerVehicleID(playerid))) return Send(playerid, COLOR_GREY, "* ¬ы или другой игрок должны быть в автомобиле!");
	SexOffer[params[0]] = playerid; SexPrice[params[0]] = params[1];
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы придложили клиенту %s зан€тс€ сексом за $%d.", playername, params[1]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* Ўлюха %s вас секс за $%d (чтобы прин€ть /accept sex)", sendername, params[1]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:wanted(playerid, params[]) { new string[144], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	Send(playerid, COLOR_GREEN, "* ¬ –ќ«џ— ≈:");
	foreach(new i: WantedPlayers) {
		static count;
		if(count >= 5) {
			count = 0;
			string[strlen(string)-2] = '\0';
			Send(playerid, COLOR_YELLOW, string);
			string[0] = '\0';
		} else {
			count ++;
			GetPlayerName(i, playername, 24);
			scf(string, temp, "%s[%i]: %i. ", playername, i, Pl::Info[i][pWantedL]);
		}
	}
	if(strlen(string)) Send(playerid, COLOR_YELLOW, string);
	return 1;
}

CMD:dropcar(playerid, params[]) {
	if(Pl::Info[playerid][pJob] != 5) return Send(playerid, COLOR_GREY, "¬ы не јвтоугонщик !");
	if(Pl::Info[playerid][pCarTime] != 0) return Send(playerid, COLOR_GREY, "¬ы уже продали автомобиль, ждите пока закончитс€ врем€!");
	GameTextForPlayer(playerid, "~w~Car Selling ~n~~r~Drop the car at the Crane", 5000, 1);
	CP[playerid] = 1;
	DestroyDynamicCP(checkpoints[playerid]);
	checkpoints[playerid] = CreateDynamicCP(-1548.3618,123.6438,3.2966,8.0,-1,-1,playerid,99999.9);
	return 1;
}

CMD:quitjob(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pJob] <= 0) return Send(playerid, COLOR_GREY, "* ¬ы не устроены на работу!");
	if(Pl::Info[playerid][pVip] > 0) {
		if(Pl::Info[playerid][pContractTime] <= 4) {
			Iter::Remove(JobPlayers[Pl::Info[playerid][pJob]], playerid);
			Pl::Info[playerid][pJob] = 0;
			Pl::Info[playerid][pContractTime] = 0;
			Send(playerid, COLOR_LIGHTBLUE, "* ¬ы уволились с работы!");
		} else {
			format(string, sizeof string, "* ¬ам нужно отработать %d часов, чтобы уволитьс€ с работы!", Pl::Info[playerid][pContractTime]);
			Send(playerid, COLOR_LIGHTBLUE, string);
		}
	} else {
		if(!Pl::Info[playerid][pContractTime]) {
			Iter::Remove(JobPlayers[Pl::Info[playerid][pJob]], playerid);
			Pl::Info[playerid][pJob] = 0;
			Pl::Info[playerid][pContractTime] = 0;
			Send(playerid, COLOR_LIGHTBLUE, "* ¬ы отработали 5 часов по контракту и уволились с работы.");
		} else {
			format(string, sizeof string, "* ¬ам нужно отработать %d часов, чтобы уволитьс€ с работы!", Pl::Info[playerid][pContractTime]);
			Send(playerid, COLOR_LIGHTBLUE, string);
		}
	}
	return 1;
}

CMD:bail(playerid, params[]) { new string[144];
	if(Pl::Info[playerid][pJailed] != 1) return Send(playerid, COLOR_GREY, "* ¬ы не находитесь в тюрьме!");
	if(JailPrice[playerid] <= 0) Send(playerid, COLOR_GREY, "* ¬ы не можите выйти под залог!");
	if(Rac::GetPlayerMoney(playerid) > JailPrice[playerid]) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
	JailPrice[playerid] = 0; WantLawyer[playerid] = 0; CallLawyer[playerid] = 0;
	Pl::Info[playerid][pJailTime] = 1; Rac::GivePlayerMoney(playerid, -JailPrice[playerid]);
	format(string, sizeof string, "* ¬ы выпустили себ€ за: $%d", JailPrice[playerid]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:clear(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬велите: /clear [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете оправдатьс€!");
	if(IsPlayerInRangeOfPoint(playerid,3.0, 253.9280,69.6094,1003.6406) || IsPlayerInRangeOfPoint(playerid,3.0, 256.7318,188.2524,1008.1719)) {
		if(IsACop(playerid)) {
			// ќчищаем розыск
			Pl::SetWantedLevel(params[0], 0);
			ClearCrime(params[0]);

			// ¬ыводим сообщение
			getname(playerid -> sendername,params[0] -> playername);
			format(string, sizeof string, "* ¬ы очистили уровень розыска подозреваемого %s.", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ќфицер %s очистил ¬аш уровень розыска.", sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);

		} else if(IsAMafia(playerid)) {
			if(Pl::FracID(params[0]) != Pl::FracID(playerid)) return Send(playerid, COLOR_GREY, "* “от игрок не находитс€ в вашей семье!");
			if(Pl::Info[params[0]][pRank] < 4) return Send(playerid, COLOR_GREY, "¬ы нуждаетесь в 4 ранге, чтобы очистить уровни розыска!");
			if(Rac::GetPlayerMoney(playerid) < 5000) return Send(playerid, COLOR_GREY, "¬ы нуждаетесь в 5000$, чтобы очистить розыск вашему члену семьи!");

			// ќчищаем розыск
			Pl::SetWantedLevel(params[0], 0);
			ClearCrime(params[0]);
			Rac::GivePlayerMoney(playerid, -5000);

			// ¬ыводим сообщение
			getname(playerid -> sendername,params[0] -> playername);
			format(string, sizeof string, "* ¬ы очистили розыск подозреваемого %s за 5000$.", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* „лен семьи %s %s, очистил ¬аш розыск.", RankInfo[Pl::FracID(playerid)][Pl::Info[playerid][pRank]], sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);

		} else if(IsAGang(playerid)) {
			if(Pl::FracID(params[0]) != Pl::FracID(playerid)) return Send(playerid, COLOR_GREY, "* “от игрок не находитс€ в вашей семье!");
			if(Pl::Info[params[0]][pRank] < 4) return Send(playerid, COLOR_GREY, "¬ы нуждаетесь в 4 ранге, чтобы очистить уровни розыска!");
			if(Rac::GetPlayerMoney(playerid) < 5000) return Send(playerid, COLOR_GREY, "¬ы нуждаетесь в 5000$, чтобы очистить розыск вашему члену семьи!");

			// ќчищаем розыск
			Pl::SetWantedLevel(params[0], 0);
			ClearCrime(params[0]);
			Rac::GivePlayerMoney(playerid, - 5000);

			// ¬ыводим сообщение
			getname(playerid -> sendername,params[0] -> playername);
			format(string, sizeof string, "* ¬ы очистили розыск подозреваемого %s за 5000$.", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* „лен семьи %s %s, очистил ¬аш розыск.", RankInfo[Pl::FracID(playerid)][Pl::Info[playerid][pRank]], sendername);
			Send(params[0], COLOR_LIGHTBLUE, string);
		}
	}
	else Send(playerid, COLOR_GRAD2, "¬ы не в ќтделении полиции!");

	return 1;
}

CMD:aclear(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!Pl::isAdmin(playerid, MODER3LVL)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
	if(sscanf(params, "u", params[0])) return Send(playerid, COLOR_GREY, "¬велите: /clear [id/Name]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(params[0] == playerid) return Send(playerid, COLOR_GREY, "* ¬ы не можете оправдатьс€!");

	// ќчищаем розыск
	Pl::SetWantedLevel(params[0], 0);
	ClearCrime(params[0]);

	// ¬ыводим сообщение
	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы очистили уровень розыска подозреваемого %s.", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* јдминистратор %s очистил ваш уровень розыска.", sendername);
	Send(params[0], COLOR_LIGHTBLUE, string);
	return 1;
}

CMD:ticket(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	if(!OnDuty[playerid] && Pl::FracID(playerid) == 1) return Send(playerid, COLOR_GREY, "¬ы не при исполнении служебных об€занностей!");
	if(sscanf(params, "uds[24]", params[0], params[1], params[2])) return Send(playerid, COLOR_GREY, "¬ведите: /ticket [playerid] [price] [reason]");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не залогинен!");
	if(params[1] < 1 || params[1] > 99999) return Send(playerid, COLOR_GREY, "* Ўтраф не может быть ниже $1 или выше $99999!");
	if(!IsPlayerInRangeOfPlayer(playerid, 5.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не около вас!");

	TicketOffer[params[0]] = playerid;
	TicketMoney[params[0]] = params[1];

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы выписали %s штаф на сумму $%d | ѕричина: %s", playername, params[1], params[2]);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "* ќфицер %s выписал вам штраф на сумму $%d, причина: %s", sendername, params[1], params[2]);
	Send(params[0], COLOR_LIGHTBLUE, string);
	Send(params[0], COLOR_LIGHTBLUE, "* Ќапишите /accept ticket, чтобы прин€ть штраф.");
	return 1;
}

CMD:arrest(playerid, params[]) { new string[144], sendername[24], playername[24];
	if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
	if(!OnDuty[playerid] && Pl::FracID(playerid) == 1) return Send(playerid, COLOR_GREY, "* ¬ы не при исполнении служебных об€занностей!");
	if(!IsPlayerInRangeOfPoint(playerid, 10.0, 221.5466,114.4304,999.0156)) return Send(playerid, COLOR_GREY, "* ¬ы не около камеры, не может арестовать!");
	if(sscanf(params, "uiiI(0)I(1)", params[0], params[1], params[2], params[3], params[4])) return Send(playerid, COLOR_GREY, "¬ведите: /arrest [id/Name] [price] [time] [bail] [bailprice]");
	if(params[1] < 1 || params[1] > 99999) return Send(playerid, COLOR_GREY, "* ÷ена на арест не может быть ниже 1$ или выше 99999$ !");
	if(params[2] < 1 || params[2] > 20) return Send(playerid, COLOR_GREY, "* ћинуты тюремного заключени€ не могут быть ниже 1, или выше 20!");
	if(params[3] < 0 || params[3] > 1) return Send(playerid, COLOR_GREY, "* ¬ыпуск “юрьмы не может быть ниже 0 или выше 1!");
	if(params[4] < 0 || params[4] > 3000000) return Send(playerid, COLOR_GREY, "* Ўтраф не может быть ниже 0$ или выше 3000000$ !");
	if(!Pl::isLogged(params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
	if(!IsPlayerInRangeOfPlayer(playerid, 3.0, params[0])) return Send(playerid, COLOR_GREY, "* Ётот игрок слишком далеко от вас");
	if(Pl::Info[params[0]][pWantedL] < 1) return Send(playerid, COLOR_GREY, "* »грок должен по крайней мере быть в розыске!");
	if(IsACop(params[0])) return Send(playerid,COLOR_GREY,"* Ќельз€ сажать своих");
	new sekjail = params[2]*60;
	Rac::GivePlayerMoney(params[0], -params[1]);
	Jailed(params[0], sekjail, 1);
	SetPlayerFree(params[0], playerid, "Got Arrested");
	if(params[3] == 1) {
		JailPrice[params[0]] = params[4];
		format(string, sizeof string, "¬ы заключены в тюрьму в течение %i минут. «алог: $%d", params[2], JailPrice[params[0]]);
		Send(params[0], COLOR_LIGHTBLUE, string);
	} else {
		JailPrice[params[0]] = 0;
		format(string, sizeof string, "¬ы заключены в тюрьму в течение %i минут. «алог: Ѕез залога", params[2]);
		Send(params[0], COLOR_LIGHTBLUE, string);
	}

	getname(playerid -> sendername,params[0] -> playername);
	format(string, sizeof string, "* ¬ы арестовали %s!", playername);
	Send(playerid, COLOR_LIGHTBLUE, string);
	format(string, sizeof string, "arrested by %s ~n~    for $%d", sendername, params[1]);
	GameTextForPlayer(params[0], string, 5000, 5);

	switch(Pl::FracID(playerid)) {
	case 1 : strunpack(temp, !"ќфицер" );
	case 2 : strunpack(temp, !"јгент ‘Ѕ–" );
	case 3 : strunpack(temp, !"—олдат" );
	}
	format(string, sizeof string, "<< %s %s арестовал подозреваемого %s >>", temp, sendername, playername);
	OOCNews(COLOR_LIGHTRED, string);

	return 1;
}


CMD:dice(playerid, params[]) { new string[144];
	if(!gDice[playerid]) return Send(playerid, COLOR_GRAD2, "* ” ¬ас нет костей!");
	new dice = random(6)+1;
	format(string, sizeof string, "* %s бросает кости. ¬ыпало число %d", GetName(playerid), dice);
	ProxDetector(5.0, playerid, string, COLOR_GREEN, COLOR_GREEN, COLOR_GREEN, COLOR_GREEN, COLOR_GREEN);
	return 1;
}


public OnPlayerText(playerid, text[]) {
	if(isnull(text) || text[0] == ' ') return 0;
	if(!Pl::isLogged(playerid)) return !Send(playerid, COLOR_GREY, "* ¬ы не авторизованы!");
	if(Gag[playerid]) return !Send(playerid,COLOR_GREY,"* ” ¬ас кл€п во рту!");
	if(IsPMuted(playerid))return !Send(playerid, COLOR_CYAN, "* јдмин отн€л у вас возможность говорить в главном чате.");

	new tmp[32], string[144], sendername[25], giveplayer[25];
    if(MarriageCeremoney[playerid])
	{
	    if((strcmp(text, "yes", true) == 0) && (strlen(text) == strlen("yes")))
		{
		    if(GotProposedBy[playerid] != INVALID_PLAYER_ID)
		    {
			    if(IsPlayerConnected(GotProposedBy[playerid]))
				{
					GetPlayerName(playerid, sendername, sizeof(sendername));
					GetPlayerName(GotProposedBy[playerid], giveplayer, sizeof(giveplayer));
				    format(string, sizeof(string), "{FFA500}Х—в€щенник: {FFFFFF}%s ¬ы берЄте %s свою прекрасную жену? (напишите 'yes', чтобы согласитьс€).", giveplayer,sendername);
					SendClientMessage(GotProposedBy[playerid], COLOR_WHITE, string);
					MarriageCeremoney[GotProposedBy[playerid]] = 1;
					MarriageCeremoney[playerid] = 0;
					GotProposedBy[playerid] = INVALID_PLAYER_ID;
				    return 1;
			    }
			    else
			    {
			        MarriageCeremoney[playerid] = 0;
			        GotProposedBy[playerid] = INVALID_PLAYER_ID;
			        return false;
			    }
			}
			else if(ProposedTo[playerid] != INVALID_PLAYER_ID)
			{
			    if(IsPlayerConnected(ProposedTo[playerid]))
				{
					GetPlayerName(playerid, sendername, sizeof(sendername));
					GetPlayerName(ProposedTo[playerid], giveplayer, sizeof(giveplayer));
					format(string, sizeof(string), "{FFA500}Х —в€щенник: {FFFFFF}”важаемые {FFA500}%s {FFFFFF}и {FFA500}%s {FFFFFF}теперь вы €вл€етесь мужем и женой.", sendername, giveplayer);
					SendClientMessage(playerid, COLOR_WHITE, string);
				   	format(string, sizeof(string), "{FFA500}Х —в€щенник:  {FFFFFF}”важаемые {FFA500}%s {FFFFFF}и {FFA500}%s {FFFFFF}€ объ€вл€ю ¬ас теперь ћужем и ∆еной, теперь вы можете поцеловать ∆ениха.", giveplayer, sendername);
					SendClientMessage(ProposedTo[playerid], COLOR_WHITE, string);
					format(string, sizeof(string), "{FFFFFF}ѕоздравл€ем у нас нова€ семейна€ пара {FFA500}%s {FFFFFF}и {FFA500}%s.", sendername, giveplayer);
					OOCNews(COLOR_WHITE, string);
					MarriageCeremoney[ProposedTo[playerid]] = 0;
					MarriageCeremoney[playerid] = 0;
					format(string, sizeof(string), "%s", sendername);
					strmid(Pl::Info[ProposedTo[playerid]][pMarriedTo], string, 0, strlen(string), 25);
					format(string, sizeof(string), "%s", giveplayer);
					strmid(Pl::Info[playerid][pMarriedTo], string, 0, strlen(string), 25);
					GivePlayerMoney(playerid, - 100000);
					Pl::Info[playerid][pMarried] = 1;
					Pl::Info[ProposedTo[playerid]][pMarried] = 1;
					//Pl::Info[ProposedTo[playerid]][pPhousekey] = Pl::Info[playerid][pPhousekey];
					//Pl::Info[ProposedTo[playerid]][pPbiskey] = Pl::Info[playerid][pPbiskey];
					ProposedTo[playerid] = INVALID_PLAYER_ID;
					MarriageCeremoney[playerid] = 0;
				    return false;
			    }
			    else
			    {
			        MarriageCeremoney[playerid] = 0;
			        ProposedTo[playerid] = INVALID_PLAYER_ID;
			        return false;
			    }
			}
		}
		else
		{
		    if(GotProposedBy[playerid] != INVALID_PLAYER_ID)
		    {
				if(IsPlayerConnected(GotProposedBy[playerid]))
				{
					GetPlayerName(playerid, sendername, sizeof(sendername));
					GetPlayerName(GotProposedBy[playerid], giveplayer, sizeof(giveplayer));
					format(string, sizeof(string), "¬ы нехотели вступить в брак с {FFA500}%s, {FFFFFF}вы несказали {FFA500}'yes'.",giveplayer);
				    SendClientMessage(playerid, COLOR_WHITE, string);
				    format(string, sizeof(string), "{FFA500}%s {FFFFFF}хочет вступить с вами в брак, скажите {FFA500}'yes' {FFFFFF}чтобы прин€ть.",sendername);
				    SendClientMessage(GotProposedBy[playerid], COLOR_YELLOW, string);
				    return false;
			    }
			    else
			    {
			        MarriageCeremoney[playerid] = 0;
			        GotProposedBy[playerid] = INVALID_PLAYER_ID;
			        return false;
			    }
		    }
		    else if(ProposedTo[playerid] != INVALID_PLAYER_ID)
			{
			    if(IsPlayerConnected(ProposedTo[playerid]))
				{
					GetPlayerName(playerid, sendername, sizeof(sendername));
					GetPlayerName(ProposedTo[playerid], giveplayer, sizeof(giveplayer));
					format(string, sizeof(string), "¬ы нехотели вступить в брак с {FFA500}%s, {FFFFFF}вы несказали {FFA500}'yes'.",giveplayer);
				    SendClientMessage(playerid, COLOR_YELLOW, string);
				    format(string, sizeof(string), "{FFA500}%s {FFFFFF}хочет вступить с вами в брак, скажите {FFA500}'yes' {FFFFFF}чтобы прин€ть.",sendername);
				    SendClientMessage(ProposedTo[playerid], COLOR_YELLOW, string);
				    return false;
			    }
			    else
			    {
			        MarriageCeremoney[playerid] = 0;
			        ProposedTo[playerid] = INVALID_PLAYER_ID;
			        return false;
			    }
			}
		}
	    return false;
	}
	if(OnAir[playerid]) {
		new veh = GetPlayerVehicleID(playerid);
		if(IsPlayerInRangeOfPoint(playerid,5.0,353.4343,272.8408,1008.6656)) {
			switch(++Pl::Info[playerid][pSkill][6]) {
			case 50 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 2");
			case 100 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 3");
			case 200 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 4, теперь вы можете управл€ть вертолетом");
			case 400 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 5, теперь вы можете брать интервью");
			}
			GetPlayerName(playerid, sendername, 24);
			format(string, sizeof(string), "*[ѕресса] %s: %s", sendername, text);
			OOCNews(COLOR_LIGHTBLUE, string);
		} else if(veh != 0) {
			if(IsANews(veh)) {
				switch(++Pl::Info[playerid][pSkill][6]) {
				case 50 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 2");
				case 100 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 3");
				case 200 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 4, теперь вы можете управл€ть вертолетом");
				case 400 : Send(playerid, COLOR_YELLOW, "* ¬аш Ќавык –епортера Ќовостей - теперь ”ровень 5, теперь вы можете брать интервью");
				}
				GetPlayerName(playerid, sendername, 24);
				format(string, sizeof(string), "*[ѕресса] %s: %s", sendername, text);
				OOCNews(COLOR_LIGHTBLUE, string);
			}
		}
		return 0;
	}

	if(TalkingLive[playerid] != INVALID_PLAYER_ID) {
		GetPlayerName(playerid, sendername, sizeof(sendername));
		if(Pl::FracID(playerid) == 9) {
			format(string, sizeof(string), "*[ѕресса] –епортер %s: %s", sendername, text);
			OOCNews(0x5CFEB9AA, string);
		} else {
			format(string, sizeof(string), "*[ѕресса] »нтервьюер %s: %s", sendername, text);
			OOCNews(0x5CFEB9AA, string);
		}
		return 0;
	}

	if(CallLawyer[playerid] == 111) {
		sscanf(text, "s[24]", tmp);
		if((strcmp("yes", tmp, true, strlen(tmp)) == 0) && (strlen(tmp) == strlen("yes"))) {
			WantLawyer[playerid] = 0;
			CallLawyer[playerid] = 0;
			GetPlayerName(playerid, sendername, sizeof(sendername));
			format(string, sizeof(string), "** %s находитс€ в “юрьме, и нуждаетс€ в јдвокате. ѕройдите в ќтделение полиции.", sendername);
			SendJobMessage(2, COLOR_AZTECAS, string);
			SendJobMessage(2, COLOR_AZTECAS, "*  огда ¬ы в ќтделении полиции, попросите, чтобы офицер одобрил ¬ас с /accept lawyer.");
			Send(playerid, COLOR_LIGHTRED, "—ообщение послали всем доступным јдвокатам, пожалуйста ждите.");
			return 0;
		} else {
			WantLawyer[playerid] = 0;
			CallLawyer[playerid] = 0;
			Send(playerid, COLOR_LIGHTRED, "Ќет јдвоката, доступного дл€ ¬ас, “юремное заключение началось.");
		}
		return 0;
	}

	if(Mobile[playerid] != INVALID_PLAYER_ID) {
		if(Pl::isLogged(Mobile[playerid])) {
			if(Mobile[Mobile[playerid]] == playerid) {
				GetPlayerName(playerid, sendername, sizeof(sendername));
				format(string, sizeof(string), "%s говорит (телефон): %s", sendername, text);
				ProxDetector(10.0, playerid, string);
				Send(Mobile[playerid], COLOR_FADE1, string);
			}
		}
		return 0;
	}

	if(Pl::Info[playerid][pMaskOn]) {
		format(string, sizeof(string), "Ќеизвесный говорит: %s", text);
		ProxDetector(20.0, playerid, string);
		if(!IsPlayerInAnyVehicle(playerid)) {
			AnimClear[playerid] = 4;
			ApplyAnimation(playerid,"PED","IDLE_chat",4.1,0,1,1,1,1);
		}
	} else {
		GetPlayerName(playerid, sendername, sizeof(sendername));
		format(string, sizeof(string), "* %s[%i] сказал: %s", sendername, playerid, text);
		SetPlayerChatBubble(playerid, text, COLOR_GREEN, 50.0, 10000);
		ProxDetector(20.0, playerid, string);
		if(!IsPlayerInAnyVehicle(playerid)) {
			AnimClear[playerid] = 4;
			ApplyAnimation(playerid,"PED","IDLE_chat",4.1,0,1,1,1,1);
		}
	}

	return 0;
}

stock FixHour(hour) {
	hour = timeshift+hour;
	if(hour < 0) {
		hour = hour+24;
	} else if(hour > 23) {
		hour = hour-24;
	}
	shifthour = hour;
	return 1;
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[]) {

	new string[256];
	switch(dialogid) {

	case D_NONE : { }
	case 4430:
	{
	    if(response)
	    {

	        switch(listitem)
	        {
	            case 0: SPD(playerid, 4431, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", "LSPD\nFBI\nјрми€\nЅольница\nћэри€\nCNN\n“акси\nЋицензеры\nLCN\nякудза\n–усска€ ћафи€\n‘ерма\nSD", "¬ыбрать", "ќтмена");
				case 1: SPD(playerid, 4432, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", "Grove Street Gang\nThe Coronos Gang\nThe Ballas Gang\nThe Rifa Gang\nThe Vagos Gang", "¬ыбрать", "ќтмена");
				case 2: SPD(playerid, 4433, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", "јвтоугонщик\nјвтобусник\n√андилер\nЌаркодилер\nћеханик\n–абота на заводе\nѕроститутка\nƒетектив\nјвтодилер\nƒальнобойщик", "¬ыбрать", "ќтмена");
				case 3: SPD(playerid, 4434, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", "Ammo #1\nAmmo #2\nAmmo #3\nAmmo #4\nAmmo #5\n24/7 #1\n24/7 #2\n24/7 #3\n24/7 #4", "¬ыбрать", "ќтмена");
				case 4: SPD(playerid, 4435, DIALOG_STYLE_LIST, "{2641FE}-===GPS===-", "√ора \"„илиад\"\nЅанк Ћ—\nћа€к\nѕроды Ћ—\nѕроды —‘\n√араж —‘\n√араж Ћ¬\n√араж Ћ—", "¬ыбрать", "ќтмена");
				case 5:
	            {
	           		DisablePlayerRaceCheckpoint(playerid);
					GameTextForPlayer(playerid, "~r~last point~n~is removed", 5000, 1);
	            }
	        }
		}
	}
	case 4431:
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1535.7499,-1674.2941,13.3828, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 1:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1564.8955,661.2197,7.1475, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 2:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1551.5413,515.5958,7.0313, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 3:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2647.5898,702.3922,27.9323, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 4:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1485.2029,-1738.7026,13.5469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 5:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 644.5140,-1366.9736,13.6221, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 6:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1757.9419,952.0552,24.7422, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 7:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2048.1924,-77.2300,35.1719, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 8:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1268.3710,-2054.5437,59.2077, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 9:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1537.6870,2776.0701,10.7721, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 10:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2655.2537,-216.1471,4.2821, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 11:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1047.6936,-1352.3571,130.0491, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 12:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1052.7041,2060.5642,10.8203, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	        }
		}
	}
	case 4432:
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2424.7590,-1660.7588,13.3828, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 1:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1818.4347,-1882.3317,13.3996, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 2:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 959.7101,-1097.9653,23.6934, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 3:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2128.1697,-72.8768,35.1797, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 4:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2828.5667,-1569.9041,10.9219, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
			}
		}
	}
	case 4433:
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1094.2836,-1796.1046,13.6039, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 1:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1152.5359,-1746.9758,13.5703, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 2:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1362.9254,-1275.7917,13.5469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 3:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2170.5881,-1677.7448,15.0859, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 4:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1929.9771,274.2182,41.0469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 5:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1821.7500,33.0463,15.1228, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 6:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2412.4224,-1225.4891,24.5832, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 7:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1472.9645,-1740.6379,13.5469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 8:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 535.6503,-1289.7094,17.2422, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 9:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -81.5991,-1132.8804,1.0781, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
			}
		}
	}
	case 4434:
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2628.3267,211.4520,4.5542, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 1:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2154.7234,942.3593,10.8203, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 2:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2006.7460,-1055.4338,24.6029, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 3:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2395.9448,-1977.9297,13.5469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 4:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1363.3578,-1283.8812,13.5469, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 5:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1828.5229,-1845.3737,13.5781, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 6:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1317.2841,-914.8426,37.8572, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 7:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1347.2001,-1744.7318,13.3810, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 8:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2429.1106,736.0276,35.0156, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
			}
		}
	}
	case 4435:
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2336.4136,-2184.0906,34.8216, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 1:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1466.1642,-1027.8749,23.8281, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 2:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 152.6167,-1923.3624,3.7696, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 3:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 2758.4922,-2426.2739,13.4997, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 4:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -1851.2051,-219.9725,18.3750, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 5:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, -2429.8389,495.4094,29.9218, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 6:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 1665.6433,953.3226,10.6644, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
	            case 7:
	            {
					SetPlayerRaceCheckpoint(playerid, 1, 793.4975,-1542.6520,13.5611, 0.0, 0.0, 0.0, 3);
					CP[playerid] = 0;
					Send(playerid, COLOR_WHITE, "ћесто помечено на карте красной меткой");
	            }
			}
		}
	}
	case 10000: // предложение
	{
	    if(response)
	    {
		    if(ProposeOffer[playerid] != INVALID_PLAYER_ID)
	  		{
	  			if(!IsPlayerInRangeOfPoint(playerid, 30.0, 1233.6467, -1564.8873, 3277.1545)) SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}¬ы не в ÷еркви!");
				else
				{
					if(IsPlayerConnected(ProposeOffer[playerid]))
		  			{
		  				if(MarryWitness[ProposeOffer[playerid]] == INVALID_PLAYER_ID) SendClientMessage(playerid, COLOR_RED1, "x {FFFFFF}—видетель отсутствует!");
						else
						{
							if(IsPlayerConnected(MarryWitness[ProposeOffer[playerid]]))
				    		{
				    		    new sendername[25], giveplayer[25];
				    		    GetPlayerName(playerid, sendername, sizeof(sendername));
				    			GetPlayerName(ProposeOffer[playerid], giveplayer, sizeof(giveplayer));
								format(string, sizeof(string), "Х {FFFFFF}¬ы прин€ли предложение от {00FF00}%s {FFFFFF}о бракосочетании", giveplayer);
								SendClientMessage(playerid, COLOR_LIME, string);
								format(string, sizeof(string), "Х {FFFFFF}%s {FFFFFF}прин€ла предложение о бракосочетании.", sendername);
								SendClientMessage(ProposeOffer[playerid], COLOR_LIME, string);
								format(string, sizeof(string), "Х {FFFFFF}—в€щенник: {FFA500}%s {FFFFFF}вы берете %s в мужь€? ({FFA500}'yes'{FFFFFF} чтобы согласитьс€)", sendername, giveplayer);
								SendClientMessage(playerid, COLOR_ORANGE, string);
								MarriageCeremoney[playerid] = 1;
								ProposedTo[ProposeOffer[playerid]] = playerid;
								GotProposedBy[playerid] = ProposeOffer[playerid];
								MarryWitness[ProposeOffer[playerid]] = INVALID_PLAYER_ID;
								ProposeOffer[playerid] = INVALID_PLAYER_ID;
							}
						}
					}
				}
			}
		}
		else
		{
		    if(ProposeOffer[playerid] != INVALID_PLAYER_ID)
			{
				ProposeOffer[playerid] = INVALID_PLAYER_ID;
				SendClientMessage(playerid, COLOR_WHITE, "{b0daf9}Х {FFFFFF}¬ы отказались от Ѕракосочетани€");
			}
		}
		return true;
	}
	case 10001: // свидетель
	{
	    if(response)
	    {
		    if(MarryWitnessOffer[playerid] != INVALID_PLAYER_ID)
			{
				if(IsPlayerConnected(MarryWitnessOffer[playerid]))
	  			{
	  			    new name[25];
	  				GetPlayerName(MarryWitnessOffer[playerid], name, sizeof(name));
					format(string, sizeof(string), "Х {FFFFFF}¬ы прин€ли {b0daf9}%s{FFFFFF} просите быть его —видетелем Ѕрака.", name);
					SendClientMessage(playerid,COLOR_WHITE, string);
					GetPlayerName(playerid, name, sizeof(name));
					format(string, sizeof(string), "Х {FFFFFF}%s прин€л ¬аш запрос быть ¬ашим —видетелем Ѕрака.", name);
					SendClientMessage(MarryWitnessOffer[playerid], COLOR_WHITE, string);
					MarryWitness[MarryWitnessOffer[playerid]] = playerid;
					MarryWitnessOffer[playerid] = INVALID_PLAYER_ID;
	  			}
			}
		}
		else
		{
		    if(MarryWitnessOffer[playerid] != INVALID_PLAYER_ID)
			{
				MarryWitnessOffer[playerid] = INVALID_PLAYER_ID;
				SendClientMessage(playerid, COLOR_WHITE, "{b0daf9}Х {FFFFFF}¬ы отказались от —видетел€");
			}
		}
		return true;
	}
	case 10002: // развод
	{
	    if(response)
	    {
		    if(DivorceOffer[playerid] != INVALID_PLAYER_ID)
	  		{
	    		if(IsPlayerConnected(DivorceOffer[playerid]))
	      		{
	      		    new name[25];
					GetPlayerName(DivorceOffer[playerid], name, sizeof(name));
					format(string, sizeof(string), "Х {FFFFFF}¬ы прин€ли {b0daf9}%s{FFFFFF} прос€т быть его —видетелем Ѕрака.", name);
					SendClientMessage(playerid, COLOR_WHITE, string);
					GetPlayerName(playerid, name, sizeof(name));
					format(string, sizeof(string), "Х {FFFFFF}%s прин€л ¬аш запрос быть ¬ашим —видетелем Ѕрака.", name);
					SendClientMessage(DivorceOffer[playerid], COLOR_WHITE, string);
					ClearMarriage(DivorceOffer[playerid]);
					ClearMarriage(playerid);
					//Pl::Info[playerid][pPhousekey] = 255;
					//Pl::Info[playerid][pPbiskey] = 255;
	    		}
			}
		}
		else
		{
		    if(DivorceOffer[playerid] != INVALID_PLAYER_ID)
			{
				DivorceOffer[playerid] = INVALID_PLAYER_ID;
				SendClientMessage(playerid, COLOR_WHITE, "{b0daf9}Х {FFFFFF}¬ы отказались от –азвода");
			}
		}
		return true;
	}
	case D_EV_MENU : {
			if(response) {
				format(string, sizeof string, "extra[%i]", listitem);
				new item = GetPVarInt(playerid, string);
				SetPVarInt(playerid, "SelectedItem", item);
				format(string, sizeof string, "“ранспорт: %s", VehicleNames[ExtraVehicles[playerid][item][evModel] - 400]);
				dialog[0]='\0';
				if(IsValidHouse(Pl::Info[playerid][pHouseKey])) scf(dialog, temp, "«аспавнить\nѕрипарковать");
				scf(dialog, temp, "\n»зменить цвет");
				SPD(playerid, D_EV_MENU+1, DIALOG_STYLE_LIST, string, dialog, "SELECT", "CANCEL");
			}
		}

	case D_EV_MENU+1 : {
			if(response) {
				new item = GetPVarInt(playerid, "SelectedItem");
				if(strfind(inputtext, "«аспавнить") != -1) {
					if(GetVehiclePassengers(ExtraVehicles[playerid][item][evID2])) return GameTextForPlayer(playerid, "~w~Car is~n~in ~r~use", 5000, 1);
					if(ExtraVehicles[playerid][item][evPark] == PARK_GARAGE) {
						Veh::Destroy(ExtraVehicles[playerid][item][evID2]);
					} else {
						SetVehicleToRespawn(ExtraVehicles[playerid][item][evID2]);
					}
					PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					Send(playerid, COLOR_LIGHTBLUE, "* “ранспорт отбуксирован на место парковки!");
				}

				else if(strfind(inputtext, "ѕрипарковать") != -1) {
					new hid = Pl::Info[playerid][pHouseKey];
					new veh = GetPlayerVehicleID(playerid);
					if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
					if(veh != ExtraVehicles[playerid][item][evID2]) return Send(playerid, COLOR_GREY, "* ¬ы должны сидеть в траспорте!");
					if(IsPlayerInRangeOfPoint(playerid, 50.0, HouseInfo[hid][hEnter][0], HouseInfo[hid][hEnter][1], HouseInfo[hid][hEnter][2])) {
						ExtraVehicles[playerid][item][evPark] = PARK_HOME;
					} else if(IsPlayerInHouseGarage(playerid)) {
						ExtraVehicles[playerid][item][evPark] = PARK_HOME_GARAGE * hid;
					} else {
						return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от дома!");
					}
					GetVehiclePos(veh, ExtraVehicles[playerid][item][evSpawnX], ExtraVehicles[playerid][item][evSpawnY], ExtraVehicles[playerid][item][evSpawnZ]);
					GetVehicleZAngle(veh, ExtraVehicles[playerid][item][evSpawnA]);
					Veh::Destroy(veh);
					RemoveExtraVehicleFromGarage(playerid, item);
					ExtraVehicles[playerid][item][evID2] = Veh::Create(
					ExtraVehicles[playerid][item][evModel],
					ExtraVehicles[playerid][item][evSpawnX],
					ExtraVehicles[playerid][item][evSpawnY],
					ExtraVehicles[playerid][item][evSpawnZ],
					ExtraVehicles[playerid][item][evSpawnA],
					ExtraVehicles[playerid][item][evColor1],
					ExtraVehicles[playerid][item][evColor2],
					INFINITY
					);
					AutoInfo[ExtraVehicles[playerid][item][evID2]][aOwner] = playerid;
					if((ExtraVehicles[playerid][item][evPark] / hid) == PARK_HOME_GARAGE) {
						LinkVehicleToInterior(ExtraVehicles[playerid][item][evID2], 3);
						SetVehicleVirtualWorld(ExtraVehicles[playerid][item][evID2], Pl::Info[playerid][pHouseKey]);
					}
					SetVehicleNumber(ExtraVehicles[playerid][item][evID2]);
					Rac::PutPlayerInVehicle(playerid, ExtraVehicles[playerid][item][evID2], 0);
					UpdateExtraVehicle(playerid, item);
					UpdateHouse(hid);
					format(string, sizeof string, "* “ранспорт %s был припаркован!", VehicleNames[ExtraVehicles[playerid][item][evModel] - 400]);
					Send(playerid, COLOR_YELLOW, string);

				}

				else if(strfind(inputtext, "»зменить цвет") != -1) {
					ShowDialog(playerid, D_EV_MENU+2, DIALOG_STYLE_INPUT, "ѕерекраска", "dialog/colors.txt", "ENTER", "CANCEL");
				}
			} else {
				ShowExtraVehiclesMenu(playerid);
			}
		}

	case D_EV_MENU+2 : {
			if(response) {
				if(sscanf(inputtext, "p<,>ii", inputtext[0], inputtext[1])) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_EV_MENU+2, DIALOG_STYLE_INPUT, "ѕерекраска", "dialog/colors.txt", "ENTER", "CANCEL");
				} else if(inputtext[0] < 0 || inputtext[0] > 127) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_EV_MENU+2, DIALOG_STYLE_INPUT, "ѕерекраска", "dialog/colors.txt", "ENTER", "CANCEL");
				} else if(inputtext[1] < 0 || inputtext[1] > 127) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_EV_MENU+2, DIALOG_STYLE_INPUT, "ѕерекраска", "dialog/colors.txt", "ENTER", "CANCEL");
				} else {
					new item = GetPVarInt(playerid, "SelectedItem");
					ExtraVehicles[playerid][item][evColor1] = inputtext[0];
					ExtraVehicles[playerid][item][evColor2] = inputtext[1];
					ChangeVehicleColor(ExtraVehicles[playerid][item][evID2], inputtext[0], inputtext[1]);
					UpdateExtraVehicle(playerid, item);

					format(string, sizeof string, "* ÷вет транспорта %s был изминен на %i|%i!", VehicleNames[ExtraVehicles[playerid][item][evModel] - 400], inputtext[0], inputtext[1]);
					Send(playerid, COLOR_YELLOW, string);
				}
			} else {
				ShowExtraVehiclesMenu(playerid);
			}
		}

	case D_EV_MENU+3 : {
			if(response) {
				format(string, sizeof string, "extra[%i]", listitem);
				new item = GetPVarInt(playerid, string);
				new targetid = GetPVarInt(playerid, "SelectedPlayer");
				SetPVarInt(playerid, "SelectedPlayer", INVALID_PLAYER_ID);
				if(Pl::isLogged(targetid)) {
					if(RemoveExtraVehicle(targetid, item)) {
						Send(playerid, COLOR_YELLOW, "* ƒоп. траспорт был удален!");
					}
				} else {
					Send(playerid, COLOR_GREY, "* »грок вышел из игры!");
				}
			}
		}

	case D_WAIT : {
			if(!response) return KickEx(playerid, "ƒл€ игры на сервере, ¬ы должны авторизоватс€!", COLOR_LIGHTRED);
			if(Pl::Info[playerid][pWait] > 0) {
				format(dialog, sizeof dialog, "ƒождитесь полной загрузки игры и нажмите ENTER!\n\
				ќсталось секунд: %i", Pl::Info[playerid][pWait]);
				SPD(playerid, D_WAIT, 0, "ѕодождите...",dialog, "ENTER", "");
			}
			return 1;
		}

	case D_AUTH : {
			if(!WrongLogin[playerid]) return Rac::Kick(playerid, "ѕопытка взлома аккаунта");
			if(!response) return KickEx(playerid, "ƒл€ игры на сервере, ¬ы должны авторизоватс€!", COLOR_LIGHTRED);
			if(!sscanf(inputtext, "s[36]", inputtext[0])) {
				new hash[SHA1_HASH_LEN];
				KeyProtect(inputtext[0], hash);
				format(query, sizeof query, "SELECT * FROM `"#__TableUsers__"` WHERE `ID` = '%i' AND `Key` = '%s'", Pl::Info[playerid][pID], hash);
				Db::tquery(connDb, query, "onPlayerLogin", "i", playerid);
			} else {
				ShowLoginForm(playerid, 1);
			}
		}

	case D_REGG : {
			if(!response) return KickEx(playerid, "ƒл€ игры на сервере, ¬ы должны согласитс€ с правилами игры!", COLOR_LIGHTRED);
			ShowLoginForm(playerid, 0);
		}

	case D_REGG + 1 : {
			if(!response) return KickEx(playerid, "ƒл€ игры на сервере, ¬ы должны зарегистрироватьс€!", COLOR_LIGHTRED);
			if(!sscanf(inputtext, "s[36]", inputtext[0])) {
				new hash[SHA1_HASH_LEN];
				KeyProtect(inputtext[0], hash);
				format(query, sizeof query, "INSERT INTO `"#__TableUsers__"` (`Name`,`Key`,`Fightstyle`) VALUES ('%s', '%s', '%i')",
				GetName(playerid), hash, FightStyles[random(sizeof FightStyles)]);
				Db::tquery(connDb, query, "onPlayerRegister", "i", playerid);
			} else {
				ShowLoginForm(playerid, 0);
			}
		}

	case D_REGG + 2 : {
			Pl::Info[playerid][pSex] = response ? 2 : 1;
			SPD(playerid, D_REGG + 3, 2, "Location", "Los Santos\nLas Venturas", "SELECT", "CANCEL");
			return 1;
		}

	case D_REGG + 3 : {
			if(response) {
				Pl::Info[playerid][pOrigin] = (listitem + 1);
				new skin;
				Container::At(99+Pl::Info[playerid][pSex], Container::First, SelectCharPlace[playerid], skin);
				SetPlayerSkin(playerid, skin);
				ShowMenuForPlayer(SkinMenu, playerid);
			} else {
				SPD(playerid, D_REGG + 3, DIALOG_STYLE_MSGBOX, "Sex", " ¬ыберете пол вашего персонажа.", "∆≈Ќ", "ћ”∆");
			}
			return 1;
		}

	case D_FACTORY_JOB : {
			if(response) {
				if(IsPlayerAttachedObjectSlotUsed(playerid,1)) RemovePlayerAttachedObject(playerid,1);
				if(IsPlayerAttachedObjectSlotUsed(playerid,2)) RemovePlayerAttachedObject(playerid,2);
				OnJob[playerid] = 1;
				SetPlayerSkin(playerid, 27);
				SendClientMessage(playerid, COLOR_LIGHTBLUE, "¬ы начали работу в ѕроизводственном ÷еху!");
				SendClientMessage(playerid, COLOR_LIGHTBLUE, "»дите к столу, чтобы начать работу");
				ApplyAnimation(playerid,"INT_SHOP","shop_cashier",4.1,1,0,0,0,1); //    WEAPON_csawlo
				ClearAnimations(playerid);
			}
			return 1;
		}

	case D_FACTORY_JOB+1 : {
			if(response) {
				if(IsPlayerAttachedObjectSlotUsed(playerid,1)) RemovePlayerAttachedObject(playerid,1);
				if(IsPlayerAttachedObjectSlotUsed(playerid,2)) RemovePlayerAttachedObject(playerid,2);
				OnJob[playerid] = 0;
				SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
				Rac::GivePlayerMoney(playerid, KG[playerid][1] * 50);
				format(string, sizeof(string), "¬ы заработали %d$ за изготовление %dкг продуктов", KG[playerid][1] * 50, KG[playerid][1]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				KG[playerid][0] = 0;
				KG[playerid][1] = 0;
			}
			return 1;
		}

	case D_MASK	: {
			if(response) {
				switch(listitem) {
				case 0..2 : {
						static const skinInfo[][] = {
							{280, "ѕолиции"},
							{286, "‘Ѕ–"},
							{287, "јрмии"}
						};
						SetPlayerSkin(playerid, skinInfo[listitem][0]);
						HideNameTag(playerid, true);

						format(string, sizeof string, "* ¬ы скрылись в одежде %s", skinInfo[listitem][1]);
						Send(playerid,COLOR_LIGHTBLUE, string);
					}

				case 3 : {
						static const _skinInfo[][] = {
							{7, 19, 22},
							{12, 233, 211}
						};
						SetPlayerSkin(playerid, _skinInfo[Pl::Info[playerid][pSex]][random(3)]);
						HideNameTag(playerid, true);

						Send(playerid,COLOR_LIGHTBLUE,"¬ы скрылись в одежде гражданского!");
					}

				case 4 : {
						HideNameTag(playerid, false);
						SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
						Send(playerid,COLOR_LIGHTBLUE, "¬ы вернули себе свою одежду");
					}
				}
			}
		}

	case D_MASK+1 : {
			if(response) {
				switch(listitem) {
				case 0: {
						SetPlayerSkin(playerid, 120);
						HideNameTag( playerid, true );
						Send(playerid,COLOR_LIGHTBLUE,"* ¬ы скрылись в одежде японца");
					}

				case 1: {
						SetPlayerSkin(playerid, 115);
						HideNameTag( playerid, true );
						Send(playerid,COLOR_LIGHTBLUE,"* ¬ы скрылись в одежде  оронос");
					}

				case 2: {
						SetPlayerSkin(playerid, 104);
						HideNameTag( playerid, true );
						Send(playerid,COLOR_LIGHTBLUE,"* ¬ы скрылись в одежде Ѕаллас");
					}

				case 3: {
						new rnd = random(2);
						switch(Pl::Info[playerid][pSex]) {
						case 1 : {
								switch(rnd) {
								case 0 : SetPlayerSkin(playerid,7);
								case 1 : SetPlayerSkin(playerid,19);
								case 2 : SetPlayerSkin(playerid,22);
								}
							}
						case 2 : {
								switch(rnd) {
								case 0 : SetPlayerSkin(playerid,12);
								case 1 : SetPlayerSkin(playerid,233);
								case 2 : SetPlayerSkin(playerid,211);
								}
							}
						}
						Send(playerid,COLOR_LIGHTBLUE,"* ¬ы скрылись в одежде гражданского");
					}
				case 4: {
						SetPlayerSkin(playerid, Pl::Info[playerid][pChar]);
						Send(playerid,COLOR_LIGHTBLUE,"* ¬ы вернули себе свою одежду");
					}
				}
			}

			return 1;
		}

	case D_BARN :
		{
			if(response)
			{
				new vehid = GetPlayerVehicleID(playerid);
				if(!vehid) return Send(playerid,COLOR_GREY,"* ¬ы не в машине!");
				if(AutoInfo[vehid][aDrugs] <= 0) return Send(playerid,COLOR_GREY,"* ¬ вашей машине нету наркотиков!");
				if(Gm::Info[Gm::AmbarDrugs] >= 20000) return Send(playerid,COLOR_GREY,"* јмбар переполнен! ћаксимум 20000 грамм.");
				inputtext[0] = AutoInfo[vehid][aDrugs]*50;
				Gm::Info[Gm::AmbarDrugs] += AutoInfo[vehid][aDrugs]; Rac::GivePlayerMoney(playerid, inputtext[0]);
				format(string, sizeof(string), "* ¬ы продали %i грамм притону за %i$", AutoInfo[vehid][aDrugs], inputtext[0]);
				Send(playerid,COLOR_LIGHTBLUE,string);
				AutoInfo[vehid][aDrugs] = 0;
			}
			return 1;
		}

	case D_BARN+1 :
		{
			if( response )
			{
				new vehid = GetPlayerVehicleID(playerid);
				if( !vehid ) return Send(playerid,COLOR_GREY,"* ¬ы не в машине!");
				if(AutoInfo[vehid][aDrugs] <= 0) return Send(playerid,COLOR_GREY,"* ¬ вашей машине нету наркотиков!");
				if(Gm::Info[Gm::AmbarDrugs] >= 20000) return Send(playerid,COLOR_GREY,"* јмбар переполнен! ћаксимум 20000 грамм.");
				inputtext[0] = AutoInfo[vehid][aDrugs]*70;
				Gm::Info[Gm::PritonDrugs] += AutoInfo[vehid][aDrugs]; Rac::GivePlayerMoney(playerid, inputtext[0]);
				format(string, sizeof(string), "* ¬ы продали %d грамм притону за %d$", AutoInfo[vehid][aDrugs], inputtext[0]);
				Send(playerid,COLOR_LIGHTBLUE,string);
				AutoInfo[vehid][aDrugs] = 0;
			}
			return 1;
		}

	case D_BARN+2 :
		{
			if( response )
			{
				new vehid = GetPlayerVehicleID(playerid);
				if( !vehid ) return Send(playerid,COLOR_GREY,"* ¬ы не в машине!");
				if( sscanf(inputtext, "i", inputtext[0]) )
				{
					SPD(playerid, D_BARN+2, 1, "јмбар", " ол-во мака которое хотите вз€ть.", "¬з€ть", "ќтмена");
				}
				else if(inputtext[0] > 100)
				{
					Send(playerid,COLOR_GREY,"* Ѕольше 100 грамм возить нельз€!");
					SPD(playerid, D_BARN+2, 1, "јмбар", " ол-во мака которое хотите вз€ть.", "¬з€ть", "ќтмена");
				}
				else
				{
					inputtext[1] = inputtext[0]*50;
					if(Rac::GetPlayerMoney(playerid) < inputtext[1]) Send(playerid,COLOR_GREY,"* ” ¬ас не хватает денег!");
					else if(AutoInfo[vehid][aDrugs]+inputtext[0] > AutoInfo[vehid][aMaxDrugs])
					{
						Send(playerid,COLOR_LIGHTRED2,"* «а один раз можно везти 100 грамм!");
						SPD(playerid, D_BARN+2, 1, "јмбар", " ол-во мака которое хотите вз€ть.", "¬з€ть", "ќтмена");
					}
					else
					{
						AutoInfo[vehid][aDrugs] += inputtext[0];
						Gm::Info[Gm::AmbarDrugs] -= inputtext[0];
						Rac::GivePlayerMoney(playerid, -inputtext[1]);
						format(string, sizeof(string), "* ¬ы вз€ли %d грамм за $%d", inputtext[0], inputtext[1]);
						Send(playerid,COLOR_LIGHTBLUE,string);
					}
				}
			}
			return 1;
		}

	case D_HEALME : {
			if(response) {
				new houseid = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
				if(!IsValidHouse(houseid)) return Send(playerid, COLOR_GREY, "* Invalid house id!");
				if(!IsPlayerInHouse(playerid, 9.0, houseid)) return Send(playerid, COLOR_GREY, "* ¬ы не в доме!");
				switch(listitem) {
				case 0 : {
						if(!HouseInfo[houseid][hSafe][3]) return Send(playerid, COLOR_GREY, "* ¬ доме нет аптечек!");
						if(Rac::GetPlayerHealth(playerid) >= 100.0) return Send(playerid, COLOR_GREY, "* ¬ы уже вылечены!");
						HouseInfo[houseid][hSafe][3] --;
						Rac::SetPlayerHealth(playerid, 100.0);
						GameTextForPlayer(playerid, "~w~You~n~~r~healed", 1, 5000);
						format(string, sizeof(string), "* ќталось аптечек: %i штук.", HouseInfo[houseid][hSafe][3]);
						Send(playerid, COLOR_GREEN, string);
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					}
				case 1 : {
						if(!HouseInfo[houseid][hSafe][4]) return Send(playerid, COLOR_GREY, "* ¬ доме нет брони!");
						if(Rac::GetPlayerArmour(playerid) >= 100.0) return Send(playerid, COLOR_GREY, "* ¬ы уже в бронежелете!");
						HouseInfo[houseid][hSafe][4] --;
						Rac::SetPlayerArmour(playerid, 100.0);
						GameTextForPlayer(playerid, "~w~You are dressed ~r~~n~in body armor", 1, 5000);
						format(string, sizeof(string), "* ќталось брони: %i штук.", HouseInfo[houseid][hSafe][4]);
						Send(playerid, COLOR_GREEN, string);
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
					}
				}
			}
			return 1;
		}

	case D_GIVE_PASS : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					Send(playerid, COLOR_GREY, "* ¬ы ошиблись, попробуйте еще раз!");
					SPD(playerid, D_GIVE_PASS, 1, "{ffcf00}ѕаспортный стол", "”кажите ваш возраст", "¬вод", "ќтмена");
				} else if(inputtext[0] < 10 || inputtext[0] > 90) {
					Send(playerid, COLOR_GREY, "* ¬ы ошиблись, попробуйте еще раз!");
					SPD(playerid, D_GIVE_PASS, 1, "{ffcf00}ѕаспортный стол", "”кажите ваш возраст", "¬вод", "ќтмена");
				} else {
					Pl::Info[playerid][pAge] = inputtext[0];
					format(dialog, sizeof dialog, "¬ы хотите купить паспорт?\n\
					—тоимость: $%i\n—рок действи€: 20 дней", (500*Pl::Info[playerid][pLevel]));
					SPD(playerid, D_GIVE_PASS+1, 0, "{ffcf00}ѕаспортный стол", dialog, "¬з€ть", "ќтмена");
				}
			}
			return 1;
		}

	case D_GIVE_PASS+1 : {
			if(response) {
				if(Rac::GetPlayerMoney(playerid) >= (500*Pl::Info[playerid][pLevel])) {
					new currtime = gettime();
					Pl::Info[playerid][pPasport][0] = 1;
					Pl::Info[playerid][pPasport][1] = currtime;
					Pl::Info[playerid][pPasport][2] = ((20*86400) + currtime);
					Rac::GivePlayerMoney(playerid, -(500*Pl::Info[playerid][pLevel]));
					format(string, sizeof(string), "* ¬ы получили паспорт. „тобы показать его игроку, введите /pasport.");
					Send(playerid, COLOR_LIGHTBLUE, string);
				} else {
					Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
				}
			}
			return 1;
		}

	case D_NETSTAT : {
			if(response) {
				Pl::NetStats[playerid] = INVALID_PLAYER_ID;
			}
			return 1;
		}

	case D_RADIO : {
			if(response) {
				new vehid = GetPlayerVehicleID(playerid);
				if(vehid && GetPlayerState(playerid) == 2) {
					if(!listitem) {
						AutoInfo[vehid][aRadio] = listitem;
						GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~r~FM OFF", 5000, 5);
						StopAudioStreamForPlayer(playerid);
					} else {
						AutoInfo[vehid][aRadio] = listitem;
						PlayAudioStreamForPlayer(playerid, RadioInfo[listitem][rUrl]);
						format(src, sizeof src,"~n~~n~~n~~n~~n~~n~~g~%s", RadioInfo[listitem][rName]);
						GameTextForPlayer(playerid, src, 5000, 5);
					}
				}
			}
			return 1;
		}

	case D_RADIO+1: {
			if(response) {
				if(!listitem) {
					GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~r~FM OFF", 5000, 5);
					StopAudioStreamForPlayer(playerid);
				} else {
					PlayAudioStreamForPlayer(playerid, RadioInfo[listitem][rUrl]);
					format(string, sizeof string,"~n~~n~~n~~n~~n~~n~~g~%s", RadioInfo[listitem][rName]);
					GameTextForPlayer(playerid, string, 5000, 5);
				}
			}
		}

	case D_GIFT: {
			if(response && Pl::Info[playerid][pLevel] == 1) {
				new bidx = GetIndexFromBizID(7);
				Pl::Info[playerid][pLevel] = 2;
				Pl::Info[playerid][pLic][0] = 1;
				Pl::Info[playerid][pLic][3] = 1;
				Pl::Info[playerid][pLic][1] = 1;
				Pl::Info[playerid][pLic][2] = 1;
				Pl::Info[playerid][pLic][4] = 1;
				Rac::GivePlayerMoney(playerid, 400000);
				Pl::Info[playerid][pLocal] = OFFSET_BIZZ - bidx;
				SetPlayerScore(playerid, Pl::Info[playerid][pLevel]);

				Rac::SetPlayerInterior(playerid, 3);
				Rac::SetPlayerVirtualWorld(playerid, BizzInfo[bidx][bVirtual]);
				Rac::SetPlayerPos(playerid, 207.4872,-129.2266,1003.5078);
				Send(playerid, COLOR_YELLOW, "* ¬ы прин€ли подарок. ∆елаем удачной игры на сервере!");
			}

			return 1;
		}
	case D_GGUN:
		{
			if(response && Pl::isAdmin(playerid, SUPERMODER))
			{
				new setid, weaponid, amount;
				if(!sscanf(inputtext, "uii", setid, weaponid, amount))
				{
					if(!Pl::isLogged(setid)) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
					if(IsWrongWeponID(weaponid) && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GRAD1, "* Ќе правельный ID оружи€!");
					if(amount < 1 || amount > 999 && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GRAD1, "* Ќе ниже 1 и не выше 999 патронов!");
					if( Rac::GetPlayerAmmo(setid, weaponid) >= 999 && !Pl::isAdmin(playerid, 5)) return Send(playerid, COLOR_GRAD1, "* ” этого игрока слишком много оружи€!");
					format(string, sizeof(string), "[AdmWarn] * %s применил команду /ggun к игроку %s[%s]", GetName(playerid), GetName(setid), FracInfo[Pl::FracID(setid)][fName]);
					SendToAdmin(COLOR_YELLOW, string, 1, 3); Rac::GivePlayerWeapon(setid, weaponid, amount);
				}
				else
				{
					ShowDialog(playerid, D_GGUN, DIALOG_STYLE_INPUT, "GIVEGUN", "dialog/ggun.txt", "¬вод", "ќтмена");
				}
			}
			return 1;
		}
	case D_SETSTAT:
		{
			if(response && Pl::isAdmin(playerid, ADMINISTRATOR))
			{
				new setid, statcode, amount;
				if(!sscanf(inputtext, "uii", setid, statcode, amount))
				{
					if(!IsPlayerConnected(setid)) return Send(playerid, COLOR_GREY, "* Ётот игрок не подлючен!");
					if(!Pl::isLogged(setid)) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");

					switch(statcode)
					{
					case 1:
						{
							Pl::Info[setid][pLevel] = amount;
							format(string, sizeof(string), "* ”ровень игрока был изменен на %d", amount);
							Send(playerid, COLOR_GREY, string);
						}
					case 2:
						{
							Pl::Info[setid][pExp] = amount;
							format(string, sizeof(string), "* –еспекты игрока были изменены на %d", amount);
							Send(playerid, COLOR_GREY, string);
						}
					case 3:
						{
							if((amount<1000||amount>999999) && !Pl::isAdmin(playerid, ADMINISTRATOR)) {
								Send(playerid, COLOR_GREY, "* —лишком длинный или короткий номер.");
							} else {
								format(query, sizeof query, "SELECT * FROM `"#__TableUsers__"` WHERE `Number` = '%i'", amount);
								new Cache:result = Db::query(connDb, query, true);
								if(cache_get_row_count()) {
									format(string, sizeof(string), "* Ќомер телефона %d уже есть у другого игрока.", amount);
									Send(playerid, COLOR_GREY, string);
								} else {
									Pl::Info[setid][pNumber] = amount;
									format(string, sizeof(string), "* Ќомер телефона игрока был измунен на %d", amount);
									Send(playerid, COLOR_GREY, string);
								}
								cache_delete(result);
							}
						}
					case 4:
						{
							if(!IsValidHouse(amount) && amount != INVALID_HOUSE_ID) return Send(playerid, COLOR_GREY, "* ƒома с таким ID не существует!");
							Pl::Info[setid][pHouseKey] = amount;
							format(string, sizeof(string), "* ƒом игрока был изменен на %d", amount);
							Send(playerid, COLOR_GREY, string);
						}
					case 5:
						{
							if(!IsValidBiz(amount) && amount != INVALID_BIZ_ID) return Send(playerid, COLOR_GREY, "* Ѕизнеса с таким ID не существует!");
							Pl::Info[setid][pBizKey] = amount;
							format(string, sizeof(string), "* Ѕизнес игрока был изменен на %d", amount);
							Send(playerid, COLOR_GREY, string);
						}
					case 6:
						{
							if(amount < 0 || amount > 2) return Send(playerid, COLOR_GREY, "* Ќеверное значение.");
							Pl::Info[setid][pVip] = amount;
							format(string, sizeof(string), "* ¬ип статус игрока был изминен на %d", amount);
							Send(playerid, COLOR_GREY, string);
						}
					case 7:
						{
							if(amount < 0 || amount > 11) return Send(playerid, COLOR_GREY, "* Ќеверное значение.");
							if((amount == 7 || amount == 4) && !IsAMafia(setid)) return Send(playerid, COLOR_GREY, "* ќн не мафиози!");

							Iter::Remove(JobPlayers[Pl::Info[setid][pJob]], playerid);
							Iter::Add(JobPlayers[amount], playerid);

							Pl::Info[setid][pJob] = amount;
							format(string, sizeof(string), "* –абота игрока была изменена %s", JobsInfo[Pl::Info[setid][pJob]][jName]);
							Send(playerid, COLOR_GREY, string);
						}
					default:
						{
							format(string, sizeof(string), "* Ќеверное значение.");
							return ShowDialog(playerid, D_SETSTAT, DIALOG_STYLE_INPUT, "SETSTAT", "dialog/setstat.txt", "¬вод", "ќтмена");
						}
					}
					format(string, sizeof(string), "[AdmWarn] * %s применил команду /setstat к игроку %s[%s]. Statcode: %i",
					GetName(playerid), GetName(setid), FracInfo[Pl::FracID(setid)][fName], statcode); SendToAdmin(COLOR_YELLOW, string, 1, 3);
				}
				else
				{
					if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
					Send(playerid, COLOR_GREY, "* ¬ы нечего не ввели!");
					return ShowDialog(playerid, D_SETSTAT, DIALOG_STYLE_INPUT, "SETSTAT", "dialog/setstat.txt", "¬вод", "ќтмена");
				}
			}
			return 1;
		}

	case D_EDIT: {
			if(response && Pl::isAdmin(playerid, ADMINISTRATOR)) {
				new amount, name[16];
				if(!sscanf(inputtext, "s[24]i", name, amount)) {
					if(IsPlayerInAnyVehicle(playerid) && GetPlayerState(playerid) == 2) {
						new idx = GetCarID(playerid);
						if(idx == -1) return Send(playerid, COLOR_GREY, "* Ёту машину нельз€ редактировать!");
						if(!strcmp(name, "Model", true)) {
							if(amount < 400 || amount > 611) return Send(playerid, COLOR_GREY, "* Ќеверный ID моднли!");
							VehicleInfo[idx][vModel] = amount;
							AutoInfo[0][aMileage] = AutoInfo[VehicleInfo[idx][cID]][aMileage];
							GetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							GetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Veh::Destroy(VehicleInfo[idx][cID]);
							VehicleInfo[idx][cID] = Veh::Create
							(
							VehicleInfo[idx][vModel],
							VehicleInfo[idx][vPosX],
							VehicleInfo[idx][vPosY],
							VehicleInfo[idx][vPosZ],
							VehicleInfo[idx][vPosA],
							VehicleInfo[idx][vColor1],
							VehicleInfo[idx][vColor2],
							VehicleInfo[idx][vRespTime]
							);
							AutoInfo[VehicleInfo[idx][cID]][aMileage] = AutoInfo[0][aMileage];
							SetVehicleNumber(VehicleInfo[idx][cID]);
							UpdateToSQL(idx, 0);
							SetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							SetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);

						} else if(strcmp(name, "Color1", true) == 0) {
							if(amount < -1 || amount > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126!");
							VehicleInfo[idx][vColor1] = amount;
							AutoInfo[0][aMileage] = AutoInfo[VehicleInfo[idx][cID]][aMileage];
							GetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							GetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Veh::Destroy(VehicleInfo[idx][cID]);
							VehicleInfo[idx][cID] = Veh::Create
							(
							VehicleInfo[idx][vModel],
							VehicleInfo[idx][vPosX],
							VehicleInfo[idx][vPosY],
							VehicleInfo[idx][vPosZ],
							VehicleInfo[idx][vPosA],
							VehicleInfo[idx][vColor1],
							VehicleInfo[idx][vColor2],
							VehicleInfo[idx][vRespTime]
							);
							AutoInfo[VehicleInfo[idx][cID]][aMileage] = AutoInfo[0][aMileage];
							SetVehicleNumber(VehicleInfo[idx][cID]);
							UpdateToSQL(idx, 0);
							SetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							SetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);

						} else if(!strcmp(name, "Color2", true)) {
							if(amount < -1 || amount > 126) return Send(playerid, COLOR_GREY, "* ID цвета не может быть ниже 0 или выше 126!");
							VehicleInfo[idx][vColor2] = amount;
							AutoInfo[0][aMileage] = AutoInfo[VehicleInfo[idx][cID]][aMileage];
							GetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							GetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Veh::Destroy(VehicleInfo[idx][cID]);
							VehicleInfo[idx][cID] = Veh::Create
							(
							VehicleInfo[idx][vModel],
							VehicleInfo[idx][vPosX],
							VehicleInfo[idx][vPosY],
							VehicleInfo[idx][vPosZ],
							VehicleInfo[idx][vPosA],
							VehicleInfo[idx][vColor1],
							VehicleInfo[idx][vColor2],
							VehicleInfo[idx][vRespTime]
							);
							AutoInfo[VehicleInfo[idx][cID]][aMileage] = AutoInfo[0][aMileage];
							SetVehicleNumber(VehicleInfo[idx][cID]);
							UpdateToSQL(idx, 0);
							SetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							SetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);

						} else if(!strcmp(name, "Resptime", true)) {
							if(amount < 300 || amount > 2000) return Send(playerid, COLOR_GREY, "* ¬рем€ спавна может быть от 300 до 2000 сек.");
							VehicleInfo[idx][vRespTime] = amount;
							AutoInfo[0][aMileage] = AutoInfo[VehicleInfo[idx][cID]][aMileage];
							GetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							GetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Veh::Destroy(VehicleInfo[idx][cID]);
							VehicleInfo[idx][cID] = Veh::Create(
							VehicleInfo[idx][vModel],
							VehicleInfo[idx][vPosX],
							VehicleInfo[idx][vPosY],
							VehicleInfo[idx][vPosZ],
							VehicleInfo[idx][vPosA],
							VehicleInfo[idx][vColor1],
							VehicleInfo[idx][vColor2],
							VehicleInfo[idx][vRespTime]
							);
							AutoInfo[VehicleInfo[idx][cID]][aMileage] = AutoInfo[0][aMileage];
							SetVehicleNumber(VehicleInfo[idx][cID]);
							UpdateToSQL(idx, 0);
							SetVehiclePos(VehicleInfo[idx][cID], posx, posy, posz);
							SetVehicleZAngle(VehicleInfo[idx][cID], angle);
							Rac::PutPlayerInVehicle(playerid, VehicleInfo[idx][cID], 0);
						} else if(!strcmp(name, "Job", true)) {
							Iter::Remove(JobVehicles[VehicleInfo[idx][vJob]], VehicleInfo[idx][cID]);
							Iter::Add(JobVehicles[VehicleInfo[idx][vJob]], VehicleInfo[idx][cID]);
							VehicleInfo[idx][vJob] = amount;
							UpdateToSQL(idx, 0);
						}

						format(string, sizeof(string), "[AdmWarn] * %s применил команду /edit. Params: car %s %i", GetName(playerid), name, amount);
						SendToAdmin(COLOR_YELLOW, string, 4, 3);
					} else {
						foreach(new i : Biznes) {
							if(IsPlayerInRangeOfPoint(playerid, 3.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2])) {
								format(string, sizeof(string), "Biz: %d", i);
								Send(playerid, COLOR_GRAD2, string);
								if(amount >= 0) {
									if(!strcmp(name,"level",true) ) 			BizzInfo[i][bLevel] = amount;
									else if(!strcmp(name,"price",true))			BizzInfo[i][bPrice] = amount;
									else if(!strcmp(name,"funds",true))			BizzInfo[i][bSafe] = amount;
									else if(!strcmp(name,"prods",true))			BizzInfo[i][bProds] = amount;
									else if(!strcmp(name,"maxprods",true))		BizzInfo[i][bMaxProds] = amount;
									else if(!strcmp(name,"enterprice",true)) 	BizzInfo[i][bEnterCost] = amount;
									else if(!strcmp(name,"priceprods",true)) 	BizzInfo[i][bPriceProd] = amount;
									format(string, sizeof(string), "[AdmWarn] * %s применил команду /edit. Params: %s %i", GetName(playerid), name, amount);
									SendToAdmin(COLOR_YELLOW, string, 3, 3);

									return 1;
								}
							}
						}
						foreach(new i : Houses) {
							if (IsPlayerInRangeOfPoint(playerid,3,HouseInfo[i][hEnter][0], HouseInfo[i][hEnter][1], HouseInfo[i][hEnter][2])) {
								format(string, sizeof(string), "House: %d", i);
								Send(playerid, COLOR_GRAD2, string);
								if(amount >= 0) {
									if(!strcmp(name,"level",true)) 		HouseInfo[i][hLevel] = amount;
									else if(!strcmp(name,"price",true))	HouseInfo[i][hPrice] = amount;
									else if(!strcmp(name,"safe",true))	HouseInfo[i][hSafe][0] = amount;
									format(string, sizeof(string), "[AdmWarn] * %s применил команду /edit. Params: %s %i", GetName(playerid), name, amount);
									SendToAdmin(COLOR_YELLOW, string, 3, 3);

									return 1;
								}
							}
						}
					}
				}
				else
				{
					if(!Pl::isAdmin(playerid, ADMINISTRATOR)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
					Send(playerid, COLOR_GREY, "* ¬ы нечего не ввели!");
					ShowDialog(playerid, D_EDIT, DIALOG_STYLE_INPUT, "EDIT", "dialog/edit.txt", "OK", "ќ“ћ≈Ќј");
				}
			}
			return 1;
		}

	case D_ONLINE: {
			if(response) return ShowOnline(playerid,listitem);
			return 1;
		}

	case D_ONLINE+1: {
			if(response) {
				ShowDialog(playerid, D_ONLINE,DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC" ќнлайн", "dialog/online.txt", "SELECT", "CANCEL");
			}
			return 1;
		}

	case D_OFFLINE : {
			if(response) return ShowOffline(playerid, listitem);
			return 1;
		}

	case D_OFFLINE+1: {
			if(response) {
				ShowDialog(playerid, D_OFFLINE, DIALOG_STYLE_LIST,""#__SERVER_PREFIX""#__SERVER_NAME_LC": OFFLINE", "dialog/offline.txt", "SELECT", "CANCEL");
			}
			return 1;
		}

	case D_JOB : {
			if(response) {
				switch(GettingJob[playerid]) {
				case 2 : {
						if(Pl::FracID(playerid) != 7) return Send(playerid, COLOR_GREY, "* ¬ы не работаете в ѕравительстве!");
						if(6 <= Pl::Info[playerid][pRank] <= 8) {
							Pl::Info[playerid][pJob] = GettingJob[playerid];
							Pl::Info[playerid][pContractTime] = 5;
							GettingJob[playerid] = 0;
							Send(playerid, COLOR_LIGHTBLUE, "* “еперь, когда ¬ы подтвердили, что ¬ы хотите –аботу, ¬ы получили 5-часовой  онтракт.");
							Send(playerid, COLOR_LIGHTBLUE, "* ѕоздравлени€ с ¬ашей новой –аботой, напечатайте /help, чтобы видеть ¬ашу новую команду.");
						} else {
							Send(playerid, COLOR_GREY, "* ¬ы не юрист!");
						}
					}
				case 4, 7 : {
						if(!IsAMafia(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не мафиози!");
						Pl::Info[playerid][pJob] = GettingJob[playerid];
						Pl::Info[playerid][pContractTime] = 5;
						Iter::Add(JobPlayers[GettingJob[playerid]], playerid);

						GettingJob[playerid] = 0;
						ShowDialog(playerid, D_NONE, 0, "“рудоустройство", "dialog/job_success.txt", "OK", "");
					}
					default : {
						Pl::Info[playerid][pJob] = GettingJob[playerid];
						Pl::Info[playerid][pContractTime] = 5;
						Iter::Add(JobPlayers[GettingJob[playerid]], playerid);

						GettingJob[playerid] = 0;
						Send(playerid, COLOR_LIGHTBLUE, "* “еперь, когда ¬ы подтвердили, что ¬ы хотите –аботу, ¬ы получили 5-часовой  онтракт.");
						Send(playerid, COLOR_LIGHTBLUE, "* ѕоздравлени€ с ¬ашей новой –аботой, напечатайте /help, чтобы видеть ¬ашу новую команду.");
					}
				}
			}
			return 1;
		}

	case D_BANLIST : {
			if(response) {
				new playername[24];
				GetPVarString(playerid, "UnbanPlayer", playername, 24);
				DeletePVar(playerid, "UnbanPlayer");
				if(!Pl::isAdmin(playerid, SUPERMODER)) return Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
				if(RemoveBanList(GetIDFromName(playername))) {
					format(string, sizeof(string), "[UNBAN] * %s[%i] разбанил игрока %s", GetName(playerid), playerid, playername);
					SendToAdmin(COLOR_LIGHTBLUE, string, 1, 3);
				}
			}
			return 1;
		}
	case D_HMENU: {
			new hid = Pl::Info[playerid][pHouseKey];
			if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
			if(response) {
				switch(listitem) {
				case 0: PrintHouseInfo(playerid, hid);

				case 1 : {
						if(!IsPlayerInHouse(playerid, 20.0, hid)) return Send(playerid, COLOR_GREY, "¬ы сейчас не в своем доме!");
						return SafeMenu(playerid, hid);
					}

				case 2 : SPD(playerid, D_HMENU+4, DIALOG_STYLE_LIST, "[House Menu] > јренда", "¬кл./ќткл. аренду\n÷ена аренды", "ENTER", "CANCLE");

				case 3 : ShowDialog(playerid, D_HMENU+10, DIALOG_STYLE_LIST, "[House Menu] > јвто", "dialog/hmenu_auto.txt", "SELECT", "CANCEL");

				case 4 : {
						if(!IsPlayerInHouse(playerid, 15.0, hid)) return SPD(playerid, D_NONE, 0, "[House Menu] > »нтерьер", "¬ы должны находитс€ в своем доме, чтобы изменить интерьер!", "OK", "");
						SetPVarInt(playerid, "SelectedItem", 0);
						Rac::SetPlayerPos(playerid, HouseInt[0][intX], HouseInt[0][intY], HouseInt[0][intZ]);
						Rac::SetPlayerInterior(playerid, HouseInt[0][intH]);
						Rac::SetPlayerVirtualWorld(playerid, 999);
						SetCameraBehindPlayer(playerid); ShowMenuForPlayer(IntMenu, playerid);
					}

				case 5 : {
						SPD(playerid, D_HMENU+3, DIALOG_STYLE_LIST, "[House Menu] > ”лучшени€",
						""#_GREY_ARROW"ѕокупка гаража {33AA33}[$100000]\n"#_GREY_ARROW"ѕокупка телевизора {33AA33}[$20000]", "SELECT", "CANCEL");
					}
				case 6:
				    {
						new house = Pl::Info[playerid][pHouseKey];
						if(!IsPlayerHouseOwner(playerid, house)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
						new bidx = GetIndexFromBizID(Bizz_HouseService);
						if(BizzInfo[bidx][bProds] == 0) return GameTextForPlayer(playerid, "~r~Out Of Stock", 5000, 1);
						if(Rac::GetPlayerMoney(playerid) < BizzInfo[bidx][bEnterCost]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет столько денег!");
						if(GetVehiclePassengers(HouseInfo[house][hAuto])) return GameTextForPlayer(playerid, "~w~Car is~n~in ~r~use", 5000, 1);
						SetVehicleToRespawn(HouseInfo[house][hAuto]);
						Rac::GivePlayerMoney(playerid,-BizzInfo[bidx][bEnterCost]);
						GiveBizzProfit(bidx, BizzInfo[bidx][bEnterCost]);
						BizzInfo[bidx][bProds]--;
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						format(string, sizeof string, "~w~Car~n~~g~Towed Home~n~~r~-$%d", BizzInfo[bidx][bEnterCost]);
						GameTextForPlayer(playerid, string, 5000, 1);
				    }
				}
			}
			return 1;
		}
	case D_HMENU+1: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem) {
				case 0: {
						if(Rac::GetPlayerHealth(playerid) >= 100.0) return Send(playerid, COLOR_GREY, "* ¬ы уже в вылечены!");
						if(!HouseInfo[hid][hSafe][3]) return Send(playerid, COLOR_GREY, "* ¬ доме нет аптечек!");
						HouseInfo[hid][hSafe][3] --;
						Rac::SetPlayerHealth(playerid, 100.0);
						GameTextForPlayer(playerid, "~w~You~n~~r~healed", 5000, 1);
					}
				case 1: {
						new bidx = GetIndexFromBizID(Bizz_HouseService);
						if(!BizzInfo[bidx][bProds]) return GameTextForPlayer(playerid, "~r~Out of stock", 5000, 1);
						if(HouseInfo[hid][hSafe][3] >= 100) return Send(playerid, COLOR_GREY, "* ¬ доме максимальное кол-во аптечек!");
						if(HouseInfo[hid][hSafe][0] < 1000) return Send(playerid, COLOR_GREY, "* Ќа счету дома недостаточно средств!");
						HouseInfo[hid][hSafe][3] ++;
						HouseInfo[hid][hSafe][0] -= 1000;
						GiveBizzProfit(bidx, 1000);
						BizzInfo[bidx][bProds]--;
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						SPD(playerid, D_HMENU+1, DIALOG_STYLE_LIST, "[House Menu] > —ейф > јптечки", ""#_GREY_ARROW"»спользовать\n"#_GREY_ARROW" упить {33AA33}[$1000]", "SELECT", "CANCEL");
					}
				}
			} else {
				SafeMenu(playerid, Pl::Info[playerid][pHouseKey]);
			}
		}

	case D_HMENU+2: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				switch(listitem) {
				case 0: {
						if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
						if(Rac::GetPlayerArmour(playerid) >= 100.0) return Send(playerid, COLOR_GREY, "* ¬ы уже в бронежилете!");
						if(!HouseInfo[hid][hSafe][4]) return Send(playerid, COLOR_GREY, "* ¬ доме нет бронежилета!");
						HouseInfo[hid][hSafe][4] --;
						Rac::SetPlayerArmour(playerid, 100.0);
						GameTextForPlayer(playerid, "~w~You are dressed ~r~~n~in body armor", 1, 5000);
					}

				case 1: {
						new bidx = GetIndexFromBizID(Bizz_HouseService);
						if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
						if(!BizzInfo[bidx][bProds]) return GameTextForPlayer(playerid, "~r~Out of stock", 1, 5000);
						if(HouseInfo[hid][hSafe][4] >= 50) return Send(playerid, COLOR_GREY, "* ¬ доме максимальное кол-во брони!");
						if(HouseInfo[hid][hSafe][0] < 3000) return Send(playerid, COLOR_GREY, "* Ќа счету дома недостаточно средств!");
						HouseInfo[hid][hSafe][4] ++;
						HouseInfo[hid][hSafe][0] -= 3000;
						GiveBizzProfit(bidx, 3000);
						BizzInfo[bidx][bProds]--;
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						SPD(playerid, D_HMENU+2, DIALOG_STYLE_LIST, "[House Menu] > —ейф > Ѕронежелеты", ""#_GREY_ARROW"»спользовать\n"#_GREY_ARROW" упить {33AA33}[$1000]", "SELECT", "CANCEL");
					}
				}
			} else {
				SafeMenu(playerid, Pl::Info[playerid][pHouseKey]);
			}
		}
	case D_HMENU+3: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem) {
				case 0 : {
						if(HouseInfo[hid][hgGarage]) return Send(playerid, COLOR_GREY, "* ” ¬ас есть гараж!");
						if(HouseInfo[hid][hSafe][0] < 100000) return Send(playerid, COLOR_GREY, "* Ќа счету дома недостаточно средств!");
						HouseInfo[hid][hSafe][0] -= 100000;
						GameTextForPlayer(playerid, "~r~-$100000", 1000, 1);
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						format(query, sizeof query, "INSERT INTO `"#__TableHouseGarages__"` (`house`) VALUES ('%i')", HouseInfo[hid][hID]);
						Db::tquery(connDb, query, "", "");
						HouseInfo[hid][hgGarage] = true;
						Streamer_AppendArrayData(STREAMER_TYPE_PICKUP, HGaragePickup[0], E_STREAMER_WORLD_ID, HouseInfo[hid][hVirtual]);
						Streamer_AppendArrayData(STREAMER_TYPE_PICKUP, HGaragePickup[1], E_STREAMER_WORLD_ID, HouseInfo[hid][hVirtual]);
						Send(playerid, COLOR_GREY, "* ¬ ваш дом добавлен гараж! ”становите точку входа в доме (/editgarint) и точку выезда у дома (/editgarstreet)!");
					}
				case 1 : {
						new bidx = GetIndexFromBizID(Bizz_HouseService);
						if(HouseInfo[hid][hSafe][0] < 20000) return Send(playerid, COLOR_GREY, "* Ќа счету дома недостаточно средств!");
						HouseInfo[hid][hTv] = 1;
						HouseInfo[hid][hSafe][0] -= 20000;
						GiveBizzProfit(bidx, 20000);
						BizzInfo[bidx][bProds]--;
						PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
						Send(playerid, COLOR_GRAD5, "¬ы можете теперь смотреть телек, пишите /tv.");
					}
				}
			} else {
				ShowDialog(playerid, D_HMENU, DIALOG_STYLE_LIST, "[House Menu]", "dialog/hmenu.txt", "SELECT", "CANCEL");
			}
		}
	case D_HMENU+4:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem)
				{
				case 0:
					{
						switch(HouseInfo[hid][hRent][0])
						{
						case 0:
							{
								HouseInfo[hid][hRent][0] = 1;
								return SPD(playerid, D_NONE, 0,
								"[House Menu] > јренда",
								"јренда была включена!", "ќ ", "");
							}
						case 1:
							{
								HouseInfo[hid][hRent][0] = 0;
								return SPD(playerid, D_NONE, 0,
								"[House Menu] > јренда",
								"јренда была отключена!", "ќ ", "");
							}
						}
					}
				case 1:
					{
						return SPD(playerid, D_HMENU+5, DIALOG_STYLE_INPUT,
						"[House Menu] > јренда",
						"¬ведите сумму аренды.\n\
						ћаксемальна€ сумма: $99999","ENTER", "CANCEL");
					}
				}
			} else {
				ShowDialog(playerid, D_HMENU, DIALOG_STYLE_LIST, "[House Menu]", "dialog/hmenu.txt", "SELECT", "CANCEL");
			}
		}
	case D_HMENU+5:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				if(sscanf(inputtext, "d", inputtext[0]))
				{
					return SPD(playerid, D_HMENU+5, DIALOG_STYLE_INPUT,
					"[House Menu] > јренда",
					"¬ведите сумму аренды.\n\
					ћаксемальна€ сумма: $99999","ENTER", "CANCEL");
				}
				if(inputtext[0] < 1 || inputtext[0] > 99999)
				{
					Send(playerid, COLOR_GREY, "* —тоимость аренды может быть от $1 до $9999");
					return SPD(playerid, D_HMENU+5, DIALOG_STYLE_INPUT,
					"[House Menu] > јренда",
					"¬ведите сумму аренды.\n\
					ћаксемальна€ сумма: $99999", "ENTER", "CANCEL");
				}
				HouseInfo[hid][hRent][1] = inputtext[0];
				format(string, sizeof(string), "÷ена аренды была установлена!\n“епрь аренда стоит:\t$%d", inputtext[0]);
				SPD(playerid, D_NONE, 0, "[House Menu] > јренда", string, "OK", "");
			}
			else
			{
				return SPD(playerid, D_HMENU+4, DIALOG_STYLE_LIST,
				"[House Menu] > јренда",
				"¬кл./ќткл. аренду\n\
				÷ена аренды", "SELECT", "CANCEL");
			}
		}
	case D_HMENU+6:
		{
			new hid = Pl::Info[playerid][pHouseKey];
			if(response) {
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem)
				{
				case 0:
					{
						return SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф", "—колько хотите положить?", "ENTER", "CANCEL");
					}
				case 1:
					{
						return  SPD(playerid, D_HMENU+8, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф", "—колько хотите вз€ть?", "ENTER", "CANCEL");
					}
				}
			}
			else
			{
				SafeMenu(playerid, hid);
			}
			return 1;
		}
	case D_HMENU+7:
		{

			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "d", inputtext[0])) {
					SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф", "—колько хотите положить?", "ENTER", "CANCEL");
				}
				else if((HouseInfo[hid][hSafe][0] + inputtext[0]) > 10000000)
				{
					Send(playerid, COLOR_GREY, "* ¬ сейф столько не влезит!");
					SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф", "—колько хотите положить?", "ENTER", "CANCEL");
				}
				else if(inputtext[0] < 1 || inputtext[0] > Rac::GetPlayerMoney(playerid)) {
					Send(playerid, COLOR_GREY, "* ” ¬ас нет столько денег!");
					SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф", "—колько хотите положить?", "ENTER", "CANCEL");
				} else {
					HouseInfo[hid][hSafe][0] += inputtext[0];
					Rac::GivePlayerMoney(playerid, -inputtext[0]);
					format(string, sizeof(string), "¬ы положили в сейф: {33AA33}$%d", inputtext[0]);
					SPD(playerid, D_NONE, 0, "[House Menu] > —ейф", string, "OK", "");
				}
			} else {
				SPD(playerid, D_HMENU+6, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф", "ѕоложить\n¬з€ть", "SELECT", "CANCEL");
			}
			return 1;
		}
	case D_HMENU+8: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "d", inputtext[0])) {
					SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф","—колько хотите вз€ть?", "ENTER", "CANCEL");
				} else if(inputtext[0] < 1 || inputtext[0] > HouseInfo[hid][hSafe][0]) {
					Send(playerid, COLOR_GREY, "* ¬ сейфе не столько денег!");
					SPD(playerid, D_HMENU+7, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф","—колько хотите вз€ть?", "ENTER", "CANCEL");
				} else {
					HouseInfo[hid][hSafe][0] -= inputtext[0];
					Rac::GivePlayerMoney(playerid, inputtext[0]);
					format(string, sizeof(string), "¬ы вз€ли из сейфа: {33AA33}$%d", inputtext[0]);
					SPD(playerid, D_NONE, 0, "[House Menu] > —ейф", string, "OK", "");
				}
			} else {
				SPD(playerid, D_HMENU+6, DIALOG_STYLE_LIST, "[House Menu] > —ейф", "ѕоложить\n¬з€ть", "SELECT", "CANCEL");
			}
		}

	case D_HMENU+10: {
			if(response) {
				switch(listitem) {
				case 0..3 : {
						dialog[0] = '\0';
						for(new i; i < ASModelCount[listitem]; i++) {
							scf(dialog, string, ""#_GREY_ARROW"%s {33AA33}[$%i]\n", VehicleNames[AutoSolon[listitem][i][0] - 400], AutoSolon[listitem][i][1]);
						}
						SetPVarInt(playerid, "SelectedCar", listitem);
						SPD(playerid, D_HMENU+13, DIALOG_STYLE_LIST, "[House Menu] > ћашина", dialog, "SELECT", "CANCEL");
					}
				case 4 : {
						new hid = Pl::Info[playerid][pHouseKey];
						if(!(400 <= HouseInfo[hid][hvModel] <= 611)) {
							SPD(playerid, D_NONE, 0, "[House Menu] > јвто", "” ¬ас нет домашнего авто!", "OK", "");
						} else {
							ShowDialog(playerid, D_HMENU+24, DIALOG_STYLE_INPUT, "[House Menu] > јвто > ѕокраска", "dialog/colors.txt", "SELECT", "CANCEL");
						}
					}
				}
			} else {
				ShowDialog(playerid, D_HMENU, DIALOG_STYLE_LIST, "[House Menu]", "dialog/hmenu.txt", "SELECT", "CANCEL");
			}

		}

	case D_HMENU+11: {
			new idx = GetPVarInt(playerid, "SelectedItem");
			if(idx == -1) return Send(playerid, -1, "Error");
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				new bidx = GetIndexFromBizID(Bizz_HouseService);
				if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				if(!BizzInfo[bidx][bProds]) return GameTextForPlayer(playerid, "~r~Out of Stock", 1, 5000);
				if(HouseInfo[hid][hSafe][0] < HouseInt[idx][intPrice]) return Send(playerid, COLOR_GREY, "* Ќа счету дома недастаточно средств!");
				SetPVarInt(playerid, "SelectedItem", -1);
				HouseInfo[hid][hInt] = HouseInt[idx][intH];
				HouseInfo[hid][hExit][0] = HouseInt[idx][intX];
				HouseInfo[hid][hExit][1] = HouseInt[idx][intY];
				HouseInfo[hid][hExit][2] = HouseInt[idx][intZ];
				HouseInfo[hid][hSafe][0] -= HouseInt[idx][intPrice];
				GiveBizzProfit(bidx, HouseInt[idx][intPrice]);
				BizzInfo[bidx][bProds]--;
				Rac::SpawnPlayer(playerid);
				Send(playerid, COLOR_LIGHTBLUE, "* »нтерьер был успешно изменен!");
			} else {
				SetPVarInt(playerid, "SelectedItem", idx);
				Rac::SetPlayerPos(playerid, HouseInt[idx][intX], HouseInt[idx][intY], HouseInt[idx][intZ]);
				Rac::SetPlayerInterior(playerid, HouseInt[idx][intH]);
				Rac::SetPlayerVirtualWorld(playerid, 999);
				SetCameraBehindPlayer(playerid);
				ShowMenuForPlayer(IntMenu, playerid);
			}
		}

	case D_HMENU+13: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				new bidx = GetIndexFromBizID(Bizz_HouseService);
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ¬ы бомж, сначала купите дом.");
				if(!IsPlayerInSquare2D(playerid, 50.0, HouseInfo[hid][hEnter][0], HouseInfo[hid][hEnter][1])) return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от дома!");
				if(!BizzInfo[bidx][bProds]) return GameTextForPlayer(playerid, "~r~Out of Stock", 1, 5000);

				new vclass = GetPVarInt(playerid, "SelectedCar");
				if(HouseInfo[hid][hSafe][0] < AutoSolon[vclass][listitem][1]) return Send(playerid, COLOR_GREY, "* ¬ сейфе дома нет столько денег!");
				CarUpgrade(playerid, hid, AutoSolon[vclass][listitem][0]);
				HouseInfo[hid][hSafe][0] -= AutoSolon[vclass][listitem][1];
				GiveBizzProfit(bidx, PERCENT(AutoSolon[vclass][listitem][1], 20));
				BizzInfo[bidx][bProds] --;
				format(string, sizeof(string), "* Ќова€ ћодернизаци€: ¬аш автомобиль теперь %s", VehicleNames[AutoSolon[vclass][listitem][0] - 400]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				SetPVarInt(playerid, "SelectedCar", -1);
				PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
			} else {
				ShowDialog(playerid, D_HMENU+10, DIALOG_STYLE_LIST, "[House Menu] > јвто", "dialog/hmenu_auto.txt", "SELECT", "CANCEL");
			}
		}

	case D_HMENU+24 : {
			if(response) {
				if(sscanf(inputtext, "p<,>ii", inputtext[0], inputtext[1])) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_HMENU+24, DIALOG_STYLE_INPUT, "[House Menu] > јвто > ѕокраска", "dialog/colors.txt", "SELECT", "CANCEL");
				} else if(inputtext[0] < 0 || inputtext[0] > 127) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_HMENU+24, DIALOG_STYLE_INPUT, "[House Menu] > јвто > ѕокраска", "dialog/colors.txt", "SELECT", "CANCEL");
				} else if(inputtext[1] < 0 || inputtext[1] > 127) {
					Send(playerid, COLOR_GREY, "* Ќе валидна€ строка, повторите ввод!");
					return ShowDialog(playerid, D_HMENU+24, DIALOG_STYLE_INPUT, "[House Menu] > јвто > ѕокраска", "dialog/colors.txt", "SELECT", "CANCEL");
				}
				new hid = Pl::Info[playerid][pHouseKey];
				new bidx = GetIndexFromBizID(Bizz_HouseService);
				if(!IsPlayerInSquare2D(playerid, 50.0, HouseInfo[hid][hEnter][0], HouseInfo[hid][hEnter][1])) return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от дома!");
				if(!BizzInfo[bidx][bProds]) return GameTextForPlayer(playerid, "~r~Out of Stock", 1, 5000);
				if(HouseInfo[hid][hSafe][0] < 10000) return Send(playerid, COLOR_GREY, "* ¬ сейфе дома нет столько денег!");
				ChangeVehicleColor(HouseInfo[hid][hAuto], inputtext[0], inputtext[1]);
				HouseInfo[hid][hvColor][0] = inputtext[0];
				HouseInfo[hid][hvColor][1] = inputtext[1];
				format(string, sizeof(string), "* Ќова€ ћодернизаци€: ¬аш автомобиль был перекрашен в цвета %i/%i", inputtext[0], inputtext[1]);
				Send(playerid, COLOR_LIGHTBLUE, string);
				GameTextForPlayer(playerid, "~r~-$10000", 5000, 1);
			} else {
				ShowDialog(playerid, D_HMENU+10, DIALOG_STYLE_LIST, "[House Menu] > јвто", "dialog/hmenu_auto.txt", "SELECT", "CANCEL");
			}
		}

	case D_HMENU+14 : {
			if(response) {
				switch(listitem) {
				case 0: SPD(playerid, D_HMENU+6, DIALOG_STYLE_LIST, "[House Menu] > —ейф > ƒенги", ""#_GREY_ARROW"ѕоложить\n"#_GREY_ARROW"¬з€ть", "SELECT", "CANCEL");
				case 1: SPD(playerid, D_HMENU+15, DIALOG_STYLE_LIST, "[House Menu] > —ейф > Ќаркотики", ""#_GREY_ARROW"ѕоложить\n"#_GREY_ARROW"¬з€ть", "SELECT", "CANCEL");
				case 2: SPD(playerid, D_HMENU+18, DIALOG_STYLE_LIST, "[House Menu] > —ейф > ћатиреалы", ""#_GREY_ARROW"ѕоложить\n"#_GREY_ARROW"¬з€ть", "SELECT", "CANCEL");
				case 3: SafeMenu(playerid, Pl::Info[playerid][pHouseKey], 1);
				case 4: SPD(playerid, D_HMENU+1, DIALOG_STYLE_LIST, "[House Menu] > —ейф > јптечки", ""#_GREY_ARROW"»спользовать\n"#_GREY_ARROW" упить {33AA33}[$1000]", "SELECT", "CANCEL");
				case 5: {
						if(IsACop(playerid) && Pl::Info[playerid][pRank] >= 3) {
							SPD(playerid, D_HMENU+2, DIALOG_STYLE_LIST, "[House Menu] > —ейф > Ѕронежилеты", ""#_GREY_ARROW"»спользовать\n"#_GREY_ARROW" упить {33AA33}[$3000]", "SELECT", "CANCEL");
						} else {
							Send(playerid, COLOR_GREY, "* “олько законики могут использовать бронижелет!");
							SafeMenu(playerid, Pl::Info[playerid][pHouseKey]);
						}
					}
				}
			} else {
				ShowDialog(playerid, D_HMENU, DIALOG_STYLE_LIST, "[House Menu]", "dialog/hmenu.txt", "SELECT", "CANCEL");
			}
		}
	case D_HMENU+15:
		{
			new hid = Pl::Info[playerid][pHouseKey];
			if(response)
			{
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem)
				{
				case 0:
					{
						return SPD(playerid, D_HMENU+16, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф > Ќаркотики",
						"—колько хотите положить?", "ENTER", "CANCEL");
					}
				case 1:
					{
						return SPD(playerid, D_HMENU+17, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф > Ќаркотики",
						"—колько хотите вз€ть?", "ENTER", "CANCEL");
					}
				}
			}
			else
			{
				SafeMenu(playerid, hid);
			}
		}
	case D_HMENU+16:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "i", inputtext[0]))
				{
					return SPD(playerid, D_HMENU+16, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > Ќаркотики > ѕоложить",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				if((HouseInfo[hid][hSafe][1] + inputtext[0]) > 1000)
				{
					Send(playerid, COLOR_GREY, "* ¬ сейф столько не влезит!");
					return SPD(playerid, D_HMENU+16, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > Ќаркотики > ѕоложить",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				if(inputtext[0] < 1 || inputtext[0] > Pl::Info[playerid][pDrugs])
				{
					Send(playerid, COLOR_GREY, "* ” ¬ас нет столько наркоты!");
					return SPD(playerid, D_HMENU+16, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > Ќаркотики > ѕоложить",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				HouseInfo[hid][hSafe][1] += inputtext[0];
				Pl::Info[playerid][pDrugs] -= inputtext[0];
				format(string, sizeof(string), "¬ы положили в сейф: %i грамм", inputtext[0]);
				return SPD(playerid, D_NONE, 0, "[House Menu] > —ейф > Ќаркотики > ѕоложить", string, "OK", "");
			}
			else
			{
				SPD(playerid, D_HMENU+15, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф > Ќаркотики", "ѕоложить\n¬з€ть", "ENTER", "CANCLE");
				return 1;
			}
		}
	case D_HMENU+17:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "i", inputtext[0]))
				{
					return SPD(playerid, D_HMENU+17, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > Ќаркотики > ¬з€ть",
					"—колько хотите вз€ть?", "ENTER", "CANCEL");
				}
				if(inputtext[0] < 1 || inputtext[0] > HouseInfo[hid][hSafe][1])
				{
					Send(playerid, COLOR_GREY, "* ¬ сейфе нет столько!");
					return SPD(playerid, D_HMENU+17, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > Ќаркотики > ¬з€ть",
					"—колько хотите вз€ть?", "ENTER", "CANCEL");
				}
				HouseInfo[hid][hSafe][1] -= inputtext[0]; Pl::Info[playerid][pDrugs] += inputtext[0];
				format(string, sizeof(string), "¬ы вз€ли из сейфа: %i грамм", inputtext[0]);
				return SPD(playerid, D_NONE, 0, "[House Menu] > —ейф > Ќаркотики > ¬з€ть", string, "OK", "");
			}
			else
			{
				return SPD(playerid, D_HMENU+15, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф > Ќаркотики", "ѕоложить\n¬з€ть", "ENTER", "CANCLE");
			}
		}
	case D_HMENU+18:
		{
			new hid = Pl::Info[playerid][pHouseKey];
			if(response)
			{
				if(!IsPlayerHouseOwner(playerid, hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				switch(listitem)
				{
				case 0:
					{
						return SPD(playerid, D_HMENU+19, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф > ћатериалы",
						"—колько хотите положить?", "ENTER", "CANCEL");
					}
				case 1:
					{
						return SPD(playerid, D_HMENU+20, DIALOG_STYLE_INPUT,
						"[House Menu] > —ейф > ћатериалы",
						"—колько хотите вз€ть?", "ENTER", "CANCEL");
					}
				}
			}
			else
			{
				SafeMenu(playerid, hid);
			}
		}
	case D_HMENU+19:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "i", inputtext[0]))
				{
					return SPD(playerid, D_HMENU+19, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > ћатериалы",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				if((HouseInfo[hid][hSafe][2] + inputtext[0]) > 100000)
				{
					Send(playerid, COLOR_GREY, "* ¬ сейф столько не влезит!");
					return SPD(playerid, D_HMENU+19, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > ћатериалы",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				if(inputtext[0] < 1 || inputtext[0] > Pl::Info[playerid][pMats])
				{
					Send(playerid, COLOR_GREY, "* ” ¬ас нет столько материалов!");
					return SPD(playerid, D_HMENU+19, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > ћатериалы",
					"—колько хотите положить?", "ENTER", "CANCEL");
				}
				HouseInfo[hid][hSafe][2] += inputtext[0]; Pl::Info[playerid][pMats] -= inputtext[0];
				format(string, sizeof(string), "¬ы положили в сейф: %i материалов", inputtext[0]);
				return SPD(playerid, D_NONE, 0, "[House Menu] > —ейф > ћатериалы > ѕоложить", string, "OK", "");
			}
			else
			{
				return SPD(playerid, D_HMENU+18, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф > ћатериалы", "ѕоложить\n¬з€ть", "ENTER", "CANCLE");
			}
		}
	case D_HMENU+20:
		{
			if(response)
			{
				new hid = Pl::Info[playerid][pHouseKey];
				if(sscanf(inputtext, "i", inputtext[0]))
				{
					return SPD(playerid, D_HMENU+20, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > ћатериалы",
					"—колько хотите вз€ть?", "ENTER", "CANCEL");
				}
				if(inputtext[0] < 1 || inputtext[0] > HouseInfo[hid][hSafe][2])
				{
					Send(playerid, COLOR_GREY, "* ¬ сейфе нет столько!");
					return SPD(playerid, D_HMENU+20, DIALOG_STYLE_INPUT,
					"[House Menu] > —ейф > ћатериалы",
					"—колько хотите вз€ть?", "ENTER", "CANCEL");
				}
				HouseInfo[hid][hSafe][2] -= inputtext[0];
				Pl::Info[playerid][pMats] += inputtext[0];
				format(string, sizeof(string), "¬ы вз€ли из сейфа: %i материалов", inputtext[0]);
				return SPD(playerid, D_NONE, 0, "[House Menu] > —ейф > ћатериалы > ¬з€ть", string, "OK", "");
			}
			else
			{
				return SPD(playerid, D_HMENU+18, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф > ћатериалы", "ѕоложить\n¬з€ть", "ENTER", "CANCLE");
			}
		}
	case D_HMENU+21: {
			if(response) {
				SetPVarInt(playerid, "s_index", listitem);
				return SPD(playerid, D_HMENU+22, DIALOG_STYLE_LIST,
				"[House Menu] > —ейф > ќружие","¬з€ть\nѕоложить", "SELECT", "CANCEL");
			} else {
				new hid = Pl::Info[playerid][pHouseKey];
				SafeMenu(playerid, hid);
			}
		}

	case D_HMENU+22: {
			if(response) {
				new hid = Pl::Info[playerid][pHouseKey];
				new idx = GetPVarInt(playerid, "s_index");
				switch(listitem) {
				case 0: {
						if(HouseInfo[hid][hGuns][idx] == 0) {
							Send(playerid, COLOR_GREY, "* ¬ этом слоте нет оружи€!");
							return SafeMenu(playerid, hid, 1);
						}
						Rac::GivePlayerWeapon(playerid, HouseInfo[hid][hGuns][idx], HouseInfo[hid][hAmmos][idx]);
						HouseInfo[hid][hGuns][idx] = 0; HouseInfo[hid][hAmmos][idx] = 0;
						return SPD(playerid, D_HMENU+23, 0, "[House Menu] > —ейф > ќружие", "¬ы вз€ли оружие из сейфа!", "Ќазад", "¬ыход");
					}
				case 1:
					{
						if(HouseInfo[hid][hGuns][idx] != 0)
						{
							Send(playerid, COLOR_GREY, "* ¬ этом слоте уже есть оружи€!");
							return SafeMenu(playerid, hid, 1);
						}
						if(HouseInfo[hid][hAmmos][idx] >= 1000)
						{
							Send(playerid, COLOR_GREY, "* ћало места!");
							return SafeMenu(playerid, hid, 1);
						}
						HouseInfo[hid][hGuns][idx] = Rac::GetPlayerWeapon(playerid);
						HouseInfo[hid][hAmmos][idx] = Rac::GetPlayerAmmo(playerid, HouseInfo[hid][hGuns][idx]);
						Rac::RemovePlayerWeapon(playerid, HouseInfo[hid][hGuns][idx]);
						return SPD(playerid, D_HMENU+23, 0,
						"[House Menu] > —ейф > ќружие", "¬ы положили оружие в сейф!", "Ќазад", "¬ыход");
					}
				}
			}
			else
			{
				SafeMenu(playerid, Pl::Info[playerid][pHouseKey], 1);
			}
		}
	case D_HMENU+23 : {
			if(response) return SafeMenu(playerid, Pl::Info[playerid][pHouseKey], 1);
		}


	case D_RENTCAR:
		{
			if(response)
			{
				new vehid = GetPlayerVehicleID(playerid);
				if(IsACompTruck(vehid))
				{
					new hirefee = HireCost(vehid);
					if (Rac::GetPlayerMoney(playerid) < hirefee)
					{
						Rac::RemovePlayerFromVehicle(playerid);
						Rac::TogglePlayerControllable(playerid, 1);
						Send(playerid, COLOR_GRAD2, "* ” ¬ас мало денег!");
					}
					else
					{
						foreach(new i : Biznes)
						{
							if(PlayerToKvadrat(playerid, BizzInfo[i][bzMinX], BizzInfo[i][bzMinY], BizzInfo[i][bzMaxX], BizzInfo[i][bzMaxY]))
							{
								if(BizzInfo[i][bID] == Bizz_ProdSkladLS || BizzInfo[i][bID] == Bizz_ProdSkladSF)
								{
									if((BizzInfo[i][bID] == Bizz_ProdSkladLS && Pl::Info[playerid][pBizKey] != Bizz_ProdSkladLS)
											|| (BizzInfo[i][bID] == Bizz_ProdSkladSF && Pl::Info[playerid][pBizKey] != Bizz_ProdSkladSF))
									{
										Rac::GivePlayerMoney(playerid, -hirefee);
										GiveBizzProfit(i, hirefee);
										PlayerPlaySound(playerid, 1052, 0.0, 0.0, 0.0);
										format(string, sizeof(string), "~r~-$%i~n~~w~To open or close using ~g~/lock.~w~successful work!", hirefee);
										GameTextForPlayer(playerid, string, 5000, 3);
										Send(playerid, COLOR_GREEN, "* ¬ы можете доставл€ть продукты в бизнесы");
										Send(playerid, COLOR_GREEN, "*  оманды доставки /buyprods /sellprods");
									}
									else
									{
										GameTextForPlayer(playerid, "~w~No charge for the boss.~n~To open or close using ~g~/lock.~w~successful work!", 5000, 3);
										Send(playerid, COLOR_GREEN, "* ¬ы можете доставл€ть продукты в бизнесы");
										Send(playerid, COLOR_GREEN, "*  оманды доставки /buyprods /sellprods");
									}
									if(HireCar[playerid] != INVALID_VEHICLE_ID)
									{
										ToggleVehicleDoor(HireCar[playerid], true);
									}
									HireCar[playerid] = vehid;
									Rac::TogglePlayerControllable(playerid, 1);
									break;
								}
							}
						}
					}
				}
				else
				{
					Rac::RemovePlayerFromVehicle(playerid);
					Rac::TogglePlayerControllable(playerid, 1);
				}
			}
			else
			{
				Rac::RemovePlayerFromVehicle(playerid);
				Rac::TogglePlayerControllable(playerid, 1);
			}
			return 1;
		}

	case D_TUNING: {
			if(response) {
				switch(listitem) {
				case 0: {
						SPD(playerid, D_TUNING+1, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Tuning", "* ¬ы хотите заригистрировать тюнинг.\n\
						—тоимость улуги: $100000", "OK", "CANCEL");
					}

				case 1: {
						SPD(playerid, D_TUNING+2, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Tuning", "* ¬ы хотите удалить тюнинг.\n\
						—тоимость улуги: $50000", "OK", "CANCEL");
					}
				}
			}

			return 1;
		}
	case D_TUNING+1: {
			if(response) {
				if(Rac::GetPlayerMoney(playerid) < 100000) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
				new bidx = GetIndexFromBizID(Bizz_AutoSolonClassC);
				new house = Pl::Info[playerid][pHouseKey];
				UpdateTuning(HouseInfo[house][hAuto], 1, house);
				Rac::GivePlayerMoney(playerid, -100000);
				GiveBizzProfit(bidx, 10000);
				BizzInfo[bidx][bProds]--;
				Send(playerid, COLOR_LIGHTBLUE, "* “юнинг был зарегистрирован!");
			} else {
				SPD(playerid, D_TUNING, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Tuning", "«арегистрировать тюнинг\n”далить тюнинг", "SELECT", "CANCEL");
			}
		}
	case D_TUNING+2: {
			if(response) {
				if(Rac::GetPlayerMoney(playerid) < 5000) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
				new bidx = GetIndexFromBizID(Bizz_AutoSolonClassC);
				new hidx = Pl::Info[playerid][pHouseKey];
				if(IsValidHouse(hidx)) {
					Rac::GivePlayerMoney(playerid, -5000);
					GiveBizzProfit(bidx, 5000);
					BizzInfo[bidx][bProds]--;
					ResetTuning(HouseInfo[hidx][hAuto], 1, hidx);
					Send(playerid, COLOR_LIGHTBLUE, "* “юнинг был удален!");
				} else {
					Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
				}
			} else {
				SPD(playerid, D_TUNING, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Tuning", "«арегистрировать тюнинг\n”далить тюнинг", "SELECT", "CANCEL");
			}
		}

	case D_GOTO : {
			if(response) {
				switch(listitem) {
				case 0 : {
						SPD(playerid, D_GOTO+1,DIALOG_STYLE_LIST,""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты > ѕопул€рные места",
						"Ч Los Santos\nЧ San Fierro\nЧ Las Venturas\nЧ јвтоЎкола\n\
						Ч “юрьма\nЧ ѕрисон\nЧ ќтель Ћ—\nЧ Ѕанк\nЧ ƒальнобой\n\
						Ч ћа€к\nЧ Ќебоскреб Ћос —антоса\nЧ √ора „иллиад\nЧ –ублевка", "SELECT", "CANCEL");
					}
				case 1 : {
						dialog[0] = '\0';
						static const family[] = {5, 6, 8, 12, 13, 14, 15, 16, 17, 18};
						for(new i; i < sizeof family; i++) {
							scf(dialog, string, "Ч %s\n", FracInfo[family[i]][fName]);
						}
						SPD(playerid, D_GOTO+2, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты > –еспы банд/мафий", dialog, "SELECT", "CANCEL");
					}
				case 2 : {
						dialog[0] = '\0';
						static const team[] = {1, 2, 3, 4, 7, 9, 10, 11};
						for(new i; i < sizeof team; i++) {
							scf(dialog, string, "Ч %s\n", FracInfo[team[i]][fName]);
						}
						SPD(playerid, D_GOTO+3, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты > –еспы фракций", dialog, "SELECT", "CANCEL");
					}
				}
			}
			return 1;
		}

	case D_GOTO+1 : {
			if(response) {
				static const Float:tp_respInfo[][] = {
					{1529.6,-1691.2,13.3},
					{-1417.0,-295.8,14.1},
					{1699.2,1435.1,10.7},
					{-2029.798,-106.675,1038.171},
					{263.9608,82.2232,1004.6830},
					{223.8246,1889.4766,17.6406},
					{2225.5227,-1119.8511,25.7969},
					{1461.3962,-1027.9645,23.3168},
					{-72.1355,-1144.2100,4.1964},
					{146.9576,-1965.2183,3.7734},
					{1546.7333,-1371.1244,329.4535},
					{-2256.3052,-1745.8374,487.5512},
					{-2503.6970,2434.2261,16.8024}
				};

				if(0 <= listitem <= sizeof(tp_respInfo)) {
					if(GetPlayerState(playerid) == 2) {
						new tmpcar = GetPlayerVehicleID(playerid);
						Rac::SetVehiclePos(tmpcar, tp_respInfo[listitem][0], tp_respInfo[listitem][1], tp_respInfo[listitem][2]);
					} else {
						Rac::SetPlayerPos(playerid, tp_respInfo[listitem][0], tp_respInfo[listitem][1], tp_respInfo[listitem][2]);
					}
					switch(listitem) {
					case 3 : {
							Rac::SetPlayerVirtualWorld(playerid, 11);
							Rac::SetPlayerInterior(playerid,3);
						}
					case 4 : {
							Rac::SetPlayerVirtualWorld(playerid, 1);
							Rac::SetPlayerInterior(playerid, 6);
						}
						default : {
							Rac::SetPlayerVirtualWorld(playerid, 0);
							Rac::SetPlayerInterior(playerid, 0);
						}
					}
					Pl::Info[playerid][pLocal] = 0;
					Send(playerid, COLOR_WHITE, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬ы были телепортированы!");
				}
			} else {
				SPD(playerid, D_GOTO, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты", "Ч ѕопул€рные места\nЧ –еспы банд\nЧ –еспы фракций", "SELECT", "CANCEL");
			}
		}

	case D_GOTO+2: {
			if(response) {
				static const Float:gg_respInfo[][4] = {
					{1141.9388,-2035.1228,69.0078,178.7023},
					{1462.1758,2768.4282,10.8203,267.1316},
					{-1038.2272,-1222.7651,129.2188,89.8312},
					{1060.6426,2159.7278,10.8203,92.2892},
					{-2740.4331,-333.2186,7.1792,314.0976},
					{2474.6370,-1679.3092,13.3365,231.6960},
					{1757.7224,-1895.2913,13.5561,266.3302},
					{876.3609,-1102.0140,24.2969,268.9612},
					{-2156.4856,-197.4804,35.3203,179.7661},
					{2773.9526,-1607.6476,10.9219,268.2025},
					{1063.1372,2159.8367,10.8203,87.9544}
				};
				if(0 <= listitem <= sizeof(gg_respInfo)) {
					new tmpcar = GetPlayerVehicleID(playerid);
					if(GetPlayerState(playerid) == 2) {
						Rac::SetVehiclePos(tmpcar, gg_respInfo[listitem][0], gg_respInfo[listitem][1], gg_respInfo[listitem][2]);
						SetVehicleZAngle(tmpcar, gg_respInfo[listitem][3]);
					} else {
						Rac::SetPlayerPos(playerid, gg_respInfo[listitem][0], gg_respInfo[listitem][1], gg_respInfo[listitem][2]);
						SetPlayerFacingAngle(playerid, gg_respInfo[listitem][3]);
					}
					Pl::Info[playerid][pLocal] = 0;
					Rac::SetPlayerVirtualWorld(playerid, 0);
					Rac::SetPlayerInterior(playerid,0);
					Send(playerid, COLOR_WHITE, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬ы были телепортированы!");
				}
			} else {
				SPD(playerid, D_GOTO, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты", "Ч ѕопул€рные места\nЧ –еспы банд\nЧ –еспы фракций", "SELECT", "CANCEL");
			}
		}

	case D_GOTO+3 : {
			if(response) {
				static const Float:gf_respInfo[][] = {
					{1531.4489,-1701.7860,6.2188},
					{-1581.9905,677.6925,-4.9063},
					{223.8246,1889.4766,17.6406},
					{-2681.4397,638.0493,14.453},
					{1469.1552,-1771.1403,18.7958},
					{752.0109,-1356.0024,13.7000},
					{-1719.3878,1028.7029,17.5859},
					{-2044.9961,-119.2935,34.9892}
				};
				if(0 <= listitem <= sizeof(gf_respInfo)) {
					new tmpcar = GetPlayerVehicleID(playerid);
					if(GetPlayerState(playerid) == 2) {
						Rac::SetVehiclePos(tmpcar, gf_respInfo[listitem][0], gf_respInfo[listitem][1], gf_respInfo[listitem][2]);
					} else {
						Rac::SetPlayerPos(playerid, gf_respInfo[listitem][0], gf_respInfo[listitem][1], gf_respInfo[listitem][2]);
					}
					Pl::Info[playerid][pLocal] = 0;
					Rac::SetPlayerVirtualWorld(playerid, 0);
					Rac::SetPlayerInterior(playerid,0);
					Send(playerid, COLOR_WHITE, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬ы были телепортированы!");
				}
			} else {
				SPD(playerid, D_GOTO, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": “елепорты", "Ч ѕопул€рные места\nЧ –еспы банд\nЧ –еспы фракций", "SELECT", "CANCEL");
			}
		}

	case D_REFILL : {
			if(response) {
				if(!sscanf(inputtext, "i", inputtext[0])) {
					new i = GetPVarInt(playerid, "SelectGas");
					new veh = GetPlayerVehicleID(playerid);
					if(!(1 <= inputtext[0] <= 100)) return Send(playerid, COLOR_GREY, "* ¬ы не можите заправитс€ больше чем на 100 литров!");
					if((floatround(AutoInfo[veh][aFuel]) + inputtext[0]) > 100) return Send(playerid, COLOR_GREY, "* ¬ бензобак не влезит столько бензина!");
					new FillUP = (inputtext[0] * (BizzInfo[GetIndexFromBizID(RefillInfo[i][brBizID])][bEnterCost]/100));
					if(Rac::GetPlayerMoney(playerid) < FillUP) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег на запрваку!");
					SetTimerEx("Fillup", 250, false, "iiii", playerid, inputtext[0], FillUP, inputtext[0]);
					Rac::TogglePlayerControllable(playerid, 0);
					format(string, sizeof string, "~g~%i~n~~b~Please wait...", inputtext[0]);
					GameTextForPlayer(playerid, string, 600, 5);
				}
			} else {
				SetPVarInt(playerid, "SelectGas", 0xFFFF);
			}
		}

	case D_CRANK: {
			if(response) {
				if(!sscanf(inputtext, "p<.>i{s[40]}", inputtext[0])) {
					new frac = GetPVarInt(playerid, "SelectedFrac");
					SetPVarInt(playerid, "SelectedRank", inputtext[0]);
					if(Pl::Info[playerid][pLeader] == frac || Pl::isAdmin(playerid, 5)) {
						format( dialog, sizeof dialog, "“екущее: %s\n¬ведите новое название ранга.\n", RankInfo[frac][inputtext[0]]);
						SPD(playerid, D_CRANK+1, 1, "Ќазвание ранга", dialog, "OK", "CANCEL");
					} else {
						Send(playerid, COLOR_GREY, "* Ќедостаточно прав!");
					}
				}
			}
		}

	case D_CRANK+1: {
			if(response) {
				new len = strlen(inputtext);
				new frac = GetPVarInt(playerid, "SelectedFrac"), rank = GetPVarInt(playerid, "SelectedRank");
				if(isnull(inputtext) || inputtext[0] == ' ') {
					Send(playerid, COLOR_GREY, "* ѕоле ввода пустое!");
					format(dialog, sizeof dialog, "* Ќеверный ввод!\n“екущее: %s\n¬ведите новое название ранга.\n", RankInfo[frac][rank] );
					SPD(playerid, D_CRANK+1, 1, "Ќазвание ранга", dialog, "OK", "CANCEL");
				} else if(!len || len > 36) {
					Send(playerid, COLOR_GREY, "* ћакс. длина ранга состовл€ет 36 символов!");
					format(dialog, sizeof dialog, "“екущее: %s\n¬ведите новое название ранга.\n", RankInfo[frac][rank]);
					SPD(playerid, D_CRANK+1, 1, "Ќазвание ранга", dialog, "ENTER", "CANCLE");
				} else if(!regex_match_exid(inputtext, ValidText)) {
					Send(playerid, COLOR_GREY, "* ¬ названии ранга есть заприщеные символы!");
					format(dialog, sizeof dialog, "“екущее: %s\n¬ведите новое название ранга.\n", RankInfo[frac][rank]);
					SPD(playerid, D_CRANK+1, 1, "Ќазвание ранга", dialog, "OK", "CANCEL");
				} else {
					format(dialog, sizeof dialog, "–анг был изменен!\n\n  —тарый: %s\n  Ќовый: %s\n", RankInfo[frac][rank], inputtext);
					SPD(playerid, D_CRANK+2, 0, "Ќазвание ранга", dialog, "OK", "CANCEL");
					UpdateRank(frac, rank, inputtext);
				}
			} else {
				ShowRankList(playerid, GetPVarInt(playerid, "SelectedFrac"));
			}
		}

	case D_CRANK+2: {
			if(!response) ShowRankList(playerid, GetPVarInt(playerid, "SelectedFrac"));
		}

	case D_BMENU: {
			new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
			if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
			if(response) {
				switch(listitem) {
				case 0 : {
						PrintBizInfo(playerid, Pl::Info[playerid][pBizKey]);
					}
				case 1 : {
						SPD(playerid, D_BMENU+1, DIALOG_STYLE_LIST, "[Biz Menu] > —чет бизнеса", ""#_GREY_ARROW"—н€ть деньги\n"#_GREY_ARROW"ѕоложить деньги", "ENTER", "CANCLE");
					}
				case 2 : {
						format(string, sizeof(string), "* ¬ведите стоимость(от $1 до $9999) услуг бизнеса.\n\n“екуща€ стоимость: $%i", BizzInfo[bidx][bEnterCost]);
						SPD(playerid, D_BMENU+4, DIALOG_STYLE_INPUT, "[Biz Menu] > —тоимость услуг", string, "ENTER", "CANCLE");
					}
				case 3 : {
						format(string, sizeof(string), "* ¬ведите новое название бизнеса.\n\n“екущие название: %s", BizzInfo[bidx][bDescription]);
						SPD(playerid, D_BMENU+5, DIALOG_STYLE_INPUT, "[Biz Menu] > Ќазвание бизнеса", string, "ENTER", "CANCLE");
					}
				case 4 : {
						format(string, sizeof(string), "* ¬ведите сумму(от $1 до $999) по которой будут\n\
						закупатс€ продукты в бизнес.\n\n“екуща€ сумма: $%i", BizzInfo[bidx][bPriceProd]);
						SPD(playerid, D_BMENU+6, DIALOG_STYLE_INPUT, "[Biz Menu] > ÷ена за продукты", string, "ENTER", "CANCLE");
					}
				case 5 : {
						format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
						„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
						SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
					}
				}
			}
		}

	case D_BMENU+1: {
			if(response) {
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				switch(listitem) {
				case 0: {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите сн€ть!\n\n“екущий баланс: $%i", BizzInfo[bidx][bSafe]);
						SPD(playerid, D_BMENU+2, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
				case 1: {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите положить!\n\n“екущий баланс: $%i\nЌаличные: $%i", BizzInfo[bidx][bSafe], Rac::GetPlayerMoney(playerid));
						SPD(playerid, D_BMENU+3, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
				}
			} else {
				ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu]", "dialog/bmenu.txt", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+2: {
			if(response) {
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(sscanf(inputtext, "i", inputtext[0]) == 0) {
					if(inputtext[0] < 1) {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите сн€ть!\n\n“екущий баланс: $%i", BizzInfo[bidx][bSafe]);
						SPD(playerid, D_BMENU+2, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
					else if(inputtext[0] > 1000000) {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите сн€ть!\n\n“екущий баланс: $%i", BizzInfo[bidx][bSafe]);
						SPD(playerid, D_BMENU+2, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
					else if(BizzInfo[bidx][bSafe] >= inputtext[0]) {
						BizzInfo[bidx][bSafe] -= inputtext[0];
						Rac::GivePlayerMoney(playerid, inputtext[0]);
						format(string, sizeof(string), "¬ы сн€ли: $%i\nќсталось на счету: $%i", inputtext[0], BizzInfo[bidx][bSafe]);
						SPD(playerid, D_NONE, 0, "[Biz Menu] > —чет бизнеса", string, "OK", "");
					}
					else {
						format(dialog, sizeof dialog, "—ейчас на счету:\t$%i\n¬ведите сумму которую хотите сн€ть.", BizzInfo[bidx][bSafe]);
						SPD(playerid, D_BMENU+2, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
				} else {
					format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите сн€ть!\n\n“екущий баланс: $%i", BizzInfo[bidx][bSafe]);
					SPD(playerid, D_BMENU+2, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
				}
			} else {
				SPD(playerid, D_BMENU+1, DIALOG_STYLE_LIST, "[Biz Menu] > —чет бизнеса", ""#_GREY_ARROW"—н€ть деньги\n"#_GREY_ARROW"ѕоложить деньги", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+3: {
			if(response) {
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(sscanf(inputtext, "i", inputtext[0]) == 0) {
					if(inputtext[0] < 1) {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите положить!\n\n“екущий баланс: $%i\nЌаличные: $%i", BizzInfo[bidx][bSafe], Rac::GetPlayerMoney(playerid));
						SPD(playerid, D_BMENU+3, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
					else if(Rac::GetPlayerMoney(playerid) >= inputtext[0]) {
						BizzInfo[bidx][bSafe] += inputtext[0];
						Rac::GivePlayerMoney(playerid, -inputtext[0]);
						format(string, sizeof(string), "—умма: $%i\n“екущий баланс: $%i\nЌаличные: $%i", inputtext[0], BizzInfo[bidx][bSafe], Rac::GetPlayerMoney(playerid));
						SPD(playerid, D_NONE, 0, "[Biz Menu] > —чет бизнеса", string, "OK", "");
					}
					else {
						format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите положить!\n\n“екущий баланс: $%i\nЌаличные: $%i", BizzInfo[bidx][bSafe], Rac::GetPlayerMoney(playerid));
						SPD(playerid, D_BMENU+3, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
					}
				} else {
					format(dialog, sizeof dialog, "* ¬ведите сумму(от $1 до $1kk) которую хотите положить!\n\n“екущий баланс: $%i\nЌаличные: $%i", BizzInfo[bidx][bSafe], Rac::GetPlayerMoney(playerid));
					SPD(playerid, D_BMENU+3, DIALOG_STYLE_INPUT, "[Biz Menu] > —чет бизнеса", dialog, "ENTER", "CANCLE");
				}
			} else {
				SPD(playerid, D_BMENU+1, DIALOG_STYLE_LIST, "[Biz Menu] > —чет бизнеса", ""#_GREY_ARROW"—н€ть деньги\n"#_GREY_ARROW"ѕоложить деньги", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+4 : {
			if(response) {
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(!sscanf(inputtext, "i", inputtext[0])) {
					if(1 <= inputtext[0] <= 9999) {
						BizzInfo[bidx][bEnterCost] = inputtext[0];
						format(string, sizeof(string), "“екуща€ стоимость: $%i", BizzInfo[bidx][bEnterCost]);
						SPD(playerid, D_NONE, 0, "[Biz Menu] > —тоимость услуг", string, "OK", "");
					} else {
						format(string, sizeof(string), "* ¬ведите стоимость(от $1 до $9999) услуг бизнеса.\n\n“екуща€ стоимость: $%i", BizzInfo[bidx][bEnterCost]);
						SPD(playerid, D_BMENU+4, DIALOG_STYLE_INPUT, "[Biz Menu] > —тоимость услуг", string, "ENTER", "CANCLE");
					}
				} else {
					format(string, sizeof(string), "* ¬ведите стоимость(от $1 до $9999) услуг бизнеса.\n\n“екуща€ стоимость: $%i", BizzInfo[bidx][bEnterCost]);
					SPD(playerid, D_BMENU+4, DIALOG_STYLE_INPUT, "[Biz Menu] > —тоимость услуг", string, "ENTER", "CANCLE");
				}
			} else {
				ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu]", "dialog/bmenu.txt", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+5 : {
			if(response) {
				new len = strlen(inputtext);
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(!len || len > 24 || inputtext[0] == ' ') {
					format(string, sizeof(string), "* ¬ведите новое название бизнеса.\n\n“екущие название: %s", BizzInfo[bidx][bDescription]);
					SPD(playerid, D_BMENU+5, DIALOG_STYLE_INPUT, "[Biz Menu] > Ќазвание бизнеса", string, "ENTER", "CANCLE");
				} else {
					strmid(BizzInfo[bidx][bDescription], inputtext, 0, len, 24);
					format(string, sizeof(string), "* Ќазвание изменино!\n\n“екущие название: %s", BizzInfo[bidx][bDescription]);
					SPD(playerid, D_NONE, 0, "[Biz Menu] > Ќазвание бизнеса", string, "OK", "");
				}
			} else {
				ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu]", "dialog/bmenu.txt", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+6: {
			if(response) {
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx) && !IsPlayerBizExtortion(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(sscanf(inputtext, "i", inputtext[0]) == 0) {
					if(1 <= inputtext[0] <= 999) {
						BizzInfo[bidx][bPriceProd] = inputtext[0];
						format(string, sizeof(string), "Ќова€ цена за продукты:\t$%i", BizzInfo[bidx][bPriceProd]);
						SPD(playerid, D_NONE, 0, "[Biz Menu] > ÷ена за продукты", string, "OK", "");
					}
					else {
						format(string, sizeof(string), "* ¬ведите сумму(от $1 до $999) по которой будут\n\
						закупатс€ продукты в бизнес.\n\n“екуща€ сумма: $%i", BizzInfo[bidx][bPriceProd]);
						SPD(playerid, D_BMENU+6, DIALOG_STYLE_INPUT, "[Biz Menu] > ÷ена за продукты", string, "ENTER", "CANCLE");
					}
				} else {
					format(string, sizeof(string), "* ¬ведите сумму(от $1 до $999) по которой будут\n\
					закупатс€ продукты в бизнес.\n\n“екуща€ сумма: $%i", BizzInfo[bidx][bPriceProd]);
					SPD(playerid, D_BMENU+6, DIALOG_STYLE_INPUT, "[Biz Menu] > ÷ена за продукты", string, "ENTER", "CANCLE");
				}
			} else {
				ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu]", "dialog/bmenu.txt", "ENTER", "CANCLE");
			}
		}

	case D_BMENU+7 : {
			if(response) {
				new player, len = strlen(inputtext);
				new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
				if(!IsPlayerBizOwner(playerid, bidx)) return Send(playerid, COLOR_GREY, "* ¬ам не принадлежит бизнес!");
				if(sscanf(inputtext, "s[24]", string) == 0) {
					sscanf(string, "u", player);
					if(player == playerid) {
						Send(playerid, COLOR_GREY, "* ¬ы владелец бизнеса!");
						format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
						„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
						SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
					}
					else if(strval(string) == 255) {
						strmid(BizzInfo[bidx][bExtortion], "No-one", 0, strlen("No-one"), 24);
						format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
						„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
						SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
					}
					else if(!Pl::isLogged(player)) {
						Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
						format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
						„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
						SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
					}
					else {
						Pl::Info[player][pBizKey] = BizzInfo[bidx][bID];
						strmid(BizzInfo[bidx][bExtortion], string, 0, len, 24);
						format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
						„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
						SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
					}
				} else {
					format(string, sizeof(string),"* ¬ведите ID игрока чтобы назначить нового компаньона.\n\
					„тобы убрать компаньона введите 255.\n\n“екущий компаньон: %s", BizzInfo[bidx][bExtortion]);
					SPD(playerid, D_BMENU+7, 1, "[Biz Menu] >  омпаньон", string, "ENTER", "CANCLE");
				}
			} else {
				ShowDialog(playerid, D_BMENU, DIALOG_STYLE_LIST, "[Biz Menu]", "dialog/bmenu.txt", "ENTER", "CANCLE");
			}
		}

	case D_LMENU-1 : {
			if(response) {
				new fracid = Pl::FracID(playerid);
				if(strfind(inputtext, "–анги", true) != -1) {
					ShowRankList(playerid, fracid);

				} else if(strfind(inputtext, "“ранспорт", true) != -1) {
					ShowDialog(playerid, D_LMENU, 2, "L-Menu. “ранспорт", "dialog/lmenu/main.txt", "SELECT", "CANCEL");

				} else if(strfind(inputtext, "–анг захвата", false) != -1) {
					SPD(playerid, D_LMENU+8, 1, "L-Menu. –анг захвата", "¬ведите ранг захвата:", "OK", "CANCEL");

				} else if(strfind(inputtext, "„ерный список", true) != -1) {
					ShowLMenu(playerid, D_LMENU+9);

				} else if(strfind(inputtext, "–анг новостей", true) != -1) {
					SPD(playerid, D_LMENU+14, 1, "L-Menu. –анг новостей", "¬ведите ранг дл€ написани€ в /gov:", "OK", "CANCEL");

				} else if(strfind(inputtext, "”правление автошколой", true) != -1) {
					SPD(playerid, D_LMENU+10, 2, "L-Menu. ”правление автошколой", "«акрыть\nќткрыть", "SELECT", "CANCEL");
				}
			}
		}

	case D_LMENU : {
			if(response) {
				switch(listitem) {
				case 0 : SPD(playerid, D_LMENU+1, 0, "L-Menu: —мена цвета", " акой цвет хотите помин€ть?", "[-1-]", "[-2-]");

				case 1 : SPD(playerid, D_LMENU+4, 1, "L-Menu: —мена ранга", "¬ведите ранг с которого будет доступна машина.", "Enter", "Back");

				case 2 : SPD(playerid, D_LMENU+5, 1, "L-Menu: —мена номера", "¬ведите новый номер(макс. 8 символов)", "Enter", "Back");

				case 3 : SPD(playerid, D_LMENU+6, 0, "L-Menu: —мена места спавна", "—менить место спавна этого авто?", "Enter", "Back");

				case 4 : {
						if(Fc::IsEditMode(playerid)) {
							new v_frac, carid = GetPlayerVehicleID(playerid);
							if(Fc::GetInfo(carid, "f", v_frac)) Fc::ShowModel(playerid, v_frac, D_LMENU+7);
						} else {
							Fc::ShowModel(playerid, Pl::FracID(playerid), D_LMENU+7);
						}
					}
				}
			} else {
				ShowLMenu(playerid);
			}
			return 1;
		}

	case D_LMENU+10 : {
			if(response) {
				for(new i; i < TOTAL_PORTAL; i++) {
					if(Portal::Info[i][Portal::Id] == 11) {
						for(new f; f < MAX_FRAC; f++) {
							Portal::Info[i][Portal::Allowed][f] = listitem;
						}
						updatePickup(i);
						Send(playerid, -1, (listitem)?("* јвтошкола открыта!"):("* јвтошкола закрыта!"));
						return 1;
					}
				}
			}
			return 1;
		}

	case D_LMENU+8 : {
			if(response) {
				new fracid = Pl::FracID(playerid);
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+8, DIALOG_STYLE_INPUT, "L-Menu. –анг захвата", "* ѕоле ввода пустое!\n\n¬ведите ранг захвата:", "OK", "CANCEL");
				} else if(!(1 <= inputtext[0] <= RankNums[fracid])) {
					SPD(playerid, D_LMENU+8, DIALOG_STYLE_INPUT, "L-Menu. –анг захвата", "* Ќеверный ранг!\n\n¬ведите ранг захвата:", "OK", "CANCEL");
				} else {
					SetZRank(fracid, inputtext[0]);
					ShowLMenu(playerid);
				}
			} else {
				ShowLMenu(playerid);
			}

			return 1;
		}

	case D_LMENU+9 : {
			if(response) {
				switch(listitem) {
				case 0 : SPD(playerid, D_LMENU+11, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "¬ведите ранг добавлени€ в „—:", "OK", "CANCEL");
				case 1 : SPD(playerid, D_LMENU+12, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "¬ведите сумму выхода из „—:", "OK", "CANCEL");
				case 2 : SPD(playerid, D_LMENU+13, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "¬ведите кол-во убийств дл€ выхода из „—:", "OK", "CANCEL");
				}
			} else {
				ShowLMenu(playerid);
			}
			return 1;
		}


	case D_LMENU+11 : {
			if(response) {
				new fracid = Pl::FracID(playerid);
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+11, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "* ѕоле ввода пустое!\n¬ведите ранг добавлени€ в „—:", "OK", "CANCEL");
				} else if(!(1 <= inputtext[0] <= RankNums[fracid])) {
					SPD(playerid, D_LMENU+11, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "* Ќеверный ранг!\n¬ведите ранг добавлени€ в „—:", "OK", "CANCEL");
				} else {
					SetBRank(fracid, inputtext[0]);
					ShowLMenu(playerid, D_LMENU+9);
				}
			} else {
				ShowLMenu(playerid, D_LMENU+9);
			}
		}

	case D_LMENU+12 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+12, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "* ѕоле ввода пустое!\n¬ведите сумму выхода из „—:", "OK", "CANCEL");
				} else if(!(1 <= inputtext[0] <= 3000000)) {
					SPD(playerid, D_LMENU+12, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "* —умма должна быть от 1 до $3000000!\n¬ведите ранг добавлени€ в „—:", "OK", "CANCEL");
				} else {
					FracInfo[Pl::FracID(playerid)][fBConf][bPRICE] = inputtext[0];
					ShowLMenu(playerid, D_LMENU+9);
				}
			} else {
				ShowLMenu(playerid, D_LMENU+9);
			}
		}

	case D_LMENU+13 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+13, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "* ѕоле ввода пустое!\n¬ведите кол-во убийств дл€ выхода из „—:", "OK", "CANCEL");
				} else if(!(1 <= inputtext[0] <= 25)) {
					SPD(playerid, D_LMENU+13, DIALOG_STYLE_INPUT, "L-Menu. „ерный список", "*  ол-во убийств может быть от 1 до 25!\n¬ведите кол-во убийств дл€ выхода из „—:", "OK", "CANCEL");
				} else {
					FracInfo[Pl::FracID(playerid)][fBConf][bKILLS] = inputtext[0];
					ShowLMenu(playerid, D_LMENU+9);
				}
			} else {
				ShowLMenu(playerid, D_LMENU+9);
			}
		}

	case D_LMENU+14 : {
			if(response) {
				new fracid = Pl::FracID(playerid);
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+14, DIALOG_STYLE_INPUT, "L-Menu. –анг новостей", "* ѕоле ввода пустое!\n¬ведите ранг дл€ написани€ в /gov:", "OK", "CANCEL");
				} else if(!(1 <= inputtext[0] <= RankNums[fracid])) {
					SPD(playerid, D_LMENU+14, DIALOG_STYLE_INPUT, "L-Menu. –анг новостей", "* Ќеверный ранг!\n¬ведите ранг дл€ написани€ в /gov:", "OK", "CANCEL");
				} else {
					SetGRank(fracid, inputtext[0]);
					ShowLMenu(playerid);
				}
			} else {
				ShowLMenu(playerid);
			}
		}

	case D_LMENU+1 : {
			if(response) {
				ShowDialog(playerid, D_LMENU+2, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
			} else {
				ShowDialog(playerid, D_LMENU+3, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
			}
			return 1;
		}

	case D_LMENU+2 : {
			if(response && Pl::Info[playerid][pLeader]) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					Send(playerid, COLOR_GREY, "* ¬ы оставили поле ввода пустым!");
					ShowDialog(playerid, D_LMENU+2, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
				} else if(inputtext[0] < 0 || inputtext[0] > 256) {
					Send(playerid, COLOR_GREY, "* ¬ы ввели не правельный ID цвета!");
					ShowDialog(playerid, D_LMENU+2, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
				} else {
					new idx, v_frac, carid = GetPlayerVehicleID(playerid);
					if(!Pl::isAdmin(playerid, ADMINISTRATOR)) if(!IsInRespawn(Pl::FracID(playerid), carid))
					return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от респавна!");

					if(Fc::GetInfo( carid, "fi", v_frac, idx)) {
						if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
							new Float: posa, fracmoney = GetFracMoney(v_frac), cost = (ModelCost(GetVehicleModel(carid)) / 10);
							if(!Fc::IsEditMode(playerid) && cost > fracmoney) {
								format(string, sizeof(string), "* Ќедостаточно средств! Ќеобходимо: $%i", cost);
								Send(playerid, COLOR_GREY, string);
							} else {
								if(!Fc::IsEditMode(playerid)) GiveFracMoney(v_frac, -cost);
								GetVehiclePos(carid, posx, posy, posz); GetVehicleZAngle(carid, posa);
								AutoInfo[0][aMileage] = AutoInfo[carid][aMileage];
								Fc::Info[idx][Fc::Color][0] = inputtext[0];
								Fc::RecreateVehicle( idx ); Fc::Update( idx );
								AutoInfo[carid][aMileage] = AutoInfo[0][aMileage];
								SetVehiclePos(Fc::Info[idx][Fc::Id][1], posx, posy, posz); SetVehicleZAngle(carid, posa);
								SetVehicleNumberPlate(Fc::Info[idx][Fc::Id][1], Fc::Info[idx][Fc::Number]);
								Rac::PutPlayerInVehicle(playerid, Fc::Info[idx][Fc::Id][1], 0);
								format(string, sizeof(string),"* ÷вет машины был изминен на: %d", inputtext[0]);
								Send(playerid, COLOR_WHITE, string);
								format(string, sizeof(string), "~r~-$%i", cost);
								GameTextForPlayer(playerid, string, 5000, 1);
							}
						} else {
							format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
							Send(playerid, COLOR_GREY, string);
						}
					}
				}
			}

			return 1;
		}

	case D_LMENU+3 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					Send(playerid, COLOR_GREY, "* ¬ы оставили поле ввода пустым!");
					ShowDialog(playerid, D_LMENU+3, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
				} else if(inputtext[0] < 0 || inputtext[0] > 256) {
					Send(playerid, COLOR_GREY, "* ¬ы ввели не правельный ID цвета!");
					ShowDialog(playerid, D_LMENU+3, 1, "L-Menu: —мена цвета", "dialog/lmenu/colors.txt", "OK", "CANCEL");
				} else {
					new idx, v_frac, carid = GetPlayerVehicleID(playerid);
					if(!Pl::isAdmin(playerid, ADMINISTRATOR)) if(!IsInRespawn(Pl::FracID(playerid), carid))
					return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от респавна!");

					if(Fc::GetInfo( carid, "fi", v_frac, idx)) {
						if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
							new Float: posa, fracmoney = GetFracMoney(v_frac), cost = (ModelCost(GetVehicleModel(carid)) / 10);
							if(!Fc::IsEditMode(playerid)) if( cost > fracmoney) {
								format(string, sizeof(string), "* Ќедостаточно средств! Ќеобходимо: $%i", cost);
								Send(playerid, COLOR_GREY, string);
							} else {
								if(!Fc::IsEditMode(playerid)) GiveFracMoney(v_frac, -cost);
								GetVehiclePos(carid, posx, posy, posz); GetVehicleZAngle(carid, posa);
								AutoInfo[0][aMileage] = AutoInfo[carid][aMileage];
								Fc::Info[idx][Fc::Color][1] = inputtext[0];
								Fc::RecreateVehicle( idx ); Fc::Update( idx );
								SetVehiclePos(Fc::Info[idx][Fc::Id][1], posx, posy, posz); SetVehicleZAngle(carid, posa);
								SetVehicleNumberPlate(Fc::Info[idx][Fc::Id][1], Fc::Info[idx][Fc::Number]);
								AutoInfo[carid][aMileage] = AutoInfo[0][aMileage];
								Rac::PutPlayerInVehicle(playerid, Fc::Info[idx][Fc::Id][1], 0);
								format(string, sizeof(string),"* ÷вет машины был изминен на: %d", inputtext[0]);
								Send(playerid, COLOR_WHITE, string);
								format(string, sizeof(string), "~r~-$%i", cost);
								GameTextForPlayer(playerid, string, 5000, 1);
							}
						} else {
							format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
							Send(playerid, COLOR_GREY, string);
						}
					}
				}
			}
		}

	case D_LMENU+4 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_LMENU+4, DIALOG_STYLE_INPUT, "L-Menu: —мена ранга", "¬ведите ранг с которого будет доступна машина.", "Enter", "Back");
				} else {
					new idx, v_frac, carid = GetPlayerVehicleID(playerid);
					if( Fc::GetInfo( carid, "fi", v_frac, idx ) ) {
						if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
							Fc::Info[idx][Fc::RankId] = inputtext[0];
							Fc::Update( idx );
							format(string, sizeof(string),"* “еперь машина доступна с %d-го ранга!", inputtext[0]);
							Send(playerid, COLOR_WHITE, string);
						} else {
							format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
							Send(playerid, COLOR_GREY, string);
						}
					}
				}
			} else {
				ShowDialog(playerid, D_LMENU, 2, "L-Menu:  „то хотите изменить?", "dialog/lmenu/main.txt", "SELECT", "CANCEL");
			}
		}

	case D_LMENU+5 : {
			if(response) {
				new number[10];
				if(sscanf(inputtext, "s[10]", number)) return SPD(playerid, D_LMENU+5, 1, "L-Menu: —мена номера", "¬ведите новый номер(макс. 8 символов)", "Enter", "Back");
				if(strlen(number) < 1 || strlen(number) > 8) return SPD(playerid, D_LMENU+5, 1, "L-Menu: —мена номера", "¬ведите новый номер(макс. 8 символов)", "Enter", "Back");
				if(!regex_match_exid(number, ValidText)) return SPD(playerid, D_LMENU+5, 1, "L-Menu: —мена номера", "¬ведите новый номер(макс. 8 символов)", "Enter", "Back");

				new idx, v_frac, carid = GetPlayerVehicleID(playerid);
				if(!Pl::isAdmin(playerid, ADMINISTRATOR)) if(!IsInRespawn(Pl::FracID(playerid), carid))
				return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от респавна!");

				if(Fc::GetInfo( carid, "fi", v_frac, idx)) {
					if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
						new Float: posa, fracmoney = GetFracMoney(v_frac), cost = (ModelCost(GetVehicleModel(carid)) / 10);
						if(!Fc::IsEditMode(playerid)) if(cost > fracmoney) {
							format(string, sizeof(string), "* Ќедостаточно средств! Ќеобходимо: $%i", cost);
							Send(playerid, COLOR_GREY, string);
						} else {
							if(!Fc::IsEditMode(playerid)) GiveFracMoney(v_frac, -cost);
							format(Fc::Info[idx][Fc::Number], 10, "%s", number);
							GetVehiclePos(carid, posx, posy, posz); GetVehicleZAngle(carid, posa);
							AutoInfo[0][aMileage] = AutoInfo[carid][aMileage];
							Fc::RecreateVehicle( idx ); Fc::Update( idx );
							SetVehiclePos(Fc::Info[idx][Fc::Id][1], posx, posy, posz); SetVehicleZAngle(Fc::Info[idx][Fc::Id][1], posa);
							SetVehicleNumberPlate(Fc::Info[idx][Fc::Id][1], Fc::Info[idx][Fc::Number]);
							AutoInfo[Fc::Info[idx][Fc::Id][1]][aMileage] = AutoInfo[0][aMileage];
							Rac::PutPlayerInVehicle(playerid, Fc::Info[idx][Fc::Id][1], 0);
							Send(playerid, COLOR_WHITE, "* Ќомер был изменен!");
							format(string, sizeof(string), "~r~-$%i", cost);
							GameTextForPlayer(playerid, string, 5000, 1);
						}
					} else {
						format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
						Send(playerid, COLOR_GREY, string);
					}
				}
			} else {
				ShowDialog(playerid, D_LMENU, 2, "L-Menu:  „то хотите изменить?", "dialog/lmenu/main.txt", "SELECT", "CANCEL");
			}
		}

	case D_LMENU+6 : {
			if(response) {
				new idx, v_frac, carid = GetPlayerVehicleID(playerid);
				if(!Pl::isAdmin(playerid, ADMINISTRATOR)) if(!IsInRespawn(Pl::FracID(playerid), carid))
				return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от респавна!");

				if(Fc::GetInfo(carid, "fi", v_frac, idx)) {
					if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
						AutoInfo[0][aMileage] = AutoInfo[carid][aMileage];
						GetVehiclePos(carid, Fc::Info[idx][Fc::RespPos][0], Fc::Info[idx][Fc::RespPos][1], Fc::Info[idx][Fc::RespPos][2]);
						GetVehicleZAngle(carid, Fc::Info[idx][Fc::RespPos][3]);
						Fc::RecreateVehicle( idx ); Fc::Update( idx );
						SetVehicleNumberPlate(Fc::Info[idx][Fc::Id][1], Fc::Info[idx][Fc::Number]);
						AutoInfo[Fc::Info[idx][Fc::Id][1]][aMileage] = AutoInfo[0][aMileage];
						Rac::PutPlayerInVehicle(playerid, Fc::Info[idx][Fc::Id][1], 0);
						Send(playerid, COLOR_WHITE, "* ћашина была припаркована!");
					} else {
						format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
						Send(playerid, COLOR_GREY, string);
					}
				}
			} else {
				ShowDialog(playerid, D_LMENU, 2, "L-Menu:  „то хотите изменить?", "dialog/lmenu/main.txt", "SELECT", "CANCEL");
			}
		}

	case D_LMENU+7 : {
			if(response) {
				new model_id;
				name_to_id(inputtext, model_id);

				if(model_id < 400 || model_id > 611) return Send(playerid, COLOR_GREY, "* Unknown model id!");
				if(Fc::IsForbiddenVeh(model_id)) return Send( playerid, COLOR_GREY, "* Forbidden model id!");

				new idx, v_frac, carid = GetPlayerVehicleID(playerid);
				if(!Pl::isAdmin(playerid, 5) ) if(!IsInRespawn(Pl::FracID(playerid), carid))
				return Send(playerid, COLOR_GREY, "* ¬ы слишком далеко от респавна!");

				if(Fc::GetInfo(carid, "fi", v_frac, idx)) {
					if(v_frac == Pl::Info[playerid][pLeader] && !Fc::IsEditMode(playerid)) {
						new Float: posa, fracmoney = GetFracMoney(v_frac), cost = ModelCost( model_id );
						if(!Fc::IsEditMode(playerid)) if(cost > fracmoney) {
							format(string, sizeof(string), "* Ќедостаточно средств! Ќеобходимо: $%i", cost);
							Send(playerid, COLOR_GREY, string);
						} else {
							if(!Fc::IsEditMode(playerid)) GiveFracMoney(v_frac, -cost);
							GetVehiclePos(carid, posx, posy, posz); GetVehicleZAngle(carid, posa);
							Fc::Info[idx][Fc::Model] = model_id;
							Fc::RecreateVehicle( idx ); Fc::Update( idx );
							AutoInfo[Fc::Info[idx][Fc::Id][1]][aMileage] = 0.0000;
							SetVehiclePos(Fc::Info[idx][Fc::Id][1], posx, posy, posz); SetVehicleZAngle(carid, posa);
							SetVehicleNumberPlate(Fc::Info[idx][Fc::Id][1], Fc::Info[idx][Fc::Number]);
							Rac::PutPlayerInVehicle(playerid, Fc::Info[idx][Fc::Id][1], 0);
							Send(playerid, COLOR_WHITE, "* ¬ы изменили марку машины!");
							format(string, sizeof(string), "~r~-$%i", cost);
							GameTextForPlayer(playerid, string, 5000, 1);
						}
					} else {
						format(string, sizeof(string),"* ¬ы не лидер %s", FracInfo[Fc::Info[idx][Fc::FracId]][fName]);
						Send(playerid, COLOR_GREY, string);
					}
				}
			} else {
				ShowDialog(playerid, D_LMENU, 2, "L-Menu:  „то хотите изменить?", "dialog/lmenu/main.txt", "SELECT", "CANCEL");
			}
		}

	case D_ADD_FC : {
			if(response) {
				new frac_id, model_id;
				name_to_id( inputtext, model_id );

				if( model_id < 400 || model_id > 611 ) return Send(playerid, COLOR_GREY, "* Unknown model id!");
				if( Fc::IsForbiddenVeh( model_id ) ) return Send( playerid, COLOR_GREY, "* Forbidden model id!");
				frac_id = GetPVarInt( playerid, "SelectFrac");
				new Float: r_pos[4]; GetPlayerPos( playerid, r_pos[0], r_pos[1], r_pos[2]); GetPlayerFacingAngle(playerid, r_pos[3]);
				format(query, sizeof query, "INSERT INTO `"#__TableFracVehicles__"` (`model`,`frac`,`resp_pos`) VALUES \
				('%i','%i','%.3f,%.3f,%.3f,%.3f')", model_id, frac_id, r_pos[0], r_pos[1], r_pos[2], r_pos[3]);

				new Cache:result = Db::query(connDb, query, true);
				if(cache_affected_rows()) {
					new id = Fc::TOTAL; Fc::TOTAL++;

					Fc::Info[id][Fc::Id][0] 		= cache_insert_id();
					Fc::Info[id][Fc::Model] 		= model_id;
					Fc::Info[id][Fc::FracId]		= frac_id;
					Fc::Info[id][Fc::Color][0] 	= random( 100 );
					Fc::Info[id][Fc::Color][1] 	= random( 100 );
					Fc::Info[id][Fc::RespPos][0]	= r_pos[0];
					Fc::Info[id][Fc::RespPos][1]	= r_pos[1];
					Fc::Info[id][Fc::RespPos][2]	= r_pos[2];
					Fc::Info[id][Fc::RespPos][3]	= r_pos[3];

					strmid(Fc::Info[id][Fc::Number], Fc::DEF_NUMBER, 0, strlen(Fc::DEF_NUMBER), 255);

					Fc::Info[id][Fc::Id][1] =
					Veh::Create(
					Fc::Info[id][Fc::Model],
					Fc::Info[id][Fc::RespPos][0],
					Fc::Info[id][Fc::RespPos][1],
					Fc::Info[id][Fc::RespPos][2],
					Fc::Info[id][Fc::RespPos][3],
					Fc::Info[id][Fc::Color][0],
					Fc::Info[id][Fc::Color][1],
					1200
					);

					SetVehicleNumberPlate(Fc::Info[id][Fc::Id][1], Fc::Info[id][Fc::Number]);
					Rac::PutPlayerInVehicle(playerid, Fc::Info[id][Fc::Id][1], 0); Fc::Update( id );
					Iter::Add(TeamVehicles[frac_id], Fc::Info[id][Fc::Id][1]);
					Send( playerid, COLOR_YELLOW, "* ћашина добавлена!");
				}
				cache_delete(result);
			}
		}

	case D_SHOW_MODEL : {
			if(response) {
				if(!strcmp(inputtext, "ƒобавить", true)) {
					ShowDialog( playerid, D_ADD_MODEL, 1, "ƒобавить", "dialog/lmenu/addmodel.txt", "Ok", "Cancel");
				}
				else if(strcmp(inputtext, "------------", true)){
					new model_id;
					name_to_id( inputtext, model_id );
					if(model_id < 400 || model_id > 611) return Send(playerid, COLOR_GREY, "* Unknown model id!");
					if(Fc::IsForbiddenVeh(model_id)) return Send( playerid, COLOR_GREY, "* Forbidden model id!");

					SetPVarInt( playerid, "SelectModel", model_id);
					SPD( playerid, D_EDIT_MODEL, 2, "Options", "»зменить\n”далить", "Ok", "Cancel");
				}
			}
		}

	case D_EDIT_MODEL : {
			new frac_id = GetPVarInt(playerid, "SelectFrac");
			if(response) {
				switch(listitem) {
				case 0 : {
						SPD( playerid, D_EDIT_MODEL+1, 1, "Edit model", "¬ведите новый ID или название модели.\nѕример: 400 или Landstalker", "Ok", "Cancel");
					}
				case 1 : {
						new model_id = GetPVarInt( playerid, "SelectModel" );
						format(query, sizeof query, "DELETE FROM `"#__TableFracModels__"` WHERE `frac_id` = '%i' AND `model_id` = '%i'", frac_id, model_id);
						Db::tquery(connDb, query, "", "");
						Send( playerid, COLOR_WHITE, " Ёта модель была удалена из списка доступных!");
					}
				}
			} else {
				Fc::ShowModel(playerid, frac_id, D_SHOW_MODEL);
			}
		}

	case D_EDIT_MODEL+1 : {
			if(response) {
				new newmodel;
				if(!name_to_id(inputtext, newmodel)) {
					SPD( playerid, D_EDIT_MODEL+1, 1, "Edit model", "¬ведите новый ID или название модели.\nѕример: 400 или Landstalker", "Ok", "Cancel");
				} else {
					if( Fc::IsForbiddenVeh( newmodel ) ) return Send( playerid, COLOR_GREY, "* Forbidden model id!");
					new frac_id = GetPVarInt( playerid, "SelectFrac" );
					new model_id = GetPVarInt( playerid, "SelectModel" );
					format(query, sizeof query, "UPDATE `"#__TableFracModels__"` SET `model_id` = '%i' WHERE \
					`frac_id` = '%i' AND `model_id` = '%i'", newmodel, frac_id, model_id);
					Db::tquery(connDb, query, "", "");
					Send(playerid, COLOR_WHITE, " ћодель была изменена!");
				}
			}
		}

	case D_ADD_MODEL : {
			if(response) {
				new model_id;
				if(!name_to_id(inputtext, model_id)){
					ShowDialog(playerid, D_ADD_MODEL, 1, "ƒобавить", "dialog/lmenu/addmodel.txt", "Ok", "Cancel");
				} else {
					new frac_id = GetPVarInt( playerid, "SelectFrac" );
					if(model_id < 400 || model_id > 611) return Send(playerid, COLOR_GREY, "* Unknown model id!");
					if(Fc::IsForbiddenVeh(model_id)) return Send( playerid, COLOR_GREY, "* Forbidden model id!");
					if(Fc::IsThereModel(frac_id, model_id)) return Send(playerid, COLOR_RED, "* Ёта модель уже есть в списке!");
					format(query, sizeof query, "INSERT INTO `"#__TableFracModels__"` (`frac_id`, `model_id`) VALUES ('%i','%i')", frac_id, model_id);
					Db::tquery(connDb, query, "", "");
					format(string, sizeof(string), " ћодель добвалена! Model_id: %i; Model_name: %s", model_id, VehicleNames[model_id-400]);
					Send(playerid, COLOR_WHITE, string);
				}
			}
		}

	case TP_EDIT : {
			if(response) {
				switch(listitem) {
				case 0 : SPD(playerid, TP_EDIT+1, 2, "ѕервый пикап", "ћодель\n“ип\n¬ирт. мир\nѕозици€", "SELECT", "CANCEL");
				case 1 : SPD(playerid, TP_EDIT+2, 2, "¬торой пикап", "ћодель\n“ип\n¬ирт. мир\nѕозици€", "SELECT", "CANCEL");
				case 2 : {
						dialog[0] = '\0';
						new portal = GetPVarInt(playerid, "selectTeleport");
						for(new i; i < MAX_FRAC; i++) {
							if(Portal::Info[portal][Portal::Allowed][i]) {
								scf(dialog,string,"[{33AA33} - {ffffff}]{%h}%s\t\t{ffffff}\n", (GetFracColor(i)>>>8), FracInfo[i][fName]);
							} else {
								scf(dialog,string,"[{AA3333} X {ffffff}]{%h}%s\t\t{ffffff}\n", (GetFracColor(i)>>>8), FracInfo[i][fName]);
							}
						}
						SPD(playerid, TP_EDIT+9, 2, "ƒоступность дл€ фракций", dialog, "SELECT", "CANCEL");
					}

				case 3 : {
						TOTAL_PORTAL --;
						new i = GetPVarInt(playerid, "selectTeleport");
						DestroyDynamicPickup(Portal::Info[i][Portal::Pickup][0]);
						DestroyDynamicPickup(Portal::Info[i][Portal::Pickup][1]);
						format(query, sizeof query, "DELETE FROM `"#__TablePickups__"` WHERE `id`='%i'", Portal::Info[i][Portal::Id]);
						Db::tquery(connDb, query, "", "");

						CopyArray(Portal::Info[i][Portal::Model], Portal::Info[TOTAL_PORTAL][Portal::Model], 2);
						CopyArray(Portal::Info[i][Portal::Type], Portal::Info[TOTAL_PORTAL][Portal::Type], 2);
						CopyArray(Portal::Info[i][Portal::Inter], Portal::Info[TOTAL_PORTAL][Portal::Inter], 2);
						CopyArray(Portal::Info[i][Portal::World], Portal::Info[TOTAL_PORTAL][Portal::World], 2);
						CopyArray(Portal::Info[i][Portal::Pickup], Portal::Info[TOTAL_PORTAL][Portal::Pickup], 2);
						CopyArray(Portal::Info[i][Portal::Portal1], Portal::Info[TOTAL_PORTAL][Portal::Portal1], 4);
						CopyArray(Portal::Info[i][Portal::Portal2], Portal::Info[TOTAL_PORTAL][Portal::Portal2], 4);
					}
				}
			} else {
				SetPVarInt(playerid, "selectTeleport", 0xffff);
			}
		}

	case TP_EDIT+1 : {
			if(response) {
				switch(listitem) {
				case 0 : SPD(playerid, TP_EDIT+3, 1, "ћодель пикапа", "¬ведите id объекта.", "ENTER", "CANCEL");
				case 1 : SPD(playerid, TP_EDIT+5, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				case 2 : SPD(playerid, TP_EDIT+7, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				case 3 : Send(playerid, -1, "¬станте на то место где должен быть пикап и введите /setpic1");
				}
			} else {
				format(string, sizeof string, "Telepot є%i", Portal::Info[GetPVarInt(playerid, "selectTeleport")][Portal::Id]);
				SPD(playerid,TP_EDIT,2,string,"ѕерый пикап\n¬торой пикап\nќткрыть/«акрыть\n”далить","¬ыбор","¬ыход");
			}
		}

	case TP_EDIT+2 : {
			if(response) {
				switch(listitem) {
				case 0 : SPD(playerid, TP_EDIT+4, 1, "ћодель пикапа", "¬ведите id объекта.", "ENTER", "CANCEL");
				case 1 : SPD(playerid, TP_EDIT+6, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				case 2 : SPD(playerid, TP_EDIT+8, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				case 3 : Send(playerid, -1, "¬станте на то место где должен быть пикап и введите /setpic2");
				}
			} else {
				format(string, sizeof string, "Telepot є%i", Portal::Info[GetPVarInt(playerid, "selectTeleport")][Portal::Id]);
				SPD(playerid,TP_EDIT,2,string,"ѕерый пикап\n¬торой пикап\nќткрыть/«акрыть\n”далить","¬ыбор","¬ыход");
			}
		}

	case TP_EDIT+3 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+3, 1, "ћодель пикапа", "¬ведите id объекта.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::Model][0] = inputtext[0];
					Streamer::SetIntData(1, Portal::Info[teleport][Portal::Pickup][0], E_STREAMER_MODEL_ID, inputtext[0]);
					updatePickup( teleport ), SetPVarInt(playerid, "selectTeleport", 0xffff), Streamer::Update(playerid);
				}
			} else {
				SPD(playerid, TP_EDIT+1, 2, "ѕервый пикап", "ћодель\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+4 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+3, 1, "ћодель пикапа", "¬ведите id объекта.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::Model][1] = inputtext[0];
					Streamer::SetIntData(1, Portal::Info[teleport][Portal::Pickup][1], E_STREAMER_MODEL_ID, inputtext[0]);
					updatePickup( teleport ), SetPVarInt(playerid, "selectTeleport", 0xffff), Streamer::Update(playerid);
				}
			} else {
				SPD(playerid, TP_EDIT+1, 2, "¬торой пикап", "ћодель\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+5 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+5, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				} else if(inputtext[0] < 1 || inputtext[0] > 23) {
					SPD(playerid, TP_EDIT+5, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::Type][0] = inputtext[0];
					Streamer::SetIntData(1, Portal::Info[teleport][Portal::Pickup][0], E_STREAMER_TYPE, inputtext[0]);
					updatePickup( teleport ), SetPVarInt(playerid, "selectTeleport", 0xffff), Streamer::Update(playerid);
				}
			} else {
				SPD(playerid, TP_EDIT+1, 2, "¬торой пикап", "ћодель\n“ип\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+6 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+6, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				} else if(inputtext[0] < 1 || inputtext[0] > 23) {
					SPD(playerid, TP_EDIT+6, 1, "“ип пикапа", "¬ведите тип пикапа.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::Type][1] = inputtext[0];
					Streamer::SetIntData(1, Portal::Info[teleport][Portal::Pickup][1], E_STREAMER_TYPE, inputtext[0]);
					updatePickup( teleport ), SetPVarInt(playerid, "selectTeleport", 0xffff), Streamer::Update(playerid);
				}
			} else {
				SPD(playerid, TP_EDIT+2, 2, "¬торой пикап", "ћодель\n“ип\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+7 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+7, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				} else if(inputtext[0] < 0) {
					SPD(playerid, TP_EDIT+7, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::World][0] = inputtext[0];
					DestroyDynamicPickup(Portal::Info[teleport][Portal::Pickup][0]);
					Portal::Info[teleport][Portal::Pickup][0]=_AddPickup(Portal::Info[teleport][Portal::Model][0],Portal::Info[teleport][Portal::Type][0],Portal::Info[teleport][Portal::Portal1],Portal::Info[teleport][Portal::World][0]);
					updatePickup( teleport ), Rac::SetPlayerVirtualWorld(playerid,inputtext[0]), SetPVarInt(playerid, "selectTeleport", 0xffff);
				}
			} else {
				SPD(playerid, TP_EDIT+1, 2, "¬торой пикап", "ћодель\n“ип\n¬ирт. мир\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+8 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, TP_EDIT+8, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				} else if(inputtext[0] < 0) {
					SPD(playerid, TP_EDIT+8, 1, "ћир пикапа", "¬ведите мир пикапа.", "ENTER", "CANCEL");
				} else {
					new teleport = GetPVarInt(playerid, "selectTeleport");
					Portal::Info[teleport][Portal::World][1] = inputtext[0];
					DestroyDynamicPickup(Portal::Info[teleport][Portal::Pickup][1]);
					Portal::Info[teleport][Portal::Pickup][1]=_AddPickup(Portal::Info[teleport][Portal::Model][1],Portal::Info[teleport][Portal::Type][1],Portal::Info[teleport][Portal::Portal2],Portal::Info[teleport][Portal::World][1]);
					updatePickup( teleport ), Rac::SetPlayerVirtualWorld(playerid,inputtext[0]), SetPVarInt(playerid, "selectTeleport", 0xffff);
				}
			} else {
				SPD(playerid, TP_EDIT+2, 2, "¬торой пикап", "ћодель\n“ип\n¬ирт. мир\nѕозици€", "SELECT", "CANCEL");
			}
		}

	case TP_EDIT+9 : {
			if(response) {
				dialog[0] = '\0';
				new portal = GetPVarInt(playerid, "selectTeleport");
				Portal::Info[portal][Portal::Allowed][listitem] = !Portal::Info[portal][Portal::Allowed][listitem];
				for(new i; i < MAX_FRAC; i++) {
					if(Portal::Info[portal][Portal::Allowed][i]) {
						scf(dialog,string,"[{33AA33} - {ffffff}]{%h}%s\t\t{ffffff}\n", (GetFracColor(i)>>>8), FracInfo[i][fName]);
					} else {
						scf(dialog,string,"[{AA3333} X {ffffff}]{%h}%s\t\t{ffffff}\n", (GetFracColor(i)>>>8), FracInfo[i][fName]);
					}
				}
				SPD(playerid, TP_EDIT+9, 2, "ƒоступность дл€ фракций", dialog, "SELECT", "CANCEL");
				updatePickup(portal);
			} else {
				format(string, sizeof string, "Telepot є%i", Portal::Info[GetPVarInt(playerid, "selectTeleport")][Portal::Id]);
				SPD(playerid,TP_EDIT,2,string,"ѕерый пикап\n¬торой пикап\nќткрыть/«акрыть\n”далить","¬ыбор","¬ыход");
			}
		}

	case D_CHANGE_PASS : {
			if(response) {
				new hash[SHA1_HASH_LEN];
				KeyProtect(inputtext, hash);
				format(query, sizeof query, "SELECT * FROM `"#__TableUsers__"` WHERE `ID` = '%i' AND `Key` = '%s'", Pl::Info[playerid][pID], hash);
				new Cache:result = Db::query(connDb, query, true);
				if(cache_get_row_count()) {
					SPD(playerid, D_CHANGE_PASS+1,DIALOG_STYLE_PASSWORD,""#__SERVER_PREFIX""#__SERVER_NAME_LC": ATTENTION PLEASE",
					"¬Ќ»ћјЌ»≈! ¬ы хотите изменить пароль своего аккаунта!\n\
					¬ведите новый пароль и нажмите ќ !\n\n\
					Ќе рекомендуетс€ использовать простые пароли. „тобы\n\
					пароль был надежным, он должен содержать цифры,\n\
					заглавные и малые буквы латинского алфавита.","ќ ","ќ“ћ≈Ќј");
				} else {
					Rac::Kick(playerid, "ѕопытка взлома аккаунта");
				}
				cache_delete(result);
			}
		}

	case D_CHANGE_PASS+1 : {
			if(response) {
				if(!strlen(inputtext)) Send(playerid,COLOR_LIGHTRED,""#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬ы не ввели пароль!");
				else {
					new hash[SHA1_HASH_LEN];
					KeyProtect(inputtext, hash);
					format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Key`='%s' WHERE `ID`='%i'", hash, Pl::Info[playerid][pID]);
					Db::tquery(connDb, query, "", "");
					format(string, sizeof(string), ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ¬Ќ»ћјЌ»≈! ѕј–ќЋ№ »«ћ≈Ќ≈Ќ! ¬аш новый пароль: %s", inputtext);
					Send(playerid, COLOR_LIGHTRED, string);
					Send(playerid, COLOR_LIGHTRED,""#__SERVER_PREFIX""#__SERVER_NAME_LC": ќЅя«ј“≈Ћ№Ќќ сделайте скриншот с новым паролем, дл€ этого нажмите F8");
				}
			}
		}

	case D_PDDTEST : {
			if(response) {
				new i = GetPVarInt(playerid, "SelectedItem");
				if(!sscanf(inputtext, "c", inputtext[0])) {
					new letter = tolower(inputtext[0]);
					if('a' <= letter <= 'd') {
						if(correctAnswer[i] == letter) {
							format(string, sizeof string, "¬опрос є%i. ќтвет верный.", i);
							Send(playerid, COLOR_GREEN, string);
						} else {
							Pl::Info[playerid][pTest] ++;
							format(string, sizeof string, "¬опрос є%i. ќтвет не верный.", i);
							Send(playerid, COLOR_LIGHTRED, string);
						}
						if(++i >= sizeof correctAnswer) {
							if(Pl::Info[playerid][pTest] >= 3) {
								SendClientMessage(playerid, COLOR_WHITE, "“ест нe пройден. ƒопущено более 2-х ошибок.");
								Pl::Info[playerid][pTest] = 0;
							} else {
								Pl::Info[playerid][pTest] = 999;
								SendClientMessage(playerid, COLOR_GREEN, "* ѕоздравл€ю вы сдали теорию. ѕрошу встаньте в очередь к практике");
								AshQueue(playerid, 0);
							}
							SetPVarInt(playerid, "SelectedItem", -1);
							return SetTimerEx(""#Rac::"TogglePlayerControllable", 50, false, "ii", playerid, 1);
						} else {
							SetPVarInt(playerid, "SelectedItem", i);
							format(string, sizeof string, "dialog/pddtest/pdd_test_%i.txt", i);
							return ShowDialog(playerid, D_PDDTEST, 1, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": TEST PDD", string, "ќтвет", "ќтмена");
						}
					}
				}
				format(string, sizeof string, "dialog/pddtest/pdd_test_%i.txt", i);
				ShowDialog(playerid, D_PDDTEST, 1, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": PDD TEST", string, "ќтветить","ќтмена");
			} else {
				Pl::Info[playerid][pTest] = 0;
				SetPVarInt(playerid, "SelectedItem", -1);
				Send(playerid, COLOR_GREY, "* ¬ы не сдали тест");
				return SetTimerEx(""#Rac::"TogglePlayerControllable", 50, false, "ii", playerid, 1);
			}
			return 1;
		}

	case D_EN_HOUSE : {
			if(response) {
				new bidx = GetPVarInt(playerid, "PlayerHouse");
				if(Pl::Info[playerid][pHouseKey] == bidx || HouseInfo[bidx][hLock] == 0) {
					EnterHouse(playerid, bidx);
					GameTextForPlayer(playerid, "~w~Welcome Home", 5000, 1);
				} else {
					GameTextForPlayer(playerid, "~r~Locked", 5000, 1);
				}
			}
		}

	case D_EX_HOUSE : {
			if(response) {
				ExitHouse(playerid, GetPVarInt(playerid, "PlayerHouse"));
			}
			return 1;
		}

	case D_EN_BIZ : {
			if(response) {
				new bizz = GetPVarInt(playerid, "PlayerBizz");
				if(Pl::Info[playerid][pBizKey] == BizzInfo[bizz][bID] || Rac::GetPlayerMoney(playerid) >= BizzInfo[bizz][bEnterCost]) {
					if(BizzInfo[bizz][bLocked] == 1) return GameTextForPlayer(playerid, "~r~Closed", 5000, 1);
					if(BizzInfo[bizz][bProds] <= 0) return GameTextForPlayer(playerid, "~r~Out Of Stock", 5000, 1);
					switch(BizzInfo[bizz][bID]) {
					case Bizz_AutoSolonClassA, Bizz_AutoSolonClassB, Bizz_AutoSolonClassC, Bizz_AutoSolonClassD: {
							if(TotalExtraVehicles[playerid] >= ExtraVehicleLimit[Pl::Info[playerid][pVip]]) return Send(playerid, COLOR_GREY, "* ¬ы купили макс. кол-во личного транспорта!");
							new vclass;
							switch(BizzInfo[bizz][bID]) {
							case Bizz_AutoSolonClassA : vclass = 0;
							case Bizz_AutoSolonClassB : vclass = 1;
							case Bizz_AutoSolonClassC : vclass = 2;
							case Bizz_AutoSolonClassD : vclass = 3;
							}
							TempVehicle[playerid] = Veh::Create(AutoSolon[vclass][0][0], StandPos[vclass][vPos][0], StandPos[vclass][vPos][1], StandPos[vclass][vPos][2], StandPos[vclass][vPos][3], -1, -1, 600);
							Rac::SetPlayerPos(playerid, StandPos[vclass][pPos][0], StandPos[vclass][pPos][1], StandPos[vclass][pPos][2]);
							SetPlayerCameraPos(playerid, StandPos[vclass][pCPos][0], StandPos[vclass][pCPos][1], StandPos[vclass][pCPos][2]);
							SetPlayerCameraLookAt(playerid, StandPos[vclass][pCLookAt][0], StandPos[vclass][pCLookAt][1], StandPos[vclass][pCLookAt][2]);

							Pl::Info[playerid][pLocal] = OFFSET_BIZZ + bizz;
							Rac::SetPlayerVirtualWorld(playerid, playerid + Pl::Info[playerid][pLocal]);
							SetVehicleVirtualWorld(TempVehicle[playerid], playerid + Pl::Info[playerid][pLocal]);
							Rac::TogglePlayerControllable(playerid, false);

							SetPVarInt(playerid, "SelectedCar", 0);
							SetPVarInt(playerid, "VehicleClass", vclass);

							format(temp, sizeof temp, "~g~ID:~w~ %i~n~~g~MODEL: ~w~%s ~n~~g~PRICE: ~w~$%i ~n~~g~MAX SPEED: ~w~%i KM/H ~n~~g~CLASS: ~w~%c ~n~~g~in availability: ~w~yes",
							AutoSolon[vclass][0][0], VehicleNames[AutoSolon[vclass][0][0] - 400], AutoSolon[0][0][1],
							floatround(MaxVehicleSpeed[AutoSolon[vclass][0][0] - 400]) - 35, AClassChar[vclass]);

							Pt::SetString(playerid, Td::AutoSolon, temp);
							Pt::Show(playerid, Td::AutoSolon);
							ShowMenuForPlayer(AutoSolonMenu, playerid);
							return 1;
						}

					case Bizz_GarageLS, Bizz_GarageSF, Bizz_GarageLV : {
							if(TotalExtraVehicles[playerid] <= 0) return Send(playerid, COLOR_GREY, "* ” ¬ас нет личного транспорта!");
							if(TotalVehicleInGarage[playerid] <= 0) return Send(playerid, COLOR_GREY, "* ¬ы забрали весь транспорт из гаража!");
							if(IsPlayerTakeExtraVehicle(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы уже вз€ли транспорт из гаража!");
							Pl::Info[playerid][pLocal] = OFFSET_BIZZ + bizz;

							if(Pl::Info[playerid][pBizKey] != BizzInfo[bizz][bID]) {
								BizzInfo[bizz][bProds] --;
								GiveBizzProfit(bizz, BizzInfo[bizz][bEnterCost]);
								Rac::GivePlayerMoney(playerid, -BizzInfo[bizz][bEnterCost]);
								format(string, sizeof string, "~r~-$%d", BizzInfo[bizz][bEnterCost]);
								GameTextForPlayer(playerid, string, 5000, 3);
							}

							TempVehicle[playerid] = Veh::Create(
							ExtraVehicles[playerid][VehicleInGarage[playerid][0]][evModel],
							616.0352,-124.1155,997.7648,90.1765,
							ExtraVehicles[playerid][VehicleInGarage[playerid][0]][evColor1],
							ExtraVehicles[playerid][VehicleInGarage[playerid][0]][evColor2],
							600
							);

							LinkVehicleToInterior(TempVehicle[playerid], 3);
							SetVehicleVirtualWorld(TempVehicle[playerid], playerid + Pl::Info[playerid][pLocal]);

							Rac::SetPlayerPos(playerid, 609.7039,-131.0049,997.9922);
							Rac::SetPlayerInterior(playerid, 3);
							Rac::SetPlayerVirtualWorld(playerid, playerid + Pl::Info[playerid][pLocal]);
							SetPlayerCameraPos(playerid, 609.0421, -130.5442, 999.5136);
							SetPlayerCameraLookAt(playerid, 611.7945, -127.7963, 998.5791);
							TogglePlayerControllable(playerid, false);
							SetPVarInt(playerid, "SelectedCar", 0);
							ShowMenuForPlayer(GarageMenu, playerid);
							return 1;
						}

					case Bizz_PaintBall : {
							format(string, sizeof(string), "~r~-$%i~n~~w~WELCOME PAINT_BALL", BizzInfo[bizz][bEnterCost]);
							return GameTextForPlayer(playerid, string, 5000, 3);
						}
					}

					if(Pl::Info[playerid][pBizKey] != BizzInfo[bizz][bID]) {
						BizzInfo[bizz][bProds]--;
						GiveBizzProfit(bizz, BizzInfo[bizz][bEnterCost]);
						Rac::GivePlayerMoney(playerid,-BizzInfo[bizz][bEnterCost]);
						format(string, sizeof(string), "~r~-$%d", BizzInfo[bizz][bEnterCost]);
						GameTextForPlayer(playerid, string, 5000, 3);
					}

					EnterBiz(playerid, bizz);
				}
				else GameTextForPlayer(playerid, "~r~You dont have the cash", 5000, 1);
			}
			return 1;
		}

	case D_EX_BIZ : {
			if(response) {
				ExitBiz(playerid, GetPVarInt(playerid, "PlayerBizz"));
			}
		}

	case 2222 : {
			if(response) {
				if(Rac::GetPlayerMoney(playerid) < 100000) return Send(playerid, COLOR_GREY, "* ” ¬ас не хватает денег!");
				if(0 <= listitem < sizeof fightStyle) {
					Rac::GivePlayerMoney(playerid, -100000);
					Pl::Info[playerid][pFightstyle] = fightStyle[listitem][0];
					SetPlayerFightingStyle(playerid, fightStyle[listitem][0]);
					format(string, sizeof string, "* “еперь вы деретесь в стиле %s. ¬рем€ дратьс€!", fightStyle[listitem][1]);
					Send(playerid, COLOR_GREEN, string);
				}
			}
			return 1;
		}

	case D_FIGHTSTYLE : {
			if(response) {
				if(0 <= listitem < sizeof fightStyle) {
					Pl::Info[playerid][pFightstyle] = fightStyle[listitem][0];
					SetPlayerFightingStyle(playerid, fightStyle[listitem][0]);
					format(string, sizeof string, "* “еперь вы деретесь в стиле %s. ¬рем€ дратьс€!", fightStyle[listitem][1]);
					Send(playerid, COLOR_GREEN, string);
				}
			}
		}

	case 149 : {
			if(response) {
				if(Rac::GetPlayerHealth(playerid) >= 100.0) return Send(playerid, COLOR_GREY, "* ¬ы сыты!");
				Rac::GivePlayerHealth(playerid, EatInfo[listitem][bHP], 100.0);
				format(string, sizeof(string), "* %s вз€л %s.", GetName(playerid), EatInfo[listitem][bDescription]);
				ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
				format(string, sizeof(string), "~g~+ %.1f HP", EatInfo[listitem][bHP]);
				GameTextForPlayer(playerid, string, 5000, 1);

				if(Rac::GetPlayerHealth(playerid) >= 100.0) {
					Send(playerid, COLOR_GREY, "* ¬ы сыты!");
				} else {
					ShowCantina(playerid);
				}
			}
		}

	case 65 : {
			if(response) {
				Pl::Info[playerid][pSex] = 2;
				Send(playerid, COLOR_LIGHTBLUE, "* ќк, вы девушка");
			} else {
				Pl::Info[playerid][pSex] = 1;
				Send(playerid, COLOR_LIGHTBLUE, "* ќк, вы парень");
			}
		}

		// —»—“≈ћј ЅјЌ ј.
	case D_BANK : {
			if(response) {
				switch(listitem) {
				case 0 : {
						format(string, sizeof(string), "Ѕаланс счета %s: $%i", GetName(playerid), Pl::Info[playerid][pBank]);
						SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "BALANCE", string, "OK", "CANCEL");
					}

				case 1 : {
						SPD(playerid, D_BANK+1, DIALOG_STYLE_INPUT, "WITHDRAW", "¬ведите сумму: ", "OK","CANCEL");
					}

				case 2 : {
						SPD(playerid, D_BANK+2, DIALOG_STYLE_INPUT, "DEPOSIT", "¬ведите сумму: ", "OK","CANCEL");
					}

				case 3 : {
						SPD(playerid, D_BANK+3, DIALOG_STYLE_INPUT, "TRANSFER", "¬ведите сумму перевода: ", "OK","CANCEL");
					}
				}
			}
		}

	case D_BANK+1 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_BANK+1, DIALOG_STYLE_INPUT, "WITHDRAW", "Ќеверный ввод! ѕовторите попытку.\n¬ведите сумму: ", "OK","CANCEL");
				} else {
					if(inputtext[0] > 0 && Pl::Info[playerid][pBank] >= inputtext[0]) {
						Rac::GivePlayerMoney(playerid, inputtext[0]);
						GivePlayerBankMoney(playerid, -inputtext[0]);
						format(string, sizeof(string), "* ¬ы сн€ли $%i со своего счета. ќстаток: $%i", inputtext[0], Pl::Info[playerid][pBank]);
						SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "WITHDRAW", string, "OK", "CANCEL");
					} else {
						SPD(playerid, D_BANK+1, DIALOG_STYLE_INPUT, "WITHDRAW", "Ќедостаточно средств.\n¬ведите сумму: ", "OK","CANCEL");
					}
				}
			} else {
				ShowDialog(playerid, D_BANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": BANK", "dialog/bankmenu.txt", "SELECT","CENCEL");
			}
		}

	case D_BANK+2 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_BANK+2, DIALOG_STYLE_INPUT, "DEPOSIT", "Ќеверный ввод! ѕовторите попытку.\n¬ведите сумму: ", "OK","CANCEL");
				} else {
					if(inputtext[0] > 0 && Rac::GetPlayerMoney(playerid) >= inputtext[0]) {
						Rac::GivePlayerMoney(playerid, -inputtext[0]);
						GivePlayerBankMoney(playerid, inputtext[0]);
						format(string, sizeof(string), "* ¬ы пополнили счет на $%i. “екущий баланс: $%i", inputtext[0], Pl::Info[playerid][pBank]);
						SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "DEPOSIT", string, "OK", "CANCEL");
					} else {
						SPD(playerid, D_BANK+2, DIALOG_STYLE_INPUT, "DEPOSIT", "Ќедостаточно средств.\n¬ведите сумму: ", "OK","CANCEL");
					}
				}
			} else {
				ShowDialog(playerid, D_BANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": BANK", "dialog/bankmenu.txt", "SELECT","CENCEL");
			}
		}

	case D_BANK+3 : {
			if(response) {
				if(sscanf(inputtext, "i", inputtext[0])) {
					SPD(playerid, D_BANK+3, DIALOG_STYLE_INPUT, "TRANSFER", "Ќеверный ввод! ѕовторите попытку\n¬ведите сумму перевода: ", "OK","CANCEL");
				} else {
					if(inputtext[0] > 0 && Pl::Info[playerid][pBank] >= inputtext[0]) {
						SetPVarInt(playerid, "TransferAmount", inputtext[0]);
						format(string, sizeof(string), "* —умма: $%i.\n¬ведите ID получател€ платежа:", inputtext[0]);
						SPD(playerid, D_BANK+4, DIALOG_STYLE_INPUT, "TRANSFER", string, "OK", "CANCEL");
					} else {
						SPD(playerid, D_BANK+3, DIALOG_STYLE_INPUT, "TRANSFER", "Ќедостаточно средств.\n¬ведите сумму перевода: ", "OK","CANCEL");
					}
				}
			} else {
				ShowDialog(playerid, D_BANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": BANK", "dialog/bankmenu.txt", "SELECT","CENCEL");
			}
		}

	case D_BANK+4 : {
			if(response) {
				new player;
				if(sscanf(inputtext, "u", player)) {
					format(string, sizeof(string), "* —умма: $%i.\n¬ведите ID получател€ платежа:", GetPVarInt(playerid, "TransferAmount"));
					SPD(playerid, D_BANK+4, DIALOG_STYLE_INPUT, "TRANSFER", string, "OK", "CANCEL");
				} else {
					if(playerid == player) {
						SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "TRANSFER", "¬ы ввели свой ID!", "OK", "CANCEL");
					} else if(Pl::isLogged(player)) {
						SetPVarInt(playerid, "TransferPlayer", player);
						SetTimerEx("OnPlayerBankTransfer", 1000*10, false, "i", playerid);
						format(string, sizeof(string), "¬ы собираетесь совершить перевод на сумму $%i игроку [%i]%s.\n\
						” ¬ас есть 10 секунд дл€ подтверждени€ платежа!", GetPVarInt(playerid, "TransferAmount"), player, GetName(player));
						SPD(playerid, D_BANK+5, DIALOG_STYLE_MSGBOX, "TRANSFER", string, "OK", "CANCEL");
					} else {
						format(string, sizeof(string), "»грок не залогинен!\n\n* —умма: $%i.\n¬ведите ID получател€ платежа:", GetPVarInt(playerid, "TransferAmount"));
						SPD(playerid, D_BANK+4, DIALOG_STYLE_INPUT, "TRANSFER", string, "OK", "CANCEL");
					}
				}
			} else {
				SPD(playerid, D_BANK+3, DIALOG_STYLE_INPUT, "TRANSFER", "¬ведите сумму перевода: ", "OK", "CANCEL");
			}
		}

	case D_BANK+5 : {
			if(response) {
				new player = GetPVarInt(playerid, "TransferPlayer");
				if(player == INVALID_PLAYER_ID) {
					SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "TRANSFER", "¬рем€ транзакции истекло!\nѕовторите попытку.", "OK", "CANCEL");
				} else {
					new amount = GetPVarInt(playerid, "TransferAmount");
					GivePlayerBankMoney(playerid, -amount);
					GivePlayerBankMoney(player, amount);
					new bidx = OFFSET_BIZZ - bidx;
					if(amount >= 10000 && IsValidBiz(bidx)) GiveBizzProfit(bidx, amount/99);
					format(string, sizeof(string), "* ѕеревод успешно совершен!\n\
					—умма: $%i\nѕолучатель: [%i]%s\nќтправитель: [%i]%s", amount, player, GetName(player), playerid, GetName(playerid));
					SPD(playerid, D_BANK+33, DIALOG_STYLE_MSGBOX, "DEPOSIT", string, "OK", "CANCEL");
					format(string, sizeof(string), "* %s[%i] перевел на ваш счет $%i", GetName(playerid), playerid, amount);
					Send(player, COLOR_GREY, string);
					format(string, sizeof(string), "[BANK] * %s[%i] transfer $%i to %s[%i] | %.3f kk", GetName(playerid), playerid, amount, GetName(player), player, float(amount/1000000));
					SendToAdmin(COLOR_YELLOW, string, 1, 3);
				}
				SetPVarInt(playerid, "TransferPlayer", INVALID_PLAYER_ID);
				SetPVarInt(playerid, "TransferAmount", 0);
			} else {
				format(string, sizeof(string), "* —умма: $%i.\n¬ведите ID получател€ платежа:", GetPVarInt(playerid, "TransferAmount"));
				SPD(playerid, D_BANK+4, DIALOG_STYLE_INPUT, "TRANSFER", string, "OK", "CANCEL");
			}
		}

	case D_BANK+33 : {
			ShowDialog(playerid, D_BANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": BANK", "dialog/bankmenu.txt", "SELECT","CENCEL");
		}
		// —»—“≈ћј ЅјЌ ј. END

		// —»—“≈ћј ЅјЌ јћј“ќ¬
	case D_ATM : {
			if(response) {
				switch(listitem) {
				case 0: {
						format(dialog, sizeof dialog, "Ќапишите сумму, которую хотите сн€ть со счета.\nћаксимум $100000 за одну опирацию.\n\
						— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
						SPD(playerid, D_ATM+1, DIALOG_STYLE_INPUT,""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. WITHDRAW", dialog, "OK", "CANCEL");
					}

				case 1: {
						format(dialog, sizeof dialog, "Ќапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
						— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
						SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
					}

				case 2: {
						format(dialog, sizeof dialog, "Ѕаланс счета %s: $%i", GetName(playerid), Pl::Info[playerid][pBank]);
						SPD(playerid, D_ATM+33, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. BALANCE", dialog, "OK", "CANCEL");
					}
				}
			}
		}

	case D_ATM+1 : {
			if(response) {
				new cash = 0;
				if(sscanf(inputtext, "i", cash)) {
					format(dialog, sizeof dialog, "* Ќеверный ввод! ѕовторите попытку!\n\
					\nЌапишите сумму, которую хотите сн€ть со счета.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+1, DIALOG_STYLE_INPUT,""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. WITHDRAW", dialog, "OK", "CANCEL");
				} else if(cash > 100000) {
					format(dialog, sizeof dialog, "Ќапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
				} else if(cash < 100) {
					format(dialog, sizeof dialog, "* ћинимальна€ сумма за одну операцию состовл€ет 100$\n\
					\nЌапишите сумму, которую хотите сн€ть со счета.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+1, DIALOG_STYLE_INPUT,""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. WITHDRAW", dialog, "OK", "CANCEL");
				} else if(inputtext[0] > Pl::Info[playerid][pBank]) {
					Send(playerid, COLOR_GREY, "Ќельз€ сн€ть больше денег, чем на счету!");
					format(dialog, sizeof dialog, "* Ќедостаточно средств на счету!\n\
					\nЌапишите сумму, которую хотите сн€ть со счета.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+1, DIALOG_STYLE_INPUT,""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. WITHDRAW", dialog, "OK", "CANCEL");
				} else {
					new proc = (cash*3)/100;
					new babki = cash - proc;
					GiveBizzProfit(0, proc);
					GivePlayerBankMoney(playerid, -babki);
					Rac::GivePlayerMoney(playerid, babki);
					format(dialog, sizeof dialog, "* ¬ы сн€ли $%i со своего счета. ќстаток: $%i", babki, Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+33, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. WITHDRAW", dialog, "OK", "CANCLE");
				}
			} else {
				ShowDialog(playerid, D_ATM, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM.", "dialog/atmmenu.txt", "SELECT","CENCEL");
			}
		}

	case D_ATM+2 : {
			if(response) {
				new cash;
				if(sscanf(inputtext, "i", cash)) {
					format(dialog, sizeof dialog, "* Ќеверный ввод! ѕовторите попытку!\n\
					\nЌапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
				} else if(cash > 100000) {
					format(dialog, sizeof dialog, "* Ќеверный ввод! ѕовторите попытку!\n\
					\nЌапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
				} else if(cash < 100) {
					format(dialog, sizeof dialog, "* ћинимальна€ сумма за одну операцию состовл€ет 100$\n\
					\nЌапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
					— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
					SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
				} else {
					cash -= ((cash * 3) / 100);
					if(cash > Rac::GetPlayerMoney(playerid)) {
						format(dialog, sizeof dialog, "* ” ¬ас недостаточно средств!\n\
						\nЌапишите сумму, которую хотите положить на счет.\nћаксимум $100000 за одну опирацию.\n\
						— каждой перечисленной суммы взымаетс€ налог в 3 процента!", Pl::Info[playerid][pBank]);
						SPD(playerid, D_ATM+2, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
					} else {
						GivePlayerBankMoney(playerid, cash);
						Rac::GivePlayerMoney(playerid, -cash);
						format(dialog, sizeof dialog, "* ¬ы пополнили счет на $%i. “екущий баланс: $%i", cash, Pl::Info[playerid][pBank]);
						SPD(playerid, D_ATM+33, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM. DEPOSIT", dialog, "OK", "CANCEL");
					}
				}
			} else {
				ShowDialog(playerid, D_ATM, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM.", "dialog/atmmenu.txt", "SELECT","CENCEL");
			}
		}

	case D_ATM+33 : {
			ShowDialog(playerid, D_ATM, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_C" ATM.", "dialog/atmmenu.txt", "SELECT","CENCEL");
		}
		// —»—“≈ћј ЅјЌ јћј“ќ¬. END

		// —»—“≈ћј ‘–ј ÷»ќЌЌќ√ќ ЅјЌ ј
	case D_FBANK: {
			if(response) {
				SetPVarInt(playerid, "SelectedItem", listitem);
				format(string, sizeof(string), "—чет %s", FracInfo[FracID[listitem]][fName]);
				SPD(playerid, D_FBANK+1, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "ЅјЋјЌ—", "ѕ≈–≈¬ќƒ");
			}
		}

	case D_FBANK+1: {
			new idx = GetPVarInt(playerid, "SelectedItem");
			if(!response) {
				if(Bl::Info[playerid][Bl::onFrac][FracID[idx]] && FracInfo[FracID[idx]][fBConf][bPRICE]) {
					format(string, sizeof(string), "¬ыход из черного списка\n%s.\n—умма выхода: $%i", FracInfo[FracID[idx]][fName], FracInfo[FracID[idx]][fBConf][bPRICE]);
					SPD(playerid, D_FBANK+4, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				} else {
					format(string, sizeof(string), "ѕеревод средств на счет\n%s.\n¬ведите сумму :", FracInfo[FracID[idx]][fName]);
					SPD(playerid, D_FBANK+3, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				}
			} else {
				if(Pl::FracID(playerid) == FracID[idx] || EditMode[playerid]) {
					format(string, sizeof(string), "Ѕаланс %s:\n$%i", FracInfo[FracID[idx]][fName], GetFracMoney(FracID[idx]));
					SPD(playerid, D_FBANK+2, DIALOG_STYLE_MSGBOX, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				} else {
					Send(playerid, COLOR_GREY, "* ѕровер€ть баланс счета могут только его владельцы!");
				}
			}
		}

	case D_FBANK+2: {
			ShowFracBank(playerid);
		}

	case D_FBANK+3: {
			if(response) {
				new idx = GetPVarInt(playerid, "SelectedItem");
				if(sscanf(inputtext, "i", inputtext[0])) {
					format(string, sizeof(string), "ѕеревод средств на счет\n%s.\n¬ведите сумму :", FracInfo[FracID[idx]][fName]);
					SPD(playerid, D_FBANK+3, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				}

				else if(!(1 <= inputtext[0] < 1000000000)) {
					format(string, sizeof(string), "ѕеревод средств на счет\n%s.\n¬ведите сумму :", FracInfo[FracID[idx]][fName]);
					SPD(playerid, D_FBANK+3, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				}

				else if(inputtext[0] > Rac::GetPlayerMoney(playerid)) {
					Send(playerid,COLOR_GREY,"* ” ¬ас нет столько денег!");
					format(string, sizeof(string), "ѕеревод средств на счет\n%s.\n¬ведите сумму :", FracInfo[FracID[idx]][fName]);
					SPD(playerid, D_FBANK+3, DIALOG_STYLE_INPUT, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", string, "OK", "CANCEL");
				}

				else {
					GiveFracMoney(FracID[idx], inputtext[0]);
					Rac::GivePlayerMoney(playerid, -inputtext[0]);
					GetPlayerName(playerid, plname, 24);

					if(IsAMafiaF(FracID[idx]) || IsAGangF(FracID[idx])) {
						format(string, sizeof(string), "[TRANSFER]: √ул€й братва %s положил на счЄт $%i", plname, inputtext[0]);
					} else {
						format(string, sizeof(string), "[TRANSFER]: “олько что %s положил на счЄт $%i", plname, inputtext[0]);
					}
					sendToFamily(FracID[idx], COLOR_AZTECAS, string);
					format(string, sizeof(string), "* —чет %s успешно пополнен на $%i", FracInfo[FracID[idx]][fName], inputtext[0]);
					Send(playerid, COLOR_LIGHTBLUE, string);
				}

			} else {
				ShowFracBank(playerid);
			}
		}

	case D_FBANK+4: {
			if(response) {
				new idx = GetPVarInt(playerid, "SelectedItem");
				if(Bl::Info[playerid][Bl::onFrac][FracID[idx]]) {
					new exitprice = FracInfo[FracID[idx]][fBConf][bPRICE];
					if(Rac::GetPlayerMoney(playerid) >= exitprice) {
						GetPlayerName(playerid, plname, 24);
						GiveFracMoney(FracID[idx], exitprice);
						Rac::GivePlayerMoney(playerid, -exitprice);
						Bl::Remove(playerid, FracID[idx]);

						format(string, sizeof(string), "[BLACK LIST] “ерпила %s, заплатил %i$ за выход из черного списка %s", plname, exitprice, FracInfo[FracID[idx]][fName]);
						sendToFamily(FracID[idx], COLOR_AZTECAS, string);
						format(string, sizeof(string), "[BLACK LIST] ¬ы вышли из черного списка(%s) за %i$", FracInfo[FracID[idx]][fName], exitprice);
						Send(playerid, COLOR_AZTECAS, string);
					}
				}
			} else {
				ShowFracBank(playerid);
			}
		}
		// —»—“≈ћј ‘–ј ÷»ќЌЌќ√ќ ЅјЌ ј. END

		// ѕќћќў№ ѕќ »√–≈
	case D_REF : {
			if(response) {
				switch(listitem) {
				case 0 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: ”ровень игрока.", "dialog/ref/level.txt", "ENTER", "");
				case 1 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: „аты.", "dialog/ref/chat.txt", "ENTER", "");
				case 2 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: Ћицензии.", "dialog/ref/licenzes.txt", "ENTER", "");
				case 3 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: –аботы.", "dialog/ref/jobs.txt", "ENTER", "");
				case 4 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: “ранспорт.", "dialog/ref/vehicle.txt", "ENTER", "");
				case 5 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: ƒом.", "dialog/ref/home.txt", "ENTER", "");
				case 6 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: Ѕизнес.", "dialog/ref/biznes.txt", "ENTER", "");
				case 7 : ShowDialog(playerid, D_REF+1, DIALOG_STYLE_MSGBOX, "{33CCFF}—правка: Ѕанк.", "dialog/ref/bank.txt", "ENTER", "");
				}
			}
		}

	case D_REF+1 : {
			ShowDialog(playerid, D_REF, DIALOG_STYLE_LIST, "{33CCFF}—правка.", "dialog/ref/main.txt", "SELECT", "CANCEL");
		}
		// ѕќћќў№ ѕќ »√–≈. END

	case D_HELP : {
			if(response) {
				dialog[0] = '\0';
				new tittle[50], category[50], fracid = Pl::FracID(playerid);
				switch(listitem) {
				case 0 : {
						strmid(category, " лиентские команды", 0, 50);
						LoadFile("dialog/help/client_cmd.txt", dialog);
					}
				case 1 : {
						strmid(category, "јккаунт", 0, 50);
						LoadFile("dialog/help/account.txt", dialog);
					}
				case 2 : {
						strmid(category, "ќбщее", 0, 50);
						LoadFile("dialog/help/common.txt", dialog);
					}

				case 3 : {
						strmid(category, "‘ракци€", 0, 50);
						if(fracid) {
							if(IsAGang(playerid) || IsAMafia(playerid))
							{
								strcat(dialog, "{FFFF00}/bl - {FFFFFF}черный список\n");
								strcat(dialog, "{FFFF00}/gag - {FFFFFF}надеть кл€п\n");
								strcat(dialog, "{FFFF00}/ungag - {FFFFFF}сн€ть кл€п\n");
								strcat(dialog, "{FFFF00}/steal - {FFFFFF}ограбить\n");
							}
							if(IsACop(playerid)) {
								strcat(dialog, "{FFFF00}/arrest - {FFFFFF}арестовать игрока\n");
								strcat(dialog, "{FFFF00}/color - {FFFFFF}одеть кепку\n");
								strcat(dialog, "{FFFF00}/ticket - {FFFFFF}выисать штраф игроку\n");
								strcat(dialog, "{FFFF00}/su - {FFFFFF}дать розыск игроку\n");
								strcat(dialog, "{FFFF00}/clear - {FFFFFF}очистить розыск игроку\n");
								strcat(dialog, "{FFFF00}/wanted - {FFFFFF}список розыскиваемых\n");
								strcat(dialog, "{FFFF00}/cuff - {FFFFFF}надеть игроку наручники\n");
								strcat(dialog, "{FFFF00}/uncuff - {FFFFFF}сн€ть игроку наручники\n");
								strcat(dialog, "{FFFF00}/tazer - {FFFFFF}ударить игрока электрошокером\n");
								strcat(dialog, "{FFFF00}/frisk - {FFFFFF}обыскать игрока\n");
								strcat(dialog, "{FFFF00}/mdc - {FFFFFF}посмотреть причину, по которой игроку был дан розыск\n");
								strcat(dialog, "{FFFF00}/take - {FFFFFF}отобрать что-то у игрока\n");
							}

							switch(fracid) {
							case 1 : strcat(dialog, "{FFFF00}/duty - {FFFFFF}заступить на дежурство\n");
							case 4 : {
									strcat(dialog, "{FFFF00}/duty - {FFFFFF}заступить на дежурство\n");
									strcat(dialog, "{FFFF00}/heal - {FFFFFF}вылечить игрока\n");
									strcat(dialog, "{FFFF00}/accept medic - {FFFFFF}прин€ть вызов\n");
								}
							case 8 : strcat(dialog, "{FFFF00}/loadmac - {FFFFFF}провеить, сколько мака в амбаре\n");
							case 9 : {
									strcat(dialog, "{FFFF00}/news - {FFFFFF}послать новости в эфир\n");
									strcat(dialog, "{FFFF00}/live - {FFFFFF}начать интервью\n");
								}
							case 10 : strcat(dialog, "{FFFF00}/fare - {FFFFFF}установить таксу\n");
							case 11 : {
									strcat(dialog, "{FFFF00}/startlesson - {FFFFFF}начать экзамен\n");
									strcat(dialog, "{FFFF00}/stoplesson - {FFFFFF}завершить экзамен\n");
									strcat(dialog, "{FFFF00}/givelicense - {FFFFFF}выдать лицензию игроку\n");
									strcat(dialog, "{FFFF00}/take - {FFFFFF}отобрать что-то у игрока\n");
								}
							case 17 : {
									strcat(dialog, "{FFFF00}/buymats - {FFFFFF}купить материалы в доках Ћ—\n");
									strcat(dialog, "{FFFF00}/sellmats - {FFFFFF}продать материалы на базе\n");
									strcat(dialog, "{FFFF00}/loadmats - {FFFFFF}посмотреть, на сколько загружен склад\n");
								}
							}
							if(IsAMafia(playerid)) {
								strcat(dialog, "{FFFF00}/selldrugs - {FFFFFF}продать наркоту\n");
								strcat(dialog, "{FFFF00}/sellgun - {FFFFFF}продать оружие\n");
							}
							if(IsAGang(playerid)) strcat(dialog, "{FFFF00}/zahvat - {FFFFFF}атаковать бизнес\n");
							strcat(dialog, "{FFFF00}/color - {FFFFFF}активировать цвет\n");
						}
						else strcat(dialog, "¬ам это меню не доступно!");
					}
				case 4:
					{
						strmid(category, "–абота", 0, 50);
						switch(Pl::Info[playerid][pJob])
						{
						case 1: strcat(dialog, "{FFFF00}/find - {FFFFFF}найти игрока\n");
						case 2: strcat(dialog, "{FFFF00}/free - {FFFFFF}выпустить игрока из тюрьмы\n");
						case 3: strcat(dialog, "{FFFF00}/sex - {FFFFFF}предложить зан€тьс€ сексом\n");
						case 4: strcat(dialog, "{FFFF00}/selldrugs - {FFFFFF}продать наркотики игроку\n");
						case 5: {
								strcat(dialog, "{FFFF00}/jack - {FFFFFF}взломать замок автомобил€\n");
								strcat(dialog, "{FFFF00}/dropcar - {FFFFFF}экспортировать автомобиль\n");
							}
						case 6: {
								strcat(dialog, "{FFFF00}/at - {FFFFFF}прицепить прицеп\n");
								strcat(dialog, "{FFFF00}/dt - {FFFFFF}отцепить прицеп\n");
								strcat(dialog, "{FFFF00}/duty - {FFFFFF}заступить на дежурство\n");
								strcat(dialog, "{FFFF00}/repair - {FFFFFF}починить автомобиль\n");
								strcat(dialog, "{FFFF00}/refill - {FFFFFF}заправить автомобиль\n");
							}
						case 7: {
								strcat(dialog, "{FFFF00}/mats - {FFFFFF}купить/переработать материалы\n");
								strcat(dialog, "{FFFF00}/sellgun - {FFFFFF}продать оружие игроку\n");
							}
						case 8: strcat(dialog, "{FFFF00}/sellcar - {FFFFFF}продать авто игроку\n");
						case 9: strcat(dialog, "{FFFF00}/fare - {FFFFFF}установить цену проезда\n");
						case 10: strcat(dialog, "{FFFF00}/delivery - {FFFFFF}начать рэйс\n");
						default: strcat(dialog, "” ¬ас нет работы!");
						}
						if(Pl::Info[playerid][pJob] > 0) strcat(dialog, "{FFFF00}/quitjob - {FFFFFF}уволитьс€\n");
					}
				case 5:
					{
						strmid(category, "„аты", 0, 50);
						strcat(dialog, "{FFFF00}/w (/pm) - {FFFFFF}отправить личное сообщение игроку\n");
						strcat(dialog, "{FFFF00}/s - {FFFFFF}крикнуть\n");
						strcat(dialog, "{FFFF00}/b - {FFFFFF}OOC чат\n");
						if(IsAFamily(playerid)) strcat(dialog, "{FFFF00}/f - {FFFFFF}отправить сообщение в фракционный чат\n");
						if(IsATeam(playerid) || fracid == 11)
						{
							strcat(dialog, "{FFFF00}/d - {FFFFFF}отправить сообщение в чат департамента\n");
							strcat(dialog, "{FFFF00}/r - {FFFFFF}сказать по рации\n");
							strcat(dialog, "{FFFF00}/m - {FFFFFF}крикнуть по мегафону\n");
							strcat(dialog, "{FFFF00}/gov - {FFFFFF}отправить сообщение в городские новост\n");
						}
						strcat(dialog, "{FFFF00}/ad - {FFFFFF}подать объ€вление\n");
						strcat(dialog, "{FFFF00}/me - {FFFFFF}описать свое действие от 3-его лица\n");
						strcat(dialog, "{FFFF00}/do - {FFFFFF}описать действи€ вокруг себ€\n");
						strcat(dialog, "{FFFF00}/try - {FFFFFF}попытатьс€ что-то сделать\n");
						strcat(dialog, "{FFFF00}/togooc - {FFFFFF}вкл/выкл сообщени€ о входе/выходе игроков\n");
						strcat(dialog, "{FFFF00}/tognews - {FFFFFF}вкл/выкл показ новостей\n");
						strcat(dialog, "{FFFF00}/togfam - {FFFFFF}вкл/выкл семейный чат\n");
						strcat(dialog, "{FFFF00}/togwhisper - {FFFFFF}вкл/выкл личные сообщени€\n");
					}

				case 6 : {
						strmid(category, "“елефон", 0, 50);
						LoadFile("dialog/help/phone.txt", dialog);
					}

				case 7 : {
						strmid(category, "јренда авто", 0, 50);
						LoadFile("dialog/help/rent_car.txt", dialog);
					}

				case 8 : {
						strmid(category, "ƒом", 0, 50);
						LoadFile("dialog/help/home.txt", dialog);
					}

				case 9 : {
						strmid(category, "јренда дома", 0, 50);
						LoadFile("dialog/help/rent_home.txt", dialog);
					}

				case 10 : {
						strmid(category, "Ѕизнес", 0, 50);
						LoadFile("dialog/help/biznes.txt", dialog);
					}

				case 11:
					{
						strmid(category, "Ћ»ƒ≈– ј", 0, 50);
						if(IsPlayerLeader(playerid) > 0) {
							strcat(dialog, "{FFFF00}/lmenu - {FFFFFF}меню лидера\n");
							strcat(dialog, "{FFFF00}/invite - {FFFFFF}прин€ть игрока в свою фракцию\n");
							strcat(dialog, "{FFFF00}/uninvite - {FFFFFF}выгнать игрока из своей фракции\n");
							strcat(dialog, "{FFFF00}/giverank - {FFFFFF}установить ранг игроку\n");
							strcat(dialog, "{FFFF00}/fracpay - {FFFFFF}выдать зарплату\n");
							strcat(dialog, "{FFFF00}/givetwarn - {FFFFFF}дать выговор игроку\n");
							strcat(dialog, "{FFFF00}/untwarn - {FFFFFF}сн€ть выговор с игрока\n");
							if(fracid == 7) {
								strcat(dialog, "{FFFF00}/settax - {FFFFFF}установить налог\n");
								strcat(dialog, "{FFFF00}/givetax - {FFFFFF}выдать зарплпту законникам\n");
								strcat(dialog, "{FFFF00}/checktax - {FFFFFF}проверить казну\n");
							}
						} else {
							strcat(dialog, "¬ы не лидер!");
						}
					}
				case 12:
					{
						strmid(category, "’елперка", 0, 50);
						if(!IsPHelper(playerid, 1)) strcat(dialog, "¬ы не хелпер!");
						strcat(dialog, "{FFFF00}/hc - {FFFFFF}отправить текст в чат хелперов\n");
						strcat(dialog, "{FFFF00}/ans - {FFFFFF}ответить игроку\n");
						strcat(dialog, "{FFFF00}/hduty - {FFFFFF}заступить на дежурство\n");
						if(IsPHelper(playerid, 2)) strcat(dialog, "{FFFF00}/hmute - {FFFFFF}дать мут игроку\n");
						if(IsPHelper(playerid, 3)) strcat(dialog, "{FFFF00}/makehelper(1-3) - {FFFFFF}дать хелперку\n");
					}
				case 13:
					{
						if(!Pl::Info[playerid][pAdmin]) strcat(dialog, "¬ы не админ!");
						else
						{
							return ShowDialog(playerid, D_NONE, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ѕомощь >  оманды админов", "dialog/help/admin.txt", "CANCEL", "");
						}
					}
				case 14:
					{
						strmid(category, "÷вета", 0, 50);
						strcat(dialog, "{AA3333}/red\n");
						strcat(dialog, "{FFFFFF}/white\n");
						strcat(dialog, "{100080}/navy\n");
						strcat(dialog, "{F0F8FF}/aqua\n");
						strcat(dialog, "{FFE4C4}/bisque\n");
						strcat(dialog, "{7FFF00}/chartreuse\n");
						strcat(dialog, "{A52A2A}/brown\n");
						strcat(dialog, "{FF7F50}/coral\n");
						strcat(dialog, "{ADFF2F}/greenyellow\n");
						strcat(dialog, "{7CFC00}/lawngreen\n");
						strcat(dialog, "{32CD32}/limegreen\n");
						strcat(dialog, "{808000}/olive\n");
						strcat(dialog, "{FF66FF}/pink\n");
						strcat(dialog, "{10FF7F}/springgreen\n");
						strcat(dialog, "{9ACD32}/yellowgreen\n");
						strcat(dialog, "{8B008B}/mediummagenta\n");
						strcat(dialog, "{EFEFF7}/system\n");
						strcat(dialog, "{C2A2DA}/purple\n");
					}
				case 15:
					{
						strmid(category, "√отовка. –ыбалка", 0, 50);
                        strcat(dialog, "{FFFF00}/cook - {FFFFFF}приготовить пищу\n");
                        strcat(dialog, "{FFFF00}/eat - {FFFFFF}съесть приготовленную пищу\n");
                        strcat(dialog, "{FFFF00}/sell cooked - {FFFFFF}поделитьс€ приготовленной едой\n\n");
                        strcat(dialog, "{FFFF00}/fish - {FFFFFF}рыбачить\n");
                        strcat(dialog, "{FFFF00}/fishes - {FFFFFF}пойманна€ рыба\n");
                        strcat(dialog, "{FFFF00}/throwback - {FFFFFF}выпустить последнюю пойманную рыбу обратно в океан\n");
                        strcat(dialog, "{FFFF00}/throwbackall - {FFFFFF}выпустить всю пойманную рыбу обратно в океан\n");
                        strcat(dialog, "{FFFF00}/releasefish - {FFFFFF}выпустить определенную рыбу обатно в океан\n");
                        strcat(dialog, "{FFFF00}/sell fish - {FFFFFF}продать пойманную рыбу\n");
					}
				}
				format(tittle, sizeof(tittle), ""#__SERVER_PREFIX""#__SERVER_NAME_LC": ѕомощь > %s", category);
				SPD(playerid, D_HELP+33, 0, tittle, dialog, "BACK", "CANCEL");
			}
		}

	case D_HELP+33 : {
			ShowDialog(playerid, D_HELP, DIALOG_STYLE_LIST,""#__SERVER_PREFIX""#__SERVER_NAME_LC": ѕомощь", "dialog/help.txt", "SELECT", "CANCEL");
		}

	case D_ARMOUR: {
			if(response) {
				if(Rac::GetPlayerArmour(playerid) >= 100.0 && Rac::GetPlayerHealth(playerid) >= 100.0) return Send(playerid, COLOR_GRAD2, "* ¬ы уже в бронежилете!");
				Rac::SetPlayerHealth(playerid, 100.0);
				Rac::SetPlayerArmour(playerid, 100.0);
				Rac::GivePlayerMoney(playerid, -500);
			}
		}

	case D_FARE : {
			if(response) {
				new Veh = GetPlayerVehicleID(playerid);
				if(IsABusCar(Veh)) {
					SetPVarInt(playerid, "NextCP", 0);
					SetPVarInt(playerid, "RouteID", listitem);
					format(string, sizeof(string), "її %s - %s ЂЂ\n“ариф: $%i", BusRoute[listitem][0][stopName], BusRoute[listitem][BusRouteCount[listitem]-1][stopName], TransportValue[playerid]);
					AttachText[Veh] = Add3DText(string, COLOR_BUS_PRICE, 0.0, 3.5, 2.8, 20.0, INVALID_PLAYER_ID, Veh, 0, 0, 0, -1);
					format(string, sizeof(string), "¬ы начали маршрут %s - %s", BusRoute[listitem][0][stopName], BusRoute[listitem][BusRouteCount[listitem]-1][stopName]);
					Send(playerid, COLOR_TAXI_PRICE, string);
					Send(playerid,COLOR_LIGHTRED, "—ледуете к красному ма€чку на радаре.");
					checkpointb[playerid] = CreateDynamicRaceCP(
					2,
					BusRoute[listitem][0][stopX],
					BusRoute[listitem][0][stopY],
					BusRoute[listitem][0][stopZ],
					0, 0, 0, 4.0, 0, 0, playerid, 99999.0
					);
				}
			} else {
				BusDrivers --;
				TransportDuty[playerid] = 0;
				TransportValue[playerid] = 0;
			}
		}

	case D_SKILL : {
			if(response) {
				switch(listitem) {
				case 0: {
						new score = Pl::Info[playerid][pSkill][0];
						new level = GetSkillLevel(playerid, 0);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии детектив = %i.\n*ƒл€ повышени€ уровн€ необходимо найти ещЄ %i игроков!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии детектив = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 1: {
						new score = Pl::Info[playerid][pSkill][2];
						new level = GetSkillLevel(playerid, 2);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии адвокат = %i.\n*ƒл€ повышени€ уровн€ необходимо освободить ещЄ %i игроков!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии адвокат = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 2: {
						new score = Pl::Info[playerid][pSkill][1];
						new level = GetSkillLevel(playerid, 1);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии шлюха = %i.\n*ƒл€ повышени€ уровн€ необходимо обслужить ещЄ %i клиентов!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии шлюха = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 3: {
						new score = Pl::Info[playerid][pSkill][7];
						new level = GetSkillLevel(playerid, 7);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии наркодилер = %i.\n*ƒл€ повышени€ уровн€ необходимо совершить ещЄ %i сделок!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии наркодилер = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 4: {
						new score = Pl::Info[playerid][pSkill][4];
						new level = GetSkillLevel(playerid, 4);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии автоугонщик = %i.\n*ƒл€ повышени€ уровн€ необходимо продать ещЄ %i машин!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии автоугонщик = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 5:	{
						new score = Pl::Info[playerid][pSkill][6];
						new level = GetSkillLevel(playerid, 6);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии репортер = %i.\n*ƒл€ повышени€ уровн€ необходимо опубликовать ещЄ %i новостей в /news!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии репортер = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 6: {
						new score = Pl::Info[playerid][pSkill][3];
						new level = GetSkillLevel(playerid, 3);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии механик = %i.\n*ƒл€ повышени€ уровн€ необходимо починить/заправить ещЄ %i машин!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии механик = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}

				case 7: {
						new score = Pl::Info[playerid][pSkill][5];
						new level = GetSkillLevel(playerid, 5);
						if(level < 5) format(string,sizeof(string),"*¬аш уровень опыта по профессии автодилер = %i.\n*ƒл€ повышени€ уровн€ необходимо оформить ещЄ %i автомобилей!", level, 50 - score);
						else format(string,sizeof(string),"*¬аш уровень опыта по профессии автодилер = 5.");
						SPD(playerid, D_SKILL+1, DIALOG_STYLE_MSGBOX, "SKILL", string, "Ќј«јƒ", "«акрыть");
					}
				}
			}
		}

	case D_SKILL+1 : {
			if(response) {
				ShowDialog(playerid, D_SKILL, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": SKILL", "dialog/skill.txt", "¬ыбор","ќтмена");
			}
		}

	case D_SPAWN : {
			if(response) {
				Pl::Info[playerid][pOrigin] = listitem ? 2 : 1;
				Pl::SetSpawnInfo(playerid);
				format(string, sizeof string, "* ¬ы будите спавнитс€ в отеле %s.", listitem ? ("Ћас ¬ентураса") : ("Jefferson"));
				Send(playerid, COLOR_LIGHTBLUE, string);
			}
		}

	case D_SERVICE : {
			if(response) {
				switch(listitem) {
				case 0: {
						if(!TaxiDrivers) return Send(playerid, COLOR_GREY, "Ќет свободных таксистов!");
						if(TransportDuty[playerid] > 0) return Send(playerid, COLOR_GREY, "¬ы уже вызвали такси!");
						format(string, sizeof(string), "[¬џ«ќ¬]  лиент %s. —ообщение: %s  (( ¬ведите /accept taxi ))", GetName(playerid), inputtext);
						sendToFamily(TEAM_TAXI, COLOR_AZTECAS, string);
						Send(playerid, COLOR_LIGHTBLUE, "* ¬ы позвали “аксиста, ждите ответа.");
						TaxiCall = playerid;
					}

				case 1: {
						if(!Medics) return Send(playerid, COLOR_GREY, "Ќет свободных медиков!");
						if(Iter::Count(MedicCalls)) {
							if(Iter::Contains(MedicCalls, playerid)) {
								Send(playerid, COLOR_GREY, "* ¬ы уже вызвали медика!");
							}
						} else {
							format(string, sizeof(string), "[¬џ«ќ¬]  лиент %s. —ообщение: %s  ((¬ведите /accept medic))", GetName(playerid), inputtext);
							sendToFamily(TEAM_MEDIC, COLOR_AZTECAS, string);
							Send(playerid, COLOR_LIGHTBLUE, "* ¬ы позвали —анитара, ждите ответа.");
							Iter::Add(MedicCalls, playerid);
						}
					}

				case 2: {
						if(!Mechanics) return Send(playerid, COLOR_GREY, "Ќет свободных механиков!");
						if(Iter::Count(MechanicCalls)) {
							if(Iter::Contains(MechanicCalls, playerid)) {
								Send(playerid, COLOR_GREY, "* ¬ы уже вызвали механика!");
							}
						} else {
							format(string, sizeof(string), "[¬џ«ќ¬]  лиент %s. —ообщение: %s  (( ¬ведите /accept mechanic ))", GetName(playerid), inputtext);
							SendJobMessage(JOB_MECHANIC, COLOR_AZTECAS, string);
							Send(playerid, COLOR_LIGHTBLUE, "* ¬ы позвали јвтомобильного ћеханика, ждите ответа.");
							Iter::Add(MechanicCalls, playerid);
						}
					}
				}
			}
		}
	}

	return 1;
}

public: Gm::Thread() {
	static advTimer;
	if(++advTimer >= ADV_TIME) {
		advTimer = 0;
		SendToAll(COLOR_LIGHTGREEN,"Ќа сервере "#__SERVER_PREFIX""#__SERVER_NAME_LC" запрещено: ƒЅ, ƒћ, ‘луд, „иты, CLEO скрипты,  апс, –озжиг межрасовой розни");
		SendToAll(COLOR_LIGHTBLUE,"¬се интересующие вас вопросы, касающиес€ игры вы найдете на нашем форуме: "#__SERVER_SITE"");
		SendToAll(COLOR_DBLUE,"≈сли вас оскорбили, унизили, убили без причины, либо вы увидели читера или того, кто нарушает правила - то пишите /report [id] жалоба.");
	}

	static syncTimer;
	if(++syncTimer >= 60) {
		syncTimer = 0;
		new h, m, s;
		new currtime = gettime(h, m, s);
		FixHour(h);
		h = shifthour;

		format(temp, sizeof temp, "~w~%02i:%02i", h, m);
		Td::SetString(Time, temp);
		foreach(new i : Player) {
			if(Pl::isLogged(i)) {
				Td::ShowForPlayer(i, Time);
			}
		}

		if((h > ghour) || (h == 0 && ghour == 23)) {
			ghour = h;
			SetWorldTime(h);
			format(temp, sizeof(temp), "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": сейчас %d:00 часа(ов).", h);
			SendToAll(COLOR_WHITE, temp);
			//SetTimer("onPayDay", 555, false);
            onPayDay();

			format(query, sizeof query, "SELECT `ip` FROM `"#__TableBanned__"` WHERE `unbandate` <= '%i'", currtime);
			Db::tquery(connDb, query, "ClearBanList", "i", currtime);

			for(new i; i < MAX_FRAC; i++) FracPay[i] = 0;
		}
	}

	static gainsTime[2];
	if(++gainsTime[0] >= GAINS_TIME) {
		gainsTime[0] = 0;
		new cash, totalgains[MAX_FRAC];

		foreach(new i : Biznes) {
			if(BizzInfo[i][bOwned] == 1) {
				cash = floatround(PERCENT(BizzInfo[i][bProfit], 10));
				if(cash > 0) {
					BizzInfo[i][bSafe] -= cash;
					totalgains[BizzInfo[i][bFrac]] += cash;
				}
			}
		}

		for(new i; i < sizeof Gangs; i++) {
			GiveFracMoney(Gangs[i], totalgains[Gangs[i]]);
			foreach(new p : TeamPlayers[Gangs[i]]) {
				format(temp, sizeof(temp), "~r~%s~n~Gains ~g~$%i", GetGangName(Gangs[i]), totalgains[Gangs[i]]);
				GameTextForPlayer(p, temp, 5000, 1);
			}
		}

		if(++gainsTime[1] == 4) {
			gainsTime[1] = 0;
			foreach(new i : Biznes) {
				BizzInfo[i][bProfit] = 0;
			}
		}
	}

	foreach(new vehicleid : enginedVehicles) {
		new driver = GetVehicleDriver(vehicleid);
		if(driver != INVALID_PLAYER_ID) {
			if(!AFKInfo[driver][afk_State]) {
				new speed = Rac::GetPlayerSpeed(driver);
				if(speed > 0) {
					new Float:rate = (speed / 1.6 / 1609.344);
					AutoInfo[vehicleid][aFuel] -= (speed > 110) ? (rate + speed / 1609.344) : (rate);
					if(AutoInfo[vehicleid][aFuel] < 1.0) {
						AutoInfo[vehicleid][aFuel] = 0.0;
						switch(GetVehicleType(GetVehicleModel(vehicleid))) {
						case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
								isEngined{vehicleid} = false;
								GetVehicleParamsEx(vehicleid,engine,light,alarm,doors,bonnet,boot,objective);
								SetVehicleParamsEx(vehicleid,false,light,alarm,doors,bonnet,boot,objective);
							}
						}
						new next;
						Iter::SafeRemove(enginedVehicles, vehicleid, next);
						vehicleid = next;
					}
				} else {
					goto mark;
				}
			}
		} else {
mark:
			AutoInfo[vehicleid][aUpdate] ++;
			if(AutoInfo[vehicleid][aUpdate] >= 25) {
				AutoInfo[vehicleid][aFuel] -= 0.5;
				AutoInfo[vehicleid][aUpdate] = 0;
				if(AutoInfo[vehicleid][aFuel] < 1.0) {
					AutoInfo[vehicleid][aFuel] = 0.0;
					switch(GetVehicleType(GetVehicleModel(vehicleid))) {
					case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
							isEngined{vehicleid} = false;
							GetVehicleParamsEx(vehicleid,engine,light,alarm,doors,bonnet,boot,objective);
							SetVehicleParamsEx(vehicleid,false,light,alarm,doors,bonnet,boot,objective);
						}
					}
					new next;
					Iter::SafeRemove(enginedVehicles, vehicleid, next);
					vehicleid = next;
				}
			}
		}
	}

	foreach(new p : Player) {
	    if(Flood[p] > 0) Flood[p] -=1;
	    if(sFlood[p] > 0) sFlood[p] -=1;
	    if(timermc[p] > 0) timermc[p] -=1;
		if(Pl::Info[p][pWait] > 0) {
			if(--Pl::Info[p][pWait] == 0) {
				GetPlayerName(p, plname, 24);
				if((Pl::Info[p][pID] = GetIDFromName(plname)) != -1) {
					if(!CheckBan(p)) {
						ShowLoginForm(p, 1);
					} else {
						Kick(p);
					}
				} else {
					if(Gm::Info[Gm::EnableReg]) {
						if(regex_match_exid(plname, ValidRPName)) {
							ShowLoginForm(p, 2);
						} else {
							Send(p, COLOR_LIGHTRED, "¬аш ник не соответствует правилам нашего сервера");
							Send(p, COLOR_LIGHTBLUE, "»змените свой ник по типу: »м€_‘амили€. Ќапример: Ivan_Petrov");
							Kick(p);
						}
					} else {
						ShowDialog(p, D_NONE, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_C" REGISTRATION", "dialog/noregged.txt", "OK", "");
						Kick(p);
					}
				}
			}
		} else {
			if(Pl::isLogged(p)) {
				Update(p);
				UnJailPlayer(p);
				playerAFKUpdate(p);
				vehicleStatusUpdate(p);
				playerSpectateUpdate(p);
				PoppyCollection(p);
				OnPlayerPickupExit(p);
			}
		}
	}
}

stock vehicleStatusUpdate(playerid) {
	//static Float:x, Float:y, Float:z;
	static model, vehicle, speed;
	static Float:health, string[255];
	if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER) {
		vehicle = GetPlayerVehicleID(playerid);
		model = GetVehicleModel(vehicle);
		switch(GetVehicleType(model)) {
		case VEHICLE_TYPE_UNKNOWN : {
			}

		case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
				if(isEngined{vehicle}) {
					GetVehicleHealth(vehicle, health);
					if(health < 450 || AutoInfo[vehicle][aFuel] < 1.0) {
						ToggleVehicleEngine(vehicle, 0);
						format(string, sizeof string, "* ƒвигатель заглох");
						ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
						GameTextForPlayer(playerid, (health<450)?("~n~~n~~n~~n~~n~~n~~w~CЗOMAHO"):("~n~~n~~n~~n~~n~~n~~w~HET АEHИЕHA"), 7000, 5);
					}
				}

				speed = Rac::GetPlayerSpeed(playerid, false);
				if(!AFKInfo[playerid][afk_State] && speed > 0) {
					AutoInfo[vehicle][aMileage] += speed / 1.6 / 1609.344;
				}
				format(string, sizeof string, "~w~VEHICLE: ~g~%s [id: %i]      %.1f (miles)", VehicleNames[model-400], model, AutoInfo[vehicle][aMileage]);
				if(model == 482 && isTeamVehicle(TEAM_RIFA, vehicle)) {
					scf(string, temp, "      MATS: ~r~%i/%i", AutoInfo[vehicle][aMats], AutoInfo[vehicle][aMaxMats]);
				} else if(IsACompTruck(vehicle)) {
					scf(string, temp, "      PRODS: ~r~%i/%i", PlayerHaul[vehicle-comptruck[0]][pLoad], PlayerHaul[vehicle-comptruck[0]][pCapasity]);
				} else if(isTeamVehicle(TEAM_FARMERS, vehicle)) {
					scf(string, temp, "      MAK: ~r~%i/%i", AutoInfo[vehicle][aDrugs], AutoInfo[vehicle][aMaxDrugs]);
				}
				updateBenzinTD(playerid, vehicle);
			}

			default : {
				format(string, sizeof string,"~w~VEHICLE: ~g~%s [id: %i]", VehicleNames[model-400], model, AutoInfo[vehicle][aMileage]);
			}
		}
		Pt::SetString(playerid, Pt::Name[playerid], string);
		Pt::SetString(playerid, Pt::Status[playerid], (gCarLock{vehicle})?("~r~Lock"):("~w~Lock"));
	}
	return 1;
}

stock PoppyCollection(i) {
	if(Pl::FracID(i) == TEAM_FARMERS) {
		if(IsPlayerInDynamicArea(i, Area::poppyField)) {
			new vehid = GetPlayerVehicleID(i);
			if(vehid && GetVehicleModel(vehid) == 532) {
				if(Rac::GetPlayerSpeed(i) > 0) {
					if(AutoInfo[vehid][aDrugs] != AutoInfo[vehid][aMaxDrugs]) {
						AutoInfo[vehid][aDrugs] ++;
					}
				}
			}
		}
	}
}

stock UnJailPlayer(i) {
	if(Pl::Info[i][pJailed] > 0 && AFKInfo[i][afk_Time][0] < AFK_TEXT_SET) {
		if(Pl::Info[i][pJailTime] != 0) {
			Pl::Info[i][pJailTime]--;
			if(Pl::Info[i][pJailTime] <= 0) {
				Pl::SetFracColor(i);
				ClearCrime(i);
				UnJail(i, Pl::Info[i][pJailed]);
				Send(i, COLOR_GRAD1,"* ¬ы заплатили свой долг обществу.");
				format(temp, sizeof(temp), "~g~Freedom~n~~w~Try to be a better citizen");
				GameTextForPlayer(i, temp, 5000, 1);
			}
		}
	}

	if(WantLawyer[i] >= 1) {
		CallLawyer[i] = 111;
		switch(WantLawyer[i]++) {
		case 1, 8, 15 : Send(i, COLOR_LIGHTRED, "¬ы хотите јдвоката? (пишите yes (если нужен) или no (если не нужен) )");
		case 20 : {
				Send(i, COLOR_LIGHTRED, "јдвоката нету. “юремное заключение началось.");
				WantLawyer[i] = 0;
				CallLawyer[i] = 0;
			}
		}
	}
}

#if defined __rac_included
public onPlayerKick(playerid, reason[], reasonid) {
	GetPlayerName(playerid, plname, 24);
	format(temp, sizeof temp, "[античит] * %s[%i] был кикнут, причина: %s || AC%s", plname, playerid, reason, reasonid == R_NONE ? ("#0000") : R::Info[reasonid]);
	foreach(new i : AdminPlayers) {
		if(playerid != i) {
			if(Pl::isAdmin(i, 1)) {
				Send(i, COLOR_LIGHTRED, temp);
			}
		}
	}
	SendLog(LOG_ANTICHEAT, temp);

	return 1;
}

public onPlayerBan(playerid, reason[], reasonid) {
	GetPlayerName(playerid, plname, 24);
	format(temp, sizeof temp, "[античит] * %s[%i] был забанен, причина: %s || AC%s", plname, playerid, reason, reasonid == R_NONE ? ("#0000") : R::Info[reasonid]);
	foreach(new i : AdminPlayers) {
		if(playerid != i) {
			if(Pl::isAdmin(i, 1)) {
				Send(i, COLOR_LIGHTRED, temp);
			}
		}
	}
	SendLog(LOG_ANTICHEAT, temp);

	return 1;
}
#endif


public OnPlayerTakeDamage(playerid, issuerid, Float:amount, weaponid, bodypart) {
	GMTest{playerid} = false;
}

public OnPlayerGiveDamage(playerid, damagedid, Float:amount, weaponid, bodypart)
{
	if(InAntiDmZone{playerid})
	{
		AnimClear[playerid] = 4;
		ApplyAnimation(playerid, "FAT","IDLE_tired", 4.1, 1, 1, 1, 1, 0);
		if(Rac::IsPlayerControllable(playerid)) { SetTimerEx(""#Rac::"TogglePlayerControllable", 7000, false, "ii", playerid, 1);}
	}
	else SetPlayerDamage(playerid, damagedid, amount, weaponid);
	/*{
		static olddamage[MAX_PLAYERS];
		new currdamage = GetTickCount();
		if((currdamage - olddamage[playerid]) >= 900) {
			olddamage[playerid] = currdamage;

			switch(weaponid) {
			case 33, 34 : {
					if(bodypart == BODY_PART_HEAD) {
						SetPlayerDamage(playerid, damagedid, Float:INFINITY, weaponid);
					}
				}
				default : {
					SetPlayerDamage(playerid, damagedid, amount, weaponid);
				}
			}
		}
	}*/
}

stock SetPlayerDamage(playerid, damagedid, Float:damage, reason) {
	new Float:health, Float:armour;
	GetPlayerHealth(damagedid, health);
	GetPlayerArmour(damagedid, armour);
	if(armour > 0)
	{
		armour -= damage;
		if(armour < 1)
		{
			health -= damage;
			if(health < 1)
			{
				SyncInfo[damagedid][sKillerID] = playerid;
				SyncInfo[damagedid][sReasonID] = reason;
			}
		}
		Rac::SetPlayerArmour(damagedid, armour);
		Rac::SetPlayerHealth(damagedid, health);
	}
	else if(health > 0)
	{
	    armour = 0;
		health -= damage;
		if(health < 1)
		{
			SyncInfo[damagedid][sKillerID] = playerid;
			SyncInfo[damagedid][sReasonID] = reason;
		}
		Rac::SetPlayerArmour(damagedid, armour);
		Rac::SetPlayerHealth(damagedid, health);
	}
	return 1;
}

public OnPlayerUpdate(playerid) {
	static string[125];
	AFKInfo[playerid][afk_Time][0] = 0;
	if(AFKInfo[playerid][afk_State] != 0) {
		AFKInfo[playerid][afk_State] = 0;
		Delete3DTextLabel(AFKInfo[playerid][afk_Text]);
		CallLocalFunction("OnPlayerAFK", "iii", playerid, 0, 1);
	}

	switch(Rac::GetPlayerState(playerid)) {
	case PLAYER_STATE_DRIVER : {
			new vehicle = GetPlayerVehicleID(playerid);
			new speed = Rac::GetPlayerSpeed(playerid, false);
			if(speed > AutoInfo[vehicle][aLimit]) {
				Rac::SetVehicleSpeed(vehicle, AutoInfo[vehicle][aLimit]);
				speed = AutoInfo[vehicle][aLimit];
			}
			format(string, sizeof string, "%03i km'h", speed);
			Pt::SetString(playerid, Pt::Speed[playerid][2], string);
			UpdateSpeedometer(playerid, speed);
		}
	}

	return 1;
}

public OnPlayerStreamIn(playerid, forplayerid) {
	if(Rac::IsValidState(forplayerid) && Rac::IsValidState(playerid)) {
		new fracid = Pl::FracID(forplayerid);
		if(Bl::Info[playerid][Bl::onFrac][fracid] && Bl::Info[forplayerid][Bl::Observe] == INVALID_PLAYER_ID) {
			if(Bl::Info[playerid][Bl::Finder] == INVALID_PLAYER_ID) {
				Bl::Info[playerid][Bl::Finder] = forplayerid;
				Bl::Info[forplayerid][Bl::Observe] = playerid;
				GetPlayerPos(playerid, posx, posy, posz);
				switch(GetPlayerState(playerid)) {
				case PLAYER_STATE_ONFOOT : {
						Bl::Info[forplayerid][Bl::Marker] = CreateDynamicCP(posx, posy, posz, 1.6, -1, -1, forplayerid, 200.0);
					}
				case PLAYER_STATE_DRIVER, PLAYER_STATE_PASSENGER : {
						new vehid = GetPlayerVehicleID(playerid);
						GetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, objective);
						SetVehicleParamsEx(vehid, engine, light, alarm, doors, bonnet, boot, true);
					}
				}
				getname(playerid -> plname, forplayerid -> temp);
				format(src, sizeof(src), "[BLACK LIST] ¬ы были замечены, %s %s [%s]", RankInfo[fracid][Pl::Info[forplayerid][pRank]], temp, FracInfo[fracid][fName]);
				Send(playerid, COLOR_AZTECAS, src);
				format(src, sizeof(src), "[BLACK LIST] ѕо€вилс€ запашок черта, %s %s заметил %s", RankInfo[fracid][Pl::Info[forplayerid][pRank]], temp, plname);
				sendToFamily(fracid, COLOR_AZTECAS, src);
			} else {
				GetPlayerPos(playerid, posx, posy, posz);
				Bl::Info[forplayerid][Bl::Observe] = playerid;
				switch(GetPlayerState(playerid)) {
				case PLAYER_STATE_ONFOOT : {
						Bl::Info[forplayerid][Bl::Marker] = CreateDynamicCP(posx, posy, posz, 1.6, -1, -1, forplayerid, 200.0);
					}
				}
			}
		}
	}

	ShowPlayerNameTagForPlayer(forplayerid, playerid, !Pl::Info[playerid][pMaskOn]);
	Iter::Add(inStreamPlayers[forplayerid], playerid);
}

public OnPlayerStreamOut(playerid, forplayerid) {
	if(Rac::IsValidState(forplayerid) && Bl::ValidState(playerid)) {
		new fracid = Pl::FracID(forplayerid);
		if(Bl::Info[playerid][Bl::onFrac][fracid]) {
			if(!Bl::Info[playerid][Bl::isKilled]) {
				if(Bl::Info[playerid][Bl::Finder] == forplayerid) {
					Bl::Info[playerid][Bl::Finder] = INVALID_PLAYER_ID;
					GetPlayerName(playerid, plname, 24);
					Send(playerid, COLOR_AZTECAS, "[BLACK LIST] ¬ам удалось скрытс€!");
					format(temp, sizeof temp, "[BLACK LIST] —лед был упущен, %s скрылс€", plname);
					sendToFamily(fracid, COLOR_AZTECAS, temp);
				}
			} else {
				Bl::Info[playerid][Bl::isKilled] = false;
			}
		}
	}

	Iter::Remove(inStreamPlayers[forplayerid], playerid);
}

public: AddsOn() adds = true;
public: onUsePlusC(playerid) usePlusC{playerid} = false;
public: onUseBannyHop(playerid) useBannyHop{playerid} = false;

public OnPlayerKeyStateChange(playerid, newkeys, oldkeys) {
	#define wait(%0); if(!Wait{%0}){Wait{%0} = 1;}else{return 1;}

    if(newkeys == KEY_CROUCH)
	{
		if(IsACop(playerid))
	    {
	        if(IsPlayerInRangeOfPoint(playerid,4, -1539.3969,509.4250,7.1797) || IsPlayerInRangeOfPoint(playerid,4, -1550.5029,510.5477,7.0659))
			{
				MoveObject(armygate[0],-1545.10, 506.38, 6.94+0.004, 0.004,0.00, 0.00, 84.00);
				SetTimer("Armygate", 8000, 0);
				Send(playerid, 0x6495EDFF, "Ўлагбаум отпуститьс€ через 8 секунд");
			}
	        else if(IsPlayerInRangeOfPoint(playerid,4, -1538.4352,518.3437,7.1797) || IsPlayerInRangeOfPoint(playerid,4, -1546.7241,519.1129,7.1797))
			{
				MoveObject(armygate[1],-1543.65, 515.57, 6.94+0.004, 0.004,0.00, 0.00, 84.00);
				SetTimer("Armygate2", 8000, 0);
				Send(playerid, 0x6495EDFF, "Ўлагбаум отпуститьс€ через 8 секунд");
			}
		}
	}
    if(newkeys == KEY_CROUCH)
	{
	    if(Pl::FracID(playerid) == 11 || TakingLesson[playerid] == true)
	    {
	        if(IsPlayerInRangeOfPoint(playerid,8, -2046.9283,-80.4663,35.1641))
			{
				MoveObject(licgate,-2050.3899, -80.0900, 35.0000+0.004, 0.004,0.0000, 0.0000, 0.0000);
				SetTimer("LicClose", 8000, 0);
				Send(playerid, 0x6495EDFF, "Ўлагбаум отпуститьс€ через 8 секунд");
			}
		}
	}
	if((newkeys & KEY_FIRE) || (newkeys & KEY_JUMP) || (newkeys & KEY_SECONDARY_ATTACK) || (newkeys & KEY_SUBMISSION)) {
		if(KG[playerid][0]) {
			KG[playerid][0] = 0;
			Send(playerid, COLOR_BLUE, "* ¬ы уронили мешок");
			if(IsPlayerAttachedObjectSlotUsed(playerid,1)) {
				RemovePlayerAttachedObject(playerid,1);
			}
		}
	}

	//if(((oldkeys & KEY_FIRE)||(oldkeys == KEY_FIRE))&&((newkeys & KEY_CROUCH)||(newkeys == KEY_CROUCH))) {
	/*if((newkeys & KEY_FIRE) && (oldkeys & KEY_CROUCH) && !((oldkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) || (oldkeys & KEY_FIRE) && (newkeys & KEY_CROUCH) && !((newkeys & KEY_FIRE) || (newkeys & KEY_HANDBRAKE)) ) {
		if(!usePlusC{playerid}) {
			switch(GetPlayerWeapon(playerid)) {
				case 24, 25, 27, 29, 30, 31, 33, 34 : {
					usePlusC{playerid} = true;
					SetPlayerArmedWeapon(playerid, 0);
					SlapPlayer(playerid, 0.88);
					SetTimerEx("onUsePlusC", 1000, false, "i", playerid);
					GameTextForPlayer(playerid, "~n~~n~~n~~w~NO ~g~C-BUG", 5000, 4);
				}
			}
		} else {
			SetPlayerArmedWeapon(playerid, 0);
		}
		return 1;
	}*/

	if(!useBannyHop{playerid}) {
		if(PRESSED(KEY_SPRINT|KEY_JUMP)) {
			if(GetPlayerVehicleID(playerid) == 0) {
				useBannyHop{playerid} = true;
				SetTimerEx("onUseBannyHop", 1000, false, "i", playerid);
				ApplyAnimation(playerid, "PED", "GETUP_FRONT", 4.0, 0, 1, 1, 0, 0);
			}
			return 1;
		}
	}

	if((newkeys & KEY_JUMP) && !(oldkeys & KEY_JUMP)) {
		if(GetPlayerSpecialAction(playerid) == SPECIAL_ACTION_CUFFED) {
			return ApplyAnimation(playerid, "GYMNASIUM", "gym_jog_falloff",4.1,0,1,1,0,0);
		}
	}


	if(PRESSED(KEY_CROUCH)) {
		wait(playerid);

		switch(GetPlayerState(playerid)) {
		case PLAYER_STATE_DRIVER : {
				new veh = GetPlayerVehicleID(playerid);
				if(IsPlayerInHouseGarage(playerid)) {
					new Float:x, Float:y;
					new local = Pl::Info[playerid][pLocal] - OFFSET_HOUSE;
					Pl::Info[playerid][pLocal] = 0;
					GetXYInFrontOfPoint(x, y, HouseInfo[local][hgStreetPos][3], vehicleSize(veh));
					Rac::SetVehiclePos(veh, HouseInfo[local][hgStreetPos][0] + x, HouseInfo[local][hgStreetPos][1] + y, HouseInfo[local][hgStreetPos][2]);
					SetVehicleZAngle(veh, HouseInfo[local][hgStreetPos][3]);
					LinkVehicleToInterior(veh, 0);
					SetVehicleVirtualWorld(veh, 0);
					Rac::SetPlayerInterior(playerid, 0);
					Rac::SetPlayerVirtualWorld(playerid, 0);
					SetCameraBehindPlayer(playerid);

					foreach(new i : vehiclePassengers[veh]) {
						if(GetPlayerState(i) == PLAYER_STATE_PASSENGER) {
							Rac::SetPlayerInterior(i, 0);
							Rac::SetPlayerVirtualWorld(i, 0);
							SetCameraBehindPlayer(i);
						}
					}
				} else {
					foreach(new i : Houses) {
						if(IsPlayerInRangeOfPoint(playerid, 10.0, HouseInfo[i][hgStreetPos][0], HouseInfo[i][hgStreetPos][1], HouseInfo[i][hgStreetPos][2])) {
							if(Pl::Info[playerid][pHouseKey] != HouseInfo[i][hID]) return Send(playerid, COLOR_GREY, "* ” ¬ас нет ключей!");
							Pl::Info[playerid][pLocal] = OFFSET_HOUSE + i;
							Rac::SetVehiclePos(veh, 616.0352, -124.1155, 997.7648);
							SetVehicleZAngle(veh, 90.1765);
							LinkVehicleToInterior(veh, 3);
							SetVehicleVirtualWorld(veh, HouseInfo[i][hVirtual]);
							Rac::SetPlayerInterior(playerid, 3);
							Rac::SetPlayerVirtualWorld(playerid, HouseInfo[i][hVirtual]);
							SetCameraBehindPlayer(playerid);

							foreach(new j : vehiclePassengers[veh]) {
								if(GetPlayerState(j) == PLAYER_STATE_PASSENGER) {
									Rac::SetPlayerInterior(j, 3);
									Rac::SetPlayerVirtualWorld(j, HouseInfo[i][hVirtual]);
									SetCameraBehindPlayer(j);
								}
							}
							return 1;
						}
					}
				}
			}
		}
		return 1;
	}

	if(PRESSED(KEY_AIM) && GetPlayerWeapon(playerid) == 0) {
		wait(playerid);

		switch(Rac::GetPlayerState(playerid)) {
		case PLAYER_STATE_ONFOOT : {
				new c = ClosestVeh(playerid, 5.1);
				if(c != INVALID_VEHICLE_ID) {
					GetCoordVehicleParams(c, 3, vehx, vehy, vehz);
					if(IsPlayerInRangeOfPoint(playerid, 1.5, vehx, vehy, vehz)) {
						VehicleBoot{c} = !VehicleBoot{c};
						GetVehicleParamsEx(c,engine,light,alarm,doors,bonnet,boot,objective);
						SetVehicleParamsEx(c,engine,light,alarm,doors,bonnet,VehicleBoot{c},objective);
					} else {
						GetCoordVehicleParams(c, 2, vehx, vehy, vehz);
						if(IsPlayerInRangeOfPoint(playerid, 1.4, vehx, vehy, vehz)) {
							VehicleBonnet{c} = !VehicleBonnet{c};
							GetVehicleParamsEx(c,engine,light,alarm,doors,bonnet,boot,objective);
							SetVehicleParamsEx(c,engine,light,alarm,doors,VehicleBonnet{c},boot,objective);
						}
					}
					if(Pl::Info[playerid][pJob] == 6) {
						switch(GetVehicleType(GetVehicleModel(c))) {
						case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
								if(JobWaitTime[playerid] != 0) return Send(playerid, COLOR_GREY, "* Ќевозможно чинить/заправл€ть слишком часто, качайте скилл!");

								new Float:fuel, found;
								if(!IsAMehCar(c)) {
									foreach(new i : JobVehicles[JOB_MECHANIC]) {
										if(IsVehicleClosestForPlayer(playerid, i, 20.0)) {
											found=1;
											Pl::Info[playerid][pSkill][3] ++;
											switch(Pl::Info[playerid][pSkill][3]) {
											case 50 : Send(playerid, COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 2, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
											case 100 : Send(playerid, COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 3, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
											case 200 : Send(playerid, COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 4, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
											case 400 : Send(playerid, COLOR_YELLOW, "* ¬аш јвтомобильный Ќавык ћеханика - теперь ”ровень 5, ¬ы можете добавить больше “оплива к любым јвтомобил€м »гроков.");
											}
											break;
										}
									}
								} else {
									found=1;
								}
								if(found) {
									switch(Pl::Info[playerid][pSkill][3]) {
									case 0..50		: fuel = 15.0, JobWaitTime[playerid] = 120;
									case 51..100	: fuel = 25.0, JobWaitTime[playerid] = 80;
									case 101..200	: fuel = 35.0, JobWaitTime[playerid] = 60;
									case 201..300 	: fuel = 45.0, JobWaitTime[playerid] = 40;
									case 301..400 	: fuel = 55.0, JobWaitTime[playerid] = 30;
									case 401..501 	: fuel = 65.0, JobWaitTime[playerid] = 20;
										default 		: fuel = 65.0, JobWaitTime[playerid] = 20;
									}

									found=0;
									foreach(new p: vehiclePassengers[c]) {
										if(GetPlayerState(p) == 2) {
											found++;
											format(temp, sizeof temp, "ћеханик %s починил и заправил машину %s", GetName(playerid), GetName(p));
											break;
										}
									}

									if(AutoInfo[c][aFuel] < 100.0) AutoInfo[c][aFuel] += fuel;
									Rac::RepairVehicle(c);
									if(!found) format(temp, sizeof temp, "јвтомеханик %s починил и заправил машину", GetName(playerid));
									ProxDetector(15.0, playerid, temp, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
								} else {
									Send(playerid, COLOR_GREY, "* –€дом с вами нет машины механика!");
								}
							}
						}
					}
				}
			}
		}
		return 1;
	}

	if(PRESSED(KEY_FIRE)) {
		wait(playerid);

		switch(Rac::GetPlayerState(playerid)) {
		case PLAYER_STATE_ONFOOT : {
				if(Pl::CuffedTime[playerid] > 0) {
					AnimClear[playerid] = 4;
					ApplyAnimation(playerid, "FAT","IDLE_tired", 4.1, 1, 1, 1, 1, 0);
					if(Rac::IsPlayerControllable(playerid)) {
						SetTimerEx(""#Rac::"TogglePlayerControllable", 7000, false, "ii", playerid, 1);
					}
				}
			}
		case PLAYER_STATE_DRIVER : {
				new vehid = GetPlayerVehicleID(playerid);
				switch(GetVehicleType(GetVehicleModel(vehid))) {
				case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
						if(AutoInfo[vehid][aFuel] < 1.0) {
							Send(playerid,COLOR_WHITE,"* ¬ызовите механика, нет топлива! (/service)");
							format(src, sizeof(src), "* %s попыталс€ завести двигатель (неудачно)", GetName(playerid));
							ProxDetector(20.0, playerid, src, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
							GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~w~HET АEHИЕHA", 5000, 5);
						} else if(Rac::GetVehicleHealth(vehid) < 450) {
							Send(playerid,COLOR_WHITE,"* ¬ызовите механика, машина повреждена! (/service)");
							format(src, sizeof(src), "* %s попыталс€ завести двигатель (неудачно)", GetName(playerid));
							ProxDetector(20.0, playerid, src, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
							GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~w~CЗOMAHO", 7000, 5);
						} else {
							ToggleVehicleEngine(vehid, !isEngined{vehid});
							SetPlayerChatBubble(playerid, isEngined{vehid} ? ("завел двигатель") : ("заглушил двигатель"), COLOR_YELLOW, 30.0, 5000);
							GameTextForPlayer(playerid, isEngined{vehid} ? ("~w~ENGINE ~g~ON") : ("~w~ENGINE ~R~OFF"), 5000, 6);
						}
					}
				}
			}
		}
		return 1;
	}

	if(PRESSED(KEY_ACTION)) {
		wait(playerid);

		switch(GetPlayerState(playerid)) {
		case PLAYER_STATE_DRIVER : {
				new veh = GetPlayerVehicleID(playerid);
				switch(GetVehicleType(GetVehicleModel(veh))) {
				case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
						VehicleLight{veh} = !VehicleLight{veh};
						GameTextForPlayer(playerid, VehicleLight{veh} ? ("~w~LIGHT ~g~ON") : ("~w~LIGHT ~R~OFF"), 5000, 6);
						SetPlayerChatBubble(playerid, VehicleLight{veh} ? ("включил фары") : ("выключил фары"), COLOR_YELLOW, 30.0, 5000);
						GetVehicleParamsEx(veh,engine,light,alarm,doors,bonnet,boot,objective);
						SetVehicleParamsEx(veh,engine,VehicleLight{veh},alarm,doors,bonnet,boot,objective);
					}
				}
			}
		}
		return 1;
	}

	if(PRESSED(KEY_YES)) {
		wait(playerid);

		switch(GetPlayerState(playerid)) {
		case PLAYER_STATE_ONFOOT : {
				for(new i = 19, fracid = Pl::FracID(playerid); i < FracGateCount; i++) {
					if(IsPlayerInRangeOfGate(playerid, 2.0, FracGate[i][GateID])) {
						if(GET_GATE_ACCESS(i, fracid) == true) {
							if(GateOpen(FracGate[i][GateID])) {
								SetTimerEx("GateClose", 5000, false, "i", FracGate[i][GateID]);
								Send(playerid, 0x15AAEAAA, "* ƒверь открыта, проходите!");
							}
						}
						return 1;
					}
				}
			}
		}
	}
	if(PRESSED(KEY_LOOK_BEHIND))
	{
		wait(playerid);
		new string[144], sendername[24], playername[24], tazered;
		if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не законник!");
		if(IsPlayerInAnyVehicle(playerid)) return Send(playerid, COLOR_GREY, "* Ќельз€ использовать это в автомобиле!");
		if(PlayerUseTazed[playerid]) return Send(playerid, COLOR_GREY,"* ѕользоватс€ тазером можно раз в 8 секунд");
		tazered = GetClosestPlayer(playerid, 4.0);
		if(tazered == INVALID_PLAYER_ID) return Send(playerid, COLOR_GREY, "* ќколо вас нет никого!");
		if(!Pl::isLogged(tazered)) return Send(playerid, COLOR_GREY, "* Ётот игрок не авторизован!");
		if(IsACop(tazered)) return Send(playerid, COLOR_GREY, "Ќельз€ заэлектрошокить закон!!");
		if(IsPlayerInAnyVehicle(tazered)) return Send(playerid, COLOR_GREY, "* ѕодозреваемый находитс€ в автомобиле, выведити его сначала!");
		getname(playerid -> sendername,tazered -> playername);

  		if(Pl::Info[tazered][pMaskOn])
		{
			format(string, sizeof string, "* ¬ы ударили электрошоком по неизвесному он паролизован на 8 секунд.");
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬ы ударины электрошоком и паролизованы %s на 8 секунд.", sendername);
			Send(tazered, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s выстрелил электрошоком в неизвесного и он был паролизован,.", sendername);
			ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
		}
		else
		{
			format(string, sizeof string, "* ¬ы ударили электрошоком по %s он паролизован на 8 секунд.", playername);
			Send(playerid, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* ¬ы ударины электрошоком и паролизованы %s на 8 секунд.", sendername);
			Send(tazered, COLOR_LIGHTBLUE, string);
			format(string, sizeof string, "* %s выстрелил электрошоком в %s и он был паролизован,.", sendername, playername);
			ProxDetector(30.0, playerid, string, COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE,COLOR_PURPLE);
		}
		PlayerUseTazed[playerid] = true;
		GameTextForPlayer(tazered, "~r~Tazed", 3000, 3);
		Rac::TogglePlayerControllable(tazered, 0);
		SetPlayerAttachedObject(playerid, 0, 18642, 6, 0.055994, 0.018028, 0.045403, 348.699523, 154.366394, 0.000000, 1.000000, 1.000000, 1.000000 );
		SetTimerEx("TazerTime", 1000*8, false, "i", playerid);
		SetTimerEx(""#Rac::"TogglePlayerControllable", 1000 * 8 , false, "ii", tazered, 1);
	}
	return 1;
}


public OnPlayerClickPlayer(playerid, clickedplayerid, source) {
	if(Pl::isAdmin(playerid, 3)) {
		if(!TogTP[clickedplayerid] && !Pl::isAdmin(playerid, ADMINISTRATOR)) return 1;

		GetPlayerPos(clickedplayerid, posx, posy, posz);
		if(GetPlayerState(playerid) == 2) {
			Rac::SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(clickedplayerid));
			Rac::SetPlayerInterior(playerid, GetPlayerInterior(clickedplayerid));
			Rac::SetVehiclePos(GetPlayerVehicleID(playerid), posx, posy, posz);
		} else {
			Rac::SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(clickedplayerid));
			Rac::SetPlayerInterior(playerid, GetPlayerInterior(clickedplayerid));
			Rac::SetPlayerPos(playerid, posx, posy, posz+1);
		}
	}
	return 1;
}

public OnPlayerClickMap(playerid, Float:fX, Float:fY, Float:fZ) {
	if(Pl::isAdmin(playerid, ADMINISTRATOR)) {
		if(GetPlayerState(playerid) == 2) {
			Rac::SetPlayerVirtualWorld(playerid, 0);
			Rac::SetVehiclePos(GetPlayerVehicleID(playerid), fX, fY, fZ);
		} else {
			Rac::SetPlayerInterior(playerid, 0);
			Rac::SetPlayerVirtualWorld(playerid, 0);
			Rac::SetPlayerPos(playerid, fX, fY, fZ);
			Pl::Info[playerid][pLocal] = 0;
		}
	}
	return 1;
}

stock ChangeName(playerid) {
	new oldName[MAX_PLAYER_NAME], newName[MAX_PLAYER_NAME];
	GetPlayerName(playerid, oldName, MAX_PLAYER_NAME);
	GetPVarString(playerid, "NewName", newName, MAX_PLAYER_NAME);
	DeletePVar(playerid, "NewName");

	if(SetPlayerName(playerid, newName) == 1) {
		new nlen = strlen(newName);
		new bidx = GetIndexFromBizID(Pl::Info[playerid][pBizKey]);
		new hidx = Pl::Info[playerid][pHouseKey];

		if(IsValidHouse(hidx)) {
			if(strcmp(oldName, HouseInfo[hidx][hOwner], false) == 0) {
				strmid(HouseInfo[hidx][hOwner], newName, 0, nlen, MAX_PLAYER_NAME);
				UpdateHouse(hidx);
			}
		}
		if(IsValidBiz(bidx)) {
			if(strcmp(oldName, BizzInfo[bidx][bOwner], false) == 0) {
				strmid(BizzInfo[bidx][bOwner], newName, 0, nlen, MAX_PLAYER_NAME);
				UpdateBizz(bidx);
			}

			else if(strcmp(oldName, BizzInfo[bidx][bExtortion], false) == 0) {
				strmid(BizzInfo[bidx][bExtortion], newName, 0, nlen, MAX_PLAYER_NAME);
				UpdateBizz(bidx);
			}
		}

		format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Name`='%s' WHERE `ID`='%i'", newName, Pl::Info[playerid][pID]),
		Db::tquery(connDb, query, "", "");

		format(temp, sizeof temp, "** %s теперь изветен как %s (userid:%i)", oldName, newName, Pl::Info[playerid][pID]),
		SendLog(LOG_CHANGENAME, temp);

		format(temp, sizeof temp,"*"#__SERVER_PREFIX""#__SERVER_NAME_LC": %s теперь изветен как %s", oldName, newName),
		SendToAll(COLOR_LIGHTRED, temp);
	} else {
		Send(playerid, COLOR_LIGHTRED, "*   сожалению при смене вашего ника произошла ошибка.");
		Send(playerid, COLOR_LIGHTRED, "* ќбратитесь к администрации: /report");
	}
}

public OnVehicleStreamIn(vehicleid, forplayerid) {
	Iter::Add(inStreamVehicles[forplayerid], vehicleid);
	SetVehicleParamsForPlayer(vehicleid, forplayerid, 0, gCarLock{vehicleid});
	return 1;
}

public OnVehicleStreamOut(vehicleid, forplayerid) {
	Iter::Remove(inStreamVehicles[forplayerid], vehicleid);
	return 1;
}

public OnRconLoginAttempt(ip[], password[], success) {
	new _ip[16];
	if(!checkvar("bind","127.0.0.1")) {
		if(success) {
			foreach(new playerid : Player) {
				GetPlayerIp(playerid, _ip, 16);
				if(!strcmp(ip, _ip, true)) {
					return 1;
				}
			}
			format(temp, sizeof temp, "banip %s", ip);
			SendRconCommand(temp);
		} else {
			foreach(new playerid : Player) {
				GetPlayerIp(playerid, _ip, 16);
				if(!strcmp(ip, _ip, true)) {
					if(++Rac::Info[playerid][Rac::BadRconLogin] >= 2) {
						Rac::Kick(playerid, "ѕопытка взлома RCON парол€.");
						return 0;
					} else {
						GetPlayerName(playerid, plname, 24);
						format(temp, sizeof temp, "[AdmWarn] * %s[%i] попыталс€ залогинистс€ как RCON-админ!", plname, playerid);
						SendToAdmin(COLOR_YELLOW, temp, 3, 3);
						return 0;
					}
				}
			}
			format(temp, sizeof temp, "banip %s", ip);
			SendRconCommand(temp);
		}
	}
	return 1;
}

stock GiveFracMoney(fracid, amount) {
	if(IsValidFrac(fracid)) return FracInfo[fracid][fBank] += amount;
	return 0;
}

stock GetFracMoney(fracid) {
	if(IsValidFrac(fracid)) return FracInfo[fracid][fBank];
	return 0;
}

stock GivePlayerBankMoney(playerid, amount) Pl::Info[playerid][pBank] += amount;

public: ReduceTimer(playerid) ReduceTime[playerid] = 0;

public: TazerTime(playerid)
{
	PlayerUseTazed[playerid] = false;
	RemovePlayerAttachedObject(playerid, 0);
	return true;
}


stock IsAtATM(playerid) {
	for(new i; i < sizeof(ATMs); i++) {
		if(IsPlayerInRangeOfPoint(playerid, 2.0, ATMs[i][0], ATMs[i][1], ATMs[i][2])) {
			return 1;
		}
	}
	return 0;
}

stock GetClosestGas(playerid) {
	foreach(new i : Refills) {
		if(IsPlayerInRangeOfPoint(playerid, 8.0, RefillInfo[i][brPos][0], RefillInfo[i][brPos][1], RefillInfo[i][brPos][2])) {
			return i;
		}
	}
	return -1;
}

stock GetName(playerid) {
	static name[24];
	GetPlayerName(playerid, name, 24);
	return name;
}

stock GetPIP(playerid) {
	static pip[16];
	GetPlayerIp(playerid, pip, 16);
	return pip;
}

stock GetUserName(uid) {
	new name[24];
	format(query, sizeof query, "SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID` = '%i'", uid);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_get_row_count() > 0) {
		cache_get_row(0, 0, name);
	} else {
		strmid(name, "-", 0, 1, 24);
	}
	cache_delete(result);
	return name;
}

stock GetGangName(gangid) {
	static gangname[16];
	switch(gangid) {
	case 12, 14..18 : strmid(gangname, FracInfo[gangid][fTag], 0, 16);
		default : strmid(gangname, "посторонний", 0, 16);
	}
	return gangname;
}

native gpci(playerid, serial[], maxlen=sizeof serial);
stock GetPlayerSerial(playerid) {
	static serial[54];
	gpci(playerid, serial);
	return serial;
}

stock playerAFKUpdate(playerid) {
	static paused;
	static Float:x, Float:y, Float:z;
	paused = Rac::IsPlayerInPause(playerid);

	GetPlayerPos(playerid, x, y, z);
	if(AFKInfo[playerid][afk_Pos] == x) {
		if(paused) {
			AFKInfo[playerid][afk_Time][0] ++;
			AFKInfo[playerid][afk_Time][1] = 0;
		} else {
			AFKInfo[playerid][afk_Time][1] ++;
		}
	} else {
		if(!paused) {
			AFKInfo[playerid][afk_Time][0] = 0;
			AFKInfo[playerid][afk_Time][1] = 0;
			if(AFKInfo[playerid][afk_State] != 0) {
				AFKInfo[playerid][afk_State] = 0;
				Delete3DTextLabel(AFKInfo[playerid][afk_Text]);
				CallLocalFunction("OnPlayerAFK", "iii", playerid, 0, 1);
			}
		}
	}

	switch(AFKInfo[playerid][afk_State]) {
	case 0 : {
			if(paused && AFKInfo[playerid][afk_Time][0] == AFK_TEXT_SET) {
				AFKInfo[playerid][afk_State] = 1;
				CallLocalFunction("OnPlayerAFK", "ii", playerid, 1, 0);
				format(temp, sizeof temp, "{FF6347}[AFK: {ffffff}%i/%i {FF6347}секунд]", AFKInfo[playerid][afk_Time][0], MAX_AFK_TIME);
				AFKInfo[playerid][afk_Text] = Create3DTextLabel(temp, 0xFFFFFFFF, 0.00, 0.00, 10000.00, T_DIST, 0);
				Attach3DTextLabelToPlayer(AFKInfo[playerid][afk_Text], playerid, 0.0, 0.0, 0.3);
			}

			else if(!paused && AFKInfo[playerid][afk_Time][1] > MAX_AFK_TIME) {
				format(temp, sizeof temp,""#__SERVER_PREFIX""#__SERVER_NAME_LC": [%d]%s был кикнут сервером, причина: AFK", playerid, GetName(playerid));
				SendToAll(COLOR_GREY, temp);
				Kick(playerid);
			}
		}

	case 1 : {
			if(AFKInfo[playerid][afk_Time][0] > MAX_AFK_TIME) {
				if(Pl::isAdmin(playerid, ADMINISTRATOR)) {
					AFKInfo[playerid][afk_Time][0] = AFK_TEXT_SET;
					format(temp, sizeof temp, "{FF6347}[AFK: {ffffff}%i/%i {FF6347}секунд]", AFKInfo[playerid][afk_Time], MAX_AFK_TIME);
					Update3DTextLabelText(AFKInfo[playerid][afk_Text], 0xFFFFFFFF, temp);
				}

				else {
					format(temp, sizeof temp,""#__SERVER_PREFIX""#__SERVER_NAME_LC": [%d]%s был кикнут сервером. ѕричина: AFK", playerid, GetName(playerid));
					SendToAll(COLOR_GREY, temp);
					Kick(playerid);
				}
			} else {
				format(temp, sizeof temp, "{FF6347}[AFK: {ffffff}%i/%i {FF6347}секунд]", AFKInfo[playerid][afk_Time][0], MAX_AFK_TIME);
				Update3DTextLabelText(AFKInfo[playerid][afk_Text], 0xFFFFFFFF, temp);
			}
		}
	}

	AFKInfo[playerid][afk_Pos] = x;
}

stock UpdateGangInfo() {
	for(new p; p < sizeof(GangInfo); p++) {
		format(src, sizeof(src),
		"**GANG INFO**\n\n.::%s::.\nЅизнесы: %i\n”важение: %i\nЅанк: $%i\n«ахват с %i ранга",
		GetGangName(GangInfo[p][fID]),
		GangBiznes{GangInfo[p][fID]},
		GangInfo[p][gRespect],
		GetFracMoney(GangInfo[p][fID]),
		GetZRank(GangInfo[p][fID])
		);
		UpdateDynamic3DTextLabelText(GangInfo[p][gText], GetFracColor(GangInfo[p][fID]), src);
	}
	Sort::Gnome2D(GangInfo, gInfo, gRespect, METHOD_DESC);
	SaveGI();
}

stock IsAGang(playerid) {
	return (linearSearch(Gangs, Pl::FracID(playerid)) != -1);
}

stock IsAGangF(fracid) {
	return (linearSearch(Gangs, fracid) != -1);
}

stock IsAMafia(playerid) {
	return (linearSearch(Mafias, Pl::FracID(playerid)) != -1);
}

stock IsAMafiaF(fracid) {
	return (linearSearch(Mafias, fracid) != -1);
}


stock GiveGangRespect(gangid, amount) {
	for(new i; i < sizeof(GangInfo); i++) {
		if(GangInfo[i][fID] == gangid) {
			return GangInfo[i][gRespect] += amount;
		}
	}
	return 0;
}

stock SetGangRespect(gangid, amount) {
	for(new i; i < sizeof(GangInfo); i++) {
		if(GangInfo[i][fID] == gangid) {
			return GangInfo[i][gRespect] = amount;
		}
	}
	return 0;
}

stock GetPlayerOrigin(playerid) {
	new origin[24];
	switch(Pl::Info[playerid][pOrigin]) {
	case 1: strunpack(origin, !"≈вропа", sizeof origin);
	case 2: strunpack(origin, !"јзиа", sizeof origin);
	case 3: strunpack(origin, !"јмерика", sizeof origin);
	default: strunpack(origin,!"≈вроппа", sizeof origin);
	}
	return origin;
}

stock GetPlayerSex(playerid) {
	new sex[10];
	switch(Pl::Info[playerid][pSex]) {
	case 1: strunpack(sex, !"ћужской", sizeof sex);
	case 2: strunpack(sex, !"∆енский", sizeof sex);
	default: strunpack(sex, !"-", sizeof sex);
	}
	return sex;
}

stock GetPlayerAge(playerid) {
	new age[5];
	if(Pl::Info[playerid][pAge]) {
		format(age, sizeof age, "%i", Pl::Info[playerid][pAge]);
	} else {
		age = "-";
	}
	return age;
}

stock GetFracColor(fracid) {
	if(IsValidFrac(fracid)) {
		return FracInfo[fracid][fColor];
	}
	return COLOR_ALPHA;
}

stock GetAdminRank(admlevel) {
	new rank[16];
	switch(admlevel) {
	case 1..3: format(rank, sizeof rank, "ћодератор %ilvl", admlevel);
	case 4: strunpack(rank, !"—упермодер");
	case 5: strunpack(rank, !"ћл.јдмин");
    case 6: strunpack(rank, !"—т.јдмин");
    case 7: strunpack(rank, !"√л.јдмин");
    case 1339: strunpack(rank, !"ќснователь");
	}
	return rank;
}

stock GetHelperRank(hlvl) {
	new hrank[16];
	switch(hlvl) {
	case 1: strunpack(hrank, !"’елпер");
	case 2: strunpack(hrank, !"—тарший ’елпер");
	case 3: strunpack(hrank, !"√лавный ’елпер");
	default: strunpack(hrank, !"’елпер");
	}
	return hrank;
}

stock Db::Init() {
	Db::log(Db::Conf[Db::Debug] == 1 ? (LOG_ERROR | LOG_WARNING | LOG_DEBUG) : (LOG_ERROR | LOG_WARNING));

	connDb = Db::connect(Db::Conf[Db::Host], Db::Conf[Db::User], Db::Conf[Db::Base], Db::Conf[Db::Pass]);

	new errno = Db::errno();
	if(errno) Db::FixCharset();

	return errno == 0;
}

stock LoadConf() {
	new iniFile = iniOpen("conf.ini");
	if(iniFile != INI_FILE_NOT_FOUND) {
		iniGet(iniFile, "server.hostname", Gm::Info[Gm::Hostname], 36);
		iniGet(iniFile, "server.password", Gm::Info[Gm::Password], 36);
		iniGet(iniFile, "server.mode", Gm::Info[Gm::Mode], 36);
		iniGet(iniFile, "server.map", Gm::Info[Gm::Map], 36);
		iniGetInt(iniFile, "server.status", Gm::Info[Gm::Status]);

		iniGet(iniFile, "mysql.host", Db::Conf[Db::Host], 128);
		iniGet(iniFile, "mysql.user", Db::Conf[Db::User], 64);
		iniGet(iniFile, "mysql.base", Db::Conf[Db::Base], 64);
		iniGet(iniFile, "mysql.pass", Db::Conf[Db::Pass], 64);
		iniGet(iniFile, "mysql.charset", Db::Conf[Db::Charset], 16);
		iniGetInt(iniFile, "mysql.debug", Db::Conf[Db::Debug]);

		iniClose(iniFile);

		return 1;
	}
	return 0;
}

stock Db::FixCharset() {
	Db::set_charset(Db::Conf[Db::Charset]);
	format(temp, sizeof temp, "SET NAMES '%s'", Db::Conf[Db::Charset]);
	Db::query(connDb, temp, false);
	Db::query(connDb, "SET SESSION character_set_server='utf8';", false);
	return 1;
}

stock Db::Update() {
	if(fexist("update.sql")) {
		new File:fhandle = fopen("update.sql", io_read);
		while(fread(fhandle, temp)) {
			LoadFile(temp, query);
			Db::query(connDb, query, false);
		}
		fclose(fhandle);
	}
	return 1;
}

stock SetZRank(fracid, zrank) {
	if(IsValidFrac(fracid)) {
		FracInfo[fracid][fRConf][zRANK] = zrank;
		UpdateGangInfo();
	}
	return 1;
}

stock GetZRank(fracid) {
	if(IsValidFrac(fracid)) {
		return FracInfo[fracid][fRConf][zRANK];
	}
	return 0;
}


stock SetBRank(fracid, zrank) {
	if(IsValidFrac(fracid)) {
		FracInfo[fracid][fRConf][bRANK] = zrank;
	}
	return 1;
}

stock GetBRank(fracid) {
	if(IsValidFrac(fracid)) {
		return FracInfo[fracid][fRConf][bRANK];
	}
	return 0;
}

stock SetGRank(fracid, zrank) {
	if(IsValidFrac(fracid)) {
		FracInfo[fracid][fRConf][gRANK] = zrank;
	}
	return 1;
}

stock GetGRank(fracid) {
	if(IsValidFrac(fracid)) {
		return FracInfo[fracid][fRConf][gRANK];
	}
	return 0;
}

stock Pl::isLogged(playerid) {
	return IsPlayerConnected(playerid) && PlayerLogged{playerid};
}

stock Pl::isRegged(playerid) {
	if(IsPlayerConnected(playerid)) {
		return Pl::Info[playerid][pID] == -1 ? 0 : 1;
	}
	return 0;
}

stock GameTextForGangs(const dest[], time, type, ...) {
	static const STATIC_ARGS = 3;
	new argCount = numargs();
	if((argCount - STATIC_ARGS) > 0) {
		for(new i = STATIC_ARGS; i < argCount; i++) {
			GameTextForGang(getarg(i), dest, time, type);
		}
	} else {
		for(new i; i < sizeof Gangs; i++) {
			GameTextForGang(Gangs[i], dest, time, type);
		}
	}
	return 1;
}

stock GameTextForGang(gangid, const mess[], time, type) {
	foreach(new p: TeamPlayers[gangid]) {
		GameTextForPlayer(p, mess, time, type);
	}
}

stock Pl::Init(playerid) {
	GMTest{playerid}					= false;
	usePlusC{playerid}					= false;
	useBannyHop{playerid}				= false;
	InAntiDmZone{playerid}				= false;

	KG[playerid]						= {0,0};
	OnJob[playerid]						= 0;
	StartJob[playerid]					= 0;
	PlayerObject[playerid]				= INVALID_OBJECT_ID;

	CP[playerid]						= 0;
	Fixr{playerid}						= 0;
	Wait{playerid}						= 0;
	ChosenSkin[playerid]				= 0;
	SelectCharPlace[playerid]			= 0;
	GettingJob[playerid]				= 0;
	ApprovedLawyer[playerid]			= 0;
	CallLawyer[playerid]				= 0;
	WantLawyer[playerid]				= 0;
	UsedFind[playerid]					= 0;
	CarOffer[playerid]					= INVALID_PLAYER_ID;
	CarPrice[playerid]					= 0;
	CarID[playerid]						= 0;
	CarCalls[playerid]					= 0;
	Condom[playerid]					= 0;
	acceptgruz{playerid}				= 0;
	TaxiCallTime[playerid]				= 0;
	STDPlayer[playerid]					= 0;
	SexOffer[playerid]					= INVALID_PLAYER_ID;
	SexPrice[playerid]					= 0;
	RepairOffer[playerid]				= INVALID_PLAYER_ID;
	RepairPrice[playerid]				= 0;
	RepairCar[playerid]					= 0;
	TalkingLive[playerid]				= INVALID_PLAYER_ID;
	LiveOffer[playerid]					= INVALID_PLAYER_ID;
	RefillOffer[playerid]				= INVALID_PLAYER_ID;
	RefillPrice[playerid]				= 0;
	DrugOffer[playerid]					= INVALID_PLAYER_ID;
	DrugPrice[playerid]					= 0;
	DrugGram[playerid]					= 0;
	AnimClear[playerid]					= 0;
	JailPrice[playerid]					= 0;
	Mobile[playerid]					= 255;
	Music[playerid]						= 0;
	TransportCost[playerid]				= 0;
	gLastCar[playerid]					= INVALID_VEHICLE_ID;
	BusCallTime[playerid]				= 0;
	PlayerTazeTime[playerid]			= 0;
	useknock[playerid]					= 0;
	TicketOffer[playerid]			 	= INVALID_PLAYER_ID;
	TicketMoney[playerid]				= 0;
	MatsHolding[playerid]				= 0;
	TransportTime[playerid]				= 0;
	TaxiAccepted[playerid]				= INVALID_PLAYER_ID;
	BusAccepted[playerid]				= INVALID_PLAYER_ID;
	Fell[playerid]						= 0;
	HireCar[playerid] 					= INVALID_VEHICLE_ID;
	TransportValue[playerid]			= 0;
	TransportDriver[playerid]			= INVALID_PLAYER_ID;
	TransportDuty[playerid]				= 0;
	DrugIntoxic[playerid]				= 0;
	JobWaitTime[playerid]				= 0;
	Mobile[playerid]					= INVALID_PLAYER_ID;
	NameChange{playerid}				= 0;
	FindTime[playerid]					= 0;

	MedicCallTime[playerid]				= {INVALID_PLAYER_ID, 0};
	MechanicCallTime[playerid]			= {INVALID_PLAYER_ID, 0};

	PickupInfo[playerid][pOld]			= -1;
	PickupInfo[playerid][pDelay]		= 0;

	AFKInfo[playerid][afk_State]		= 0;
	AFKInfo[playerid][afk_Time]			= {0, 0};

	Pl::Drunk[playerid]					= 0;
	Pl::CarInt[playerid]				= INVALID_VEHICLE_ID;
	Pl::Stoned[playerid]				= 0;
	Pl::NetStats[playerid]				= INVALID_PLAYER_ID;
	Pl::DrunkTime[playerid]				= 0;
	Pl::CuffedTime[playerid]			= 0;

	Pl::SpecInfo[playerid][pSpecID]		= INVALID_PLAYER_ID;

	SyncInfo[playerid][sKillerID]		= INVALID_PLAYER_ID;
	SyncInfo[playerid][sReasonID]		= 255;

	Pl::Info[playerid][pReg]			= 0;
	Pl::Info[playerid][pSex]			= 0;
	Pl::Info[playerid][pAge]			= 0;
	Pl::Info[playerid][pExp]			= 0;
	Pl::Info[playerid][pJob]			= 0;
	Pl::Info[playerid][pBank]			= 0;
	Pl::Info[playerid][pWait]			= 10;
	Pl::Info[playerid][pLevel]			= 0;
	Pl::Info[playerid][pAdmin]			= 0;
	Pl::Info[playerid][pKills]			= 0;
	Pl::Info[playerid][pHelper]			= 0;
	Pl::Info[playerid][pOrigin]			= 1;
	Pl::Info[playerid][pCrimes]			= 0;
	Pl::Info[playerid][pDeaths]			= 0;
	Pl::Info[playerid][pArrested]		= 0;
	Pl::Info[playerid][pWantedL]		= 0;
	Pl::Info[playerid][pWantedD]		= 0;
	Pl::Info[playerid][pPhoneBook]		= 0;
	Pl::Info[playerid][pLottoNr]		= 0;
	Pl::Info[playerid][pPayCheck]		= 0;
	Pl::Info[playerid][pJailed]			= 0;
	Pl::Info[playerid][pJailTime]		= 0;
	Pl::Info[playerid][pMats]			= 0;
	Pl::Info[playerid][pDrugs]			= 0;
	Pl::Info[playerid][pLeader]			= 0;
	Pl::Info[playerid][pMember]			= 0;
	Pl::Info[playerid][pRank]			= 0;
	Pl::Info[playerid][pChar]			= 79;
	Pl::Info[playerid][pContractTime]	= 0;
	Pl::Info[playerid][pSkill]			= {0, 0, 0, 0, 0, 0, 0, 0};
	Pl::Info[playerid][pLocal]			= 0;
	Pl::Info[playerid][pNumber]			= 0;
	Pl::Info[playerid][pHouseKey]		= INVALID_HOUSE_ID;
	Pl::Info[playerid][pBizKey]			= INVALID_BIZ_ID;
	Pl::Info[playerid][pLic]			= {0, 0, 0, 0, 0};
	Pl::Info[playerid][pCarTime]		= 0;
	Pl::Info[playerid][pPayDay]			= 0;
	Pl::Info[playerid][pCDPlayer]		= 0;
	Pl::Info[playerid][pPayDayHad]		= 0;
	Pl::Info[playerid][pMutedTime]		= 0;
	Pl::Info[playerid][pMaskOn]			= false;
	Pl::Info[playerid][pWarns]			= 0;
	Pl::Info[playerid][pFuel]			= 0;
	Pl::Info[playerid][pRebuke]			= 0;
	Pl::Info[playerid][pReport]			= 0;
	Pl::Info[playerid][pFightstyle]		= 0;
	Pl::Info[playerid][pVip]			= 0;
	Pl::Info[playerid][pPasport]		= {0, 0, 0};


	Gag[playerid]						= false;
	GrabPer[playerid]                   = false;
	gOoc[playerid]						= true;
	gFam[playerid]						= true;
	gNews[playerid]						= true;
	gDice[playerid]						= false;
	OnAir[playerid]						= false;
	TogTP[playerid]						= true;
	OnDuty[playerid]					= false;
	BigEar[playerid]					= false;
	HidePM[playerid]					= false;
	EditMode[playerid]					= false;
	MedicBill[playerid]					= false;
	SwitchKey[playerid]					= false;
	AdminDuty[playerid]					= false;
	WatchingTV[playerid]				= false;
	WrongLogin[playerid]				= 3;
	PlayerTied[playerid]				= false;
	HelperDuty[playerid]				= false;
	SpawnChange[playerid]				= false;
	SuspectKill[playerid]				= false;
	PhoneOnline[playerid]				= true;
	MoneyMessage[playerid]				= false;
	TakingLesson[playerid]				= false;
	PlayerUseTazed[playerid]			= false;

	TempVehicle[playerid]				= INVALID_VEHICLE_ID;

	SetPVarInt(playerid, "RouteID", 0xFFFF);
	SetPVarInt(playerid, "SelectedCar", -1);
	SetPVarInt(playerid, "SelectedItem", -1);
	SetPVarInt(playerid, "SelectedPlayer", INVALID_PLAYER_ID);
	SetPVarInt(playerid, "selectTeleport", 0xFFFF);
	SetPVarInt(playerid, "SelectGas", 0xFFFF);

	SetPVarInt(playerid, "InvateFrac", 0);
	SetPVarInt(playerid, "AnsweredHelper", INVALID_PLAYER_ID);
	SetPVarInt(playerid, "TransferPlayer", INVALID_PLAYER_ID);
	SetPVarInt(playerid, "TransferAmount", 0);

	SetPVarInt(playerid, "HouseSeller", INVALID_PLAYER_ID);
	SetPVarInt(playerid, "HouseBuyer", INVALID_PLAYER_ID);
	SetPVarInt(playerid, "HouseType", 0);
	SetPVarInt(playerid, "HousePrice", 0);

	TotalExtraVehicles[playerid] = 0;
	TotalVehicleInGarage[playerid] = 0;
	Iter::Clear(ExtraVehicles[playerid]);

	Rac::SetPlayerMoney(playerid, 0);
	Rac::SetPlayerHealth(playerid, 100.0);
	SetPlayerColor(playerid, COLOR_GRAD2);

	for(new i; i < MAX_EXTRA_VEHICLES; i++) VehicleInGarage[playerid][i] = 0;
	for(new i; i < 6; i++) DisablePlayerCheckpointEx(playerid, i);

	return 1;
}

stock Pl::RemoveWorldModel(playerid) {
	RemoveBuildingForPlayer(playerid, 2938, 1053.2607,2088.0015,10.8203, 20.0);
	RemoveBuildingForPlayer(playerid, 14797, 617.75, -125.39062, 998.32031, 20.0);
	return 1;
}

stock Bl::Init(playerid) {
	for(new i; i < MAX_FRAC; i++) {
		Bl::Info[playerid][Bl::onFrac][i] = 0;
		Bl::Info[playerid][Bl::Kills][i] = 0;
	}
	Bl::Info[playerid][Bl::isKilled] = false;
	Bl::Info[playerid][Bl::Observe] = INVALID_PLAYER_ID;
	Bl::Info[playerid][Bl::Finder] = INVALID_PLAYER_ID;
}

stock ClearCrime(playerid) {
	new len = strlen("********");
	strmid(Pl::Crime[playerid][pVictim], "********", 0,  len, 255);
	strmid(Pl::Crime[playerid][pAccusing], "ХХХХХХХХХ", 0, len, 255);
	strmid(Pl::Crime[playerid][pAccused], "ХХХХХХХХХ", 0, len, 255);
}


stock Td::Init() {
	Logo[0] = Td::Create(473.000000, 6.000000, "~w~www.~g~rp-"#__SERVER_NAME_L"~w~.ru");
	Td::BackgroundColor(Logo[0], 255);
	Td::Font(Logo[0], 3);
	Td::LetterSize(Logo[0], 0.380000, 1.200000);
	Td::Color(Logo[0], 0xCCCCCCCC);
	Td::SetOutline(Logo[0], 1);
	Td::SetProportional(Logo[0], 1);

	Time = Td::Create(556.000000, 23.000000, "~w~00:00");
	Td::BackgroundColor(Time, 255);
	Td::Font(Time, 3);
	Td::LetterSize(Time, 0.480000, 2.399999);
	Td::Color(Time, 0xCCCCCCCC);
	Td::SetOutline(Time, 1);
	Td::SetProportional(Time, 1);

	Copyright = Td::Create(588.000000, 438.000000, "~w~powered by "#__GamemodeName__"-"#__GamemodeVersion__"");
	Td::Alignment(Copyright, 2);
	Td::BackgroundColor(Copyright, 255);
	Td::Font(Copyright, 3);
	Td::LetterSize(Copyright, 0.220000, 0.899999);
	Td::Color(Copyright, -858993630);
	Td::SetOutline(Copyright, 0);
	Td::SetProportional(Copyright, 1);
	Td::SetShadow(Copyright, 0);

	new h, m, s; gettime(h, m, s);
	format(temp, sizeof temp, "~w~%02i:%02i", h, m);
	Td::SetString(Time, temp);

	return 1;
}

stock SetVehicleNumber(vehid, number[] = "none") {
	if(strcmp(number, "none", false)) {
		SetVehicleNumberPlate(vehid, number);
	} else {
		if(vehid > 999) {
			format(temp, sizeof temp, "%c%c%04i%c", ('A'+random(26)), ('A'+random(26)), vehid, ('A'+random(26)));
		} else {
			format(temp, sizeof temp, "%c%c%03i%c", ('A'+random(26)), ('A'+random(26)), vehid, ('A'+random(26)));
		}
		SetVehicleNumberPlate(vehid, temp);
	}
}

stock ShowBizZones(playerid) {
	new fracid = Pl::FracID(playerid);
	foreach(new i : Biznes) {
		Gz::ShowForPlayer(playerid, BizzInfo[i][bZone], GetFracColor(BizzInfo[i][bFrac]));
		if(BizzInfo[i][bOnBattle] == 1) {
			Gz::FlashForPlayer(playerid, BizzInfo[i][bZone], GetFracColor(BizzInfo[i][bAttack]));
			if(fracid == BizzInfo[i][bDefend] || fracid == BizzInfo[i][bAttack]) {
				SetPlayerCheckpointEx(playerid, ZAHVAT_ICON, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2], 19, 0, -1, -1, true);
			}
		}
	}
	return 1;
}

stock HideBizZones(playerid) {
	foreach(new i : Biznes) {
		if(BizzInfo[i][bOnBattle] == 1) {
			Gz::StopFlashForPlayer(playerid, BizzInfo[i][bZone]);
		}
		Gz::HideForPlayer(playerid, BizzInfo[i][bZone]);
	}
	return 1;
}

stock Gz::ShowForGangs(zoneid, color) {
	for(new i; i < sizeof Gangs; i++) {
		foreach(new playerid : TeamPlayers[Gangs[i]]) {
			Gz::ShowForPlayer(playerid, zoneid, color);
		}
	}
	return 1;
}

stock Gz::HideForGangs(zoneid) {
	for(new i; i < sizeof Gangs; i++) {
		foreach(new playerid : TeamPlayers[Gangs[i]]) {
			Gz::HideForPlayer(playerid, zoneid);
		}
	}
	return 1;
}

stock Gz::FlashForGangs(zoneid, color) {
	for(new i; i < sizeof Gangs; i++) {
		foreach(new playerid : TeamPlayers[Gangs[i]]) {
			Gz::FlashForPlayer(playerid, zoneid, color);
		}
	}
	return 1;
}

stock Td::ShowForFrac(Text:textid, ...) {
	static const STATIC_ARGS = 1;
	new argCount = numargs();
	if((argCount - STATIC_ARGS) > 0) {
		for(new fracid, i = STATIC_ARGS; i < argCount; i++) {
			if(1 <= (fracid=getarg(i)) <= 20) {
				foreach(new p : TeamPlayers[fracid]) {
					Td::ShowForPlayer(p, textid);
				}
			}
		}
	}
	return 1;
}

stock Td::HideForFrac(Text:textid, ...) {
	static const STATIC_ARGS = 1;
	new argCount = numargs();
	if((argCount - STATIC_ARGS) > 0) {
		for(new fracid, i = STATIC_ARGS; i < argCount; i++) {
			if(1 <= (fracid=getarg(i)) <= 20) {
				foreach(new p : TeamPlayers[fracid]) {
					Td::HiddForPlayer(p, textid);
				}
			}
		}
	}
	return 1;
}

stock Pt::Init(playerid) {
	Pt::Fuel[playerid] = CreatePlayerTextDraw(playerid, 8.000000, 321.000000, "~w~Benzin: ~b~loading");
	Pt::BackgroundColor(playerid, Pt::Fuel[playerid], 255);
	Pt::Font(playerid, Pt::Fuel[playerid], 3);
	Pt::LetterSize(playerid, Pt::Fuel[playerid], 0.400000, 1.699998);
	Pt::Color(playerid, Pt::Fuel[playerid], 0xCCCCCCCC); //-286331190);
	Pt::SetOutline(playerid, Pt::Fuel[playerid], 1);
	Pt::SetProportional(playerid, Pt::Fuel[playerid], 1);

	Pt::Status[playerid] = CreatePlayerTextDraw(playerid, 8.000000, 339.000000, "~w~Lock");
	Pt::BackgroundColor(playerid, Pt::Status[playerid], 255);
	Pt::Font(playerid, Pt::Status[playerid], 3);
	Pt::LetterSize(playerid, Pt::Status[playerid], 0.400000, 1.699998);
	Pt::Color(playerid, Pt::Status[playerid], 0xCCCCCCCC);
	Pt::SetOutline(playerid, Pt::Status[playerid], 1);
	Pt::SetProportional(playerid, Pt::Status[playerid], 1);

	Pt::Name[playerid] = CreatePlayerTextDraw(playerid, 8.000000, 430.000000, "_");
	Pt::BackgroundColor(playerid, Pt::Name[playerid], 255);
	Pt::Font(playerid, Pt::Name[playerid], 3);
	Pt::LetterSize(playerid, Pt::Name[playerid], 0.400000, 1.499999);
	Pt::Color(playerid, Pt::Name[playerid], 0xCCCCCCCC);
	Pt::SetOutline(playerid, Pt::Name[playerid], 1);
	Pt::SetProportional(playerid, Pt::Name[playerid], 1);

	Pt::Spec[playerid] = CreatePlayerTextDraw(playerid, 320.000000, 350.000000, "_");
	Pt::Alignment(playerid, Pt::Spec[playerid], 2);
	Pt::BackgroundColor(playerid, Pt::Spec[playerid], 255);
	Pt::Font(playerid, Pt::Spec[playerid], 2);
	Pt::LetterSize(playerid, Pt::Spec[playerid], 0.489998, 2.099999);
	Pt::Color(playerid, Pt::Spec[playerid], 0xCCCCCCCC);
	Pt::SetOutline(playerid, Pt::Spec[playerid], 1);
	Pt::SetProportional(playerid, Pt::Spec[playerid], 1);

	Pt::Speed[playerid][0] = CreatePlayerTextDraw(playerid, 138.000000, 403.000000, " "); //30
	Pt::BackgroundColor(playerid, Pt::Speed[playerid][0], 0x00000033);
	Pt::Font(playerid, Pt::Speed[playerid][0], 1);
	Pt::LetterSize(playerid, Pt::Speed[playerid][0], 0.359999, 1.8);
	Pt::Color(playerid, Pt::Speed[playerid][0], -1);
	Pt::SetOutline(playerid, Pt::Speed[playerid][0], 1);
	Pt::SetProportional(playerid, Pt::Speed[playerid][0], 1);

	Pt::Speed[playerid][1] = CreatePlayerTextDraw(playerid, 138.000000, 403.000000, "IIIIIIIIIIIIIIIIIIIIIIIIIIIII"); //30
	Pt::BackgroundColor(playerid, Pt::Speed[playerid][1], 0x00000000);
	Pt::Font(playerid, Pt::Speed[playerid][1], 1);
	Pt::LetterSize(playerid, Pt::Speed[playerid][1], 0.359999, 1.8);
	Pt::Color(playerid, Pt::Speed[playerid][1], 0xFFFFFF33);
	Pt::SetOutline(playerid, Pt::Speed[playerid][1], 1);
	Pt::SetProportional(playerid, Pt::Speed[playerid][1], 1);

	Pt::Speed[playerid][2] = CreatePlayerTextDraw(playerid, 145.000000, 388.000000, " "); //km
	Pt::BackgroundColor(playerid, Pt::Speed[playerid][2], 0x000000FF);
	Pt::Font(playerid, Pt::Speed[playerid][2], 2);
	Pt::LetterSize(playerid, Pt::Speed[playerid][2], 0.309998, 1.600000);
	Pt::Color(playerid, Pt::Speed[playerid][2], -1);
	Pt::SetOutline(playerid, Pt::Speed[playerid][2], 0);
	Pt::SetProportional(playerid, Pt::Speed[playerid][2], 1);
	Pt::SetShadow(playerid, Pt::Speed[playerid][2], 0);

	Td::AutoSolon = CreatePlayerTextDraw(playerid, 468.000000, 351.000000, "_");
	Pt::BackgroundColor(playerid, Td::AutoSolon, 255);
	Pt::Font(playerid, Td::AutoSolon, 3);
	Pt::LetterSize(playerid, Td::AutoSolon, 0.450000, 1.300000);
	Pt::Color(playerid, Td::AutoSolon, 0xCCCCCCCC);
	Pt::SetOutline(playerid, Td::AutoSolon, 1);
	Pt::SetProportional(playerid, Td::AutoSolon, 1);

	return 1;
}


public OnVehicleMod(playerid, vehicleid, componentid) {
	if(Rac::Info[playerid][Rac::Warns][R::TUNING_HACK] == 0) {
		AutoInfo[vehicleid][aTuning][GetVehicleComponentType(componentid)] = componentid;
		return 1;
	}

	return 0;
}

public OnVehicleRespray(playerid, vehicleid, color1, color2) {
	if(color1 == -1 && color2 == -1) {
		foreach(new i : Biznes) {
			if(IsPlayerInSquare2D(playerid, 13.0, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1])) {
				if(BizzInfo[i][bOwned]) {
					if(Rac::GetPlayerMoney(playerid) < BizzInfo[i][bEnterCost]) {
						GameTextForPlayer(playerid, "~r~You dont have the cash", 5000, 1);
					} else {
						GiveBizzProfit(i, BizzInfo[i][bEnterCost]);
						Rac::GivePlayerMoney(playerid, -BizzInfo[i][bEnterCost]);
						format(src, sizeof(src), "~r~repair price~w~~n~%i$", BizzInfo[i][bEnterCost]);
						GameTextForPlayer(playerid, src, 5000, 1);
					}
				} else {
					if(Rac::GetPlayerMoney(playerid) < BizzInfo[i][bEnterCost]) {
						GameTextForPlayer(playerid, "~r~You dont have the cash", 5000, 1);
					} else {
						GiveBizzProfit(i, 500);
						Rac::GivePlayerMoney(playerid, -500);
						GameTextForPlayer(playerid, "~r~repair price~w~~n~500$", 5000, 1);
					}
				}
				break ;
			}
		}
	} else {
		AutoInfo[vehicleid][aColor][COLOR_ONE] = color1;
		AutoInfo[vehicleid][aColor][COLOR_TWO] = color2;
	}
	return 1;
}

public OnVehiclePaintjob(playerid, vehicleid, paintjobid) {
	AutoInfo[vehicleid][aPaintJob] = paintjobid;
	return 1;
}

stock IsAnyTrailerAttachedToVehicle(vehicleid) {
	return linearSearch(trailerID, GetVehicleModel(GetVehicleTrailer(vehicleid))) != -1;
}

stock UpdateTuning(vehid, type, id) {
	switch(type) {
	case 1: {
			if(!IsValidHouse(id)) return 0;
			format(query, sizeof query, "UPDATE `"#__TableHouses__"` SET `vehicle_tuning`='");
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][0], AutoInfo[vehid][aTuning][1], AutoInfo[vehid][aTuning][2], AutoInfo[vehid][aTuning][3]);
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][4], AutoInfo[vehid][aTuning][5], AutoInfo[vehid][aTuning][6], AutoInfo[vehid][aTuning][7]);
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][8], AutoInfo[vehid][aTuning][9], AutoInfo[vehid][aTuning][10], AutoInfo[vehid][aTuning][11]);
			scf(query, src, "%d,%d,%d' ", AutoInfo[vehid][aTuning][12], AutoInfo[vehid][aTuning][13], AutoInfo[vehid][aPaintJob]);
			scf(query, src, "WHERE `id`='%i'", id);
			Db::tquery(connDb, query, "", "");
		}
	case 2: {
			format(query, sizeof query, "UPDATE `"#__TableVehicles__"` SET `tuning`='");
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][0], AutoInfo[vehid][aTuning][1], AutoInfo[vehid][aTuning][2], AutoInfo[vehid][aTuning][3]);
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][4], AutoInfo[vehid][aTuning][5], AutoInfo[vehid][aTuning][6], AutoInfo[vehid][aTuning][7]);
			scf(query, src, "%d,%d,%d,%d,", AutoInfo[vehid][aTuning][8], AutoInfo[vehid][aTuning][9], AutoInfo[vehid][aTuning][10], AutoInfo[vehid][aTuning][11]);
			scf(query, src, "%d,%d,%d' ", AutoInfo[vehid][aTuning][12], AutoInfo[vehid][aTuning][13], AutoInfo[vehid][aPaintJob]);
			scf(query, src, "WHERE `ID`='%d'", id);
			Db::tquery(connDb, query, "", "");
		}
	default: return 0;
	}
	return 1;
}

stock ResetTuning(vehid, type, id) {
	switch(type) {
	case 1: {
			if(IsValidHouse(id)) {
				RemoveTuning(vehid);
				format(query, sizeof query, "UPDATE `"#__TableHouses__"` SET `vehicle_tuning`='0,0,0,0,0,0,0,0,0,0,0,0,0,0,3' WHERE `id`='%i'", id);
				Db::tquery(connDb, query, "", "");
			}
		}

	case 2: {
			RemoveTuning(vehid);
			format(query, sizeof query, "UPDATE `"#__TableVehicles__"` SET `tuning`='0,0,0,0,0,0,0,0,0,0,0,0,0,0,3' WHERE `ID`='%i'", id);
			Db::tquery(connDb, query, "", "");
		}
	default: return 0;
	}
	return 1;
}

stock AddTuning(vehid) {
	for(new i; i < MAX_COMPONENT; i++) {
		if(AutoInfo[vehid][aTuning][i] != 0) {
			AddVehicleComponent(vehid, AutoInfo[vehid][aTuning][i]);
		}
	}
	if(AutoInfo[vehid][aPaintJob] != 3) {
		ChangeVehiclePaintjob(vehid, AutoInfo[vehid][aPaintJob]);
	}
	return 1;
}

stock RemoveTuning(vehid) {
	for(new i; i < MAX_COMPONENT; i++) {
		RemoveVehicleComponent(vehid, AutoInfo[vehid][aTuning][i]);
		AutoInfo[vehid][aTuning][i] = 0;
	}
	AutoInfo[vehid][aPaintJob] = 3;
	ChangeVehiclePaintjob(vehid, AutoInfo[vehid][aPaintJob]);
	return 1;
}

stock ShowRankList(playerid, fracid) {
	dialog[0] = '\0';
	for(new i = RankNums[fracid]; i != 0; i--) {
		scf(dialog, temp, "%i.  %s\n", i, RankInfo[fracid][i]);
	}

	SetPVarInt(playerid, "SelectedFrac", fracid);
	format(temp, sizeof(temp), "–анги [%s]", FracInfo[fracid][fName]);
	SPD(playerid, D_CRANK, DIALOG_STYLE_LIST, temp, dialog, "SELECT", "CANCLE");
	return 1;
}

stock UpdateRank(fracid, rankid, rank[]) {
	new escname[36];
	Db::escape_string(rank, escname);
	strmid(RankInfo[fracid][rankid], rank, 0, strlen(rank), 255);
	format(query, sizeof query, "UPDATE `"#__TableFracRanks__"` SET `r_name` = '%s' WHERE `f_id` = '%i' AND `r_id` = '%i'", escname, fracid, rankid);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock SetFracName(fracid, name[]) {
	new escname[36];
	Db::escape_string(name, escname);
	strmid(FracInfo[fracid][fName], name, 0, strlen(name), 255);
	format(query, sizeof query, "UPDATE `"#__TableFracInfo__"` SET `fName` = '%s' WHERE `fID` = '%i'", escname, fracid);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock SetFracTag(fracid, tag[]) {
	new escname[16];
	Db::escape_string(tag, escname);
	strmid(FracInfo[fracid][fTag], tag, 0, strlen(tag), 255);
	format(query, sizeof query, "UPDATE `"#__TableFracInfo__"` SET `fTag` = '%s' WHERE `fID` = '%i'", escname, fracid);
	Db::tquery(connDb, query, "", "");
	return 1;
}

// Ѕан игрока
stock AddBanList(playerid, adminid, mins, reason[], type = 1) {
	new unbandate, currdate = gettime();
	unbandate = currdate + mins * 60;

	new safestr[64];
	Db::escape_string(reason, safestr);
	format(query, sizeof query, "INSERT INTO `"#__TableBanned__"` (`user_id`,`admin_id`,`ip`,`date`,`unbandate`,`reason`) VALUES (");
	scf(query, src, "'%i','%i','%s',", Pl::Info[playerid][pID], adminid==-1 ? adminid : Pl::Info[adminid][pID], GetPIP(playerid));
	scf(query, src, "'%i','%i','%s')", currdate, unbandate, safestr);
	Db::tquery(connDb, query, "", "");

	switch(type) {
	case 1 : {
			format(query, sizeof query, "*"#__SERVER_PREFIX""#__SERVER_NAME_LC": %s был забанен администратором %s, причина: %s", GetName(playerid), GetName(adminid), reason);
			SendToAll(COLOR_LIGHTRED, query);
		}
	case 2 : {
			format(src, sizeof(src), "* ¬ы были забанены, причина: %s", reason);
			Send(playerid, COLOR_LIGHTRED, src);
			format(src, sizeof(src), "[AdmWarn] * %s[%i] был забанен, причина: %s", GetName(playerid), playerid, reason);
			SendToAdmin(COLOR_LIGHTRED, src, 1, 3);
		}
	case 3 : {
			format(src, sizeof(src), "* ¬ы были забанены, причина: %s", reason);
			Send(playerid, COLOR_LIGHTRED, src);
			format(src, sizeof(src), "[античит] * %s[%i] был забанен, причина: %s", GetName(playerid), playerid, reason);
			SendToAdmin(COLOR_LIGHTRED, src, 1, 1);
		}
		default : {
			format(query, sizeof query, "[SBAN] јдмин %s забанил игрока %s[%i], причина: %s", GetName(adminid), GetName(playerid), playerid, reason);
			SendToAdmin(COLOR_LIGHTBLUE, query, 1, 3);
		}
	}
	return BanEx(playerid, reason);
}

// ”даление игрока из бан-листа
stock RemoveBanList(userid) {
	new banIp[16];
	format(query, sizeof query, "SELECT `ip` FROM `"#__TableBanned__"` WHERE `user_id`='%i'", userid);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_get_row_count()) {
		cache_get_row(0, 0, banIp);
		format(query, sizeof query, "unbanip %.16s", banIp);
		SendRconCommand(query);

		format(query, sizeof query, "DELETE FROM `"#__TableBanned__"` WHERE `user_id`='%i'", userid);
		Db::tquery(connDb, query, "", "");
		return 1;
	}
	cache_delete(result);
	return 0;
}

stock isBanned(userid) {
	format(query, sizeof query, "SELECT `user_id` FROM `"#__TableBanned__"` WHERE `user_id` = '%i'", userid);
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	cache_delete(result);
	return rows;
}

public: CheckBan(playerid) {
	if(Pl::Info[playerid][pID] != -1) {
		new unbandate, bandate, bip[16], aname[24], reason[64];
		format(query, sizeof query, "SELECT (SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`user_id`),\
		(SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`admin_id`),\
		`ip`,`date`,`unbandate`,`reason` FROM `"#__TableBanned__"` WHERE `user_id`='%i'", Pl::Info[playerid][pID]);

		new Cache:result = Db::query(connDb, query, true);
		if(cache_get_row_count()) {
			cache_get_row(0, 0, plname);
			cache_get_row(0, 1, aname);
			cache_get_row(0, 2, bip);
			cache_get_int(0, 3, bandate);
			cache_get_int(0, 4, unbandate);
			cache_get_row(0, 5, reason);
			cache_delete(result);

			if((unbandate-gettime()) > 0) {
				new date_s[2][28];
				to_timestamp(date_s[0], bandate, "%d-%m-%Y, %X");
				to_timestamp(date_s[1], unbandate, "%d-%m-%Y, %X");

				format(dialog, sizeof dialog, "* ¬ы были забанены!\n\n");
				scf(dialog, temp, "«абанил: %s\n", issqlnull(aname) ? ("System") : aname);
				scf(dialog, temp, "ѕричина: %s\n", reason);
				scf(dialog, temp, "—рок бана: %i дней\n", getday(unbandate, bandate));
				scf(dialog, temp, "ƒата бана: %s\n", date_s[0]);
				scf(dialog, temp, "ƒата разбана: %s\n", date_s[1]);
				return SPD(playerid, D_NONE, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_C" BAN. ¬ведите /q дл€ выхода.", dialog, "*", "");
			} else {
				RemoveBanList(Pl::Info[playerid][pID]);
			}
		}
		cache_delete(result);
	}
	return 0;
}

stock ShowPlayerBanList(adminid, pname[]) {
	new bandate, unbandate, bip[16], aname[24], reason[64], date_s[2][28];
	format(query, sizeof query, "SELECT (SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`user_id`),\
	(SELECT `Name` FROM `"#__TableUsers__"` WHERE `ID`=`admin_id`),\
	`ip`,`date`,`unbandate`,`reason` FROM `"#__TableBanned__"` WHERE `user_id`=(SELECT `ID` FROM `"#__TableUsers__"` WHERE BINARY `Name`='%s')", pname);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_get_row_count()) {
		cache_get_row(0, 1, aname);
		cache_get_row(0, 2, bip);
		cache_get_int(0, 3, bandate);
		cache_get_int(0, 4, unbandate);
		cache_get_row(0, 5, reason);

		to_timestamp(date_s[0], bandate, "%d-%m-%Y, %X");
		to_timestamp(date_s[1], unbandate, "%d-%m-%Y, %X");

		format(dialog, sizeof dialog, "* «абаненый %s\n\n", pname);
		scf(dialog, temp, "«абанил: %s\n", issqlnull(aname) ? ("System") : aname);
		scf(dialog, temp, "ѕричина: %s\n", reason);
		scf(dialog, temp, "—рок бана: %i дней\n", getday(unbandate, bandate));
		scf(dialog, temp, "ƒата бана: %s\n", date_s[0]);
		scf(dialog, temp, "ƒата разбана: %s\n\n", date_s[1]);
		SPD(adminid, D_BANLIST, 0, ""#__SERVER_PREFIX""#__SERVER_NAME_C" BANS.", dialog, "UNBAN", "OK");
		SetPVarString(adminid, "UnbanPlayer", pname);
	} else {
		Send(adminid, COLOR_GREY, "* Ётот игрок не забанен!");
	}
	cache_delete(result);
	return 1;
}

stock IsWrongWeponID(weponid)
{
	if(weponid <= 0) return true;
	for(new i; i < sizeof(wrongWeapon); i++) if(wrongWeapon[i] == weponid) return true;
	return false;
}

stock IsValidHouse(houseid) {
	return Iter::Contains(Houses, houseid);
}

stock IsPlayerHouseOwner(playerid, house) {
	if(IsValidHouse(house)) {
		return strcmp(GetName(playerid), HouseInfo[house][hOwner], false) == 0 ? 1 : 0;
	}
	return 0;
}

stock IsValidBiz(biz) {
	return Iter::Contains(Biznes, biz);
}

stock IsPlayerBizOwner(playerid, biz) {
	if(IsValidBiz(biz)) {
		return strcmp(GetName(playerid), BizzInfo[biz][bOwner], false) == 0 ? 1 : 0;
	}
	return 0;
}

stock IsPlayerBizExtortion(playerid, biz) {
	if(IsValidBiz(biz)) {
		return strcmp(GetName(playerid), BizzInfo[biz][bExtortion], false) == 0 ? 1 : 0;
	}
	return 0;
}

stock Jailed(playerid, jailtime, type = -1) {
	TempSkin[playerid] = GetPlayerSkin(playerid);
	SetPlayerSkin(playerid, GetJailedSkin(playerid));
	switch(type) {
	case 1 : {
			WantLawyer[playerid] = 1;
			Pl::Info[playerid][pJailed] = 1;
			Rac::SetPlayerInterior(playerid, 6);
			Rac::SetPlayerVirtualWorld(playerid, 1);
			Rac::SetPlayerPos(playerid,264.6288,77.5742,1001.0391);
		}
	case 2 : {
			Pl::Info[playerid][pJailed] = 2;
			Rac::SetPlayerInterior(playerid, 1);
			Rac::SetPlayerVirtualWorld(playerid, 1);
			Rac::SetPlayerPos(playerid, 1401.3,-15.5,1002.9);
			SetPlayerWorldBounds(playerid, 337.5694,101.5826,1940.9759,1798.7453);
		}
		default : {
			Pl::Info[playerid][pJailed] = 1;
			Rac::SetPlayerInterior(playerid, 6);
			Rac::SetPlayerVirtualWorld(playerid, 1);
			Rac::SetPlayerPos(playerid,264.6288,77.5742,1001.0391);
		}
	}
	Pl::SetWantedLevel(playerid, 0);
	Pl::Info[playerid][pJailTime] = jailtime;
	Pl::SetSpawnInfo(playerid);
	Rac::ResetPlayerWeapons(playerid);

	return;
}

stock Pl::SetWantedLevel(playerid, lvl) {
	lvl = (lvl > 6) ? (6) : (lvl < 0 ? 0 : lvl);
	Pl::Info[playerid][pWantedL] = lvl;
	if(lvl) Iter::Add(WantedPlayers, playerid); else Iter::Remove(WantedPlayers, playerid);
	return SetPlayerWantedLevel(playerid, Pl::Info[playerid][pWantedL]);
}

stock CarUpgrade(playerid, hid, newveh) {
	if(400 <= HouseInfo[hid][hvModel] <= 611) {
		ResetTuning(HouseInfo[hid][hAuto], 1, hid);
		HouseInfo[hid][hvModel] = newveh;
		AutoInfo[HouseInfo[hid][hAuto]][aMileage] = 0.0;
		Veh::Destroy(HouseInfo[hid][hAuto]);

		new veh = HouseInfo[hid][hAuto] = Veh::Create(
		HouseInfo[hid][hvModel],
		HouseInfo[hid][hvSpawn][0],
		HouseInfo[hid][hvSpawn][1],
		HouseInfo[hid][hvSpawn][2],
		HouseInfo[hid][hvSpawn][3],
		HouseInfo[hid][hvColor][0],
		HouseInfo[hid][hvColor][1],
		18000
		);

		AutoInfo[veh][aMileage] = AutoInfo[0][aMileage];
		SetVehicleNumber(veh);
		ToggleVehicleDoor(veh, false);
		AutoInfo[veh][aFuel] += 20.0;
		AutoInfo[veh][aOwner] = INVALID_PLAYER_ID * hid;
		if(HouseInfo[hid][hvPark] == HOME_VEHICLE) {
			SetVehicleVirtualWorld(veh, hid);
			LinkVehicleToInterior(veh, 3);
		}
	} else {
		if(IsValidVehicle(HouseInfo[hid][hAuto])) Veh::Destroy(HouseInfo[hid][hAuto]);
		GetPlayerPosEx(playerid, HouseInfo[hid][hvSpawn][0], HouseInfo[hid][hvSpawn][1], HouseInfo[hid][hvSpawn][2], HouseInfo[hid][hvSpawn][3]);
		HouseInfo[hid][hvModel] = newveh;
		new veh = HouseInfo[hid][hAuto] = Veh::Create(
		HouseInfo[hid][hvModel],
		HouseInfo[hid][hvSpawn][0],
		HouseInfo[hid][hvSpawn][1],
		HouseInfo[hid][hvSpawn][2],
		HouseInfo[hid][hvSpawn][3],
		HouseInfo[hid][hvColor][0],
		HouseInfo[hid][hvColor][1],
		18000
		);
		AutoInfo[veh][aMileage] = 0.0;
		SetVehicleNumber(HouseInfo[hid][hAuto]);
		ToggleVehicleDoor(veh, false);
		AutoInfo[veh][aFuel] += 20.0;
		AutoInfo[veh][aOwner] = INVALID_PLAYER_ID * hid;
		if(IsPlayerInHouseGarage(playerid)) {
			HouseInfo[hid][hvPark] = HOME_VEHICLE;
			SetVehicleVirtualWorld(veh, hid);
			LinkVehicleToInterior(veh, 3);
		}
	}
	return 1;
}

stock Pl::SetSpawnInfo(playerid) {
	new i;
	if(Pl::Info[playerid][pJailed]) {
		switch(Pl::Info[playerid][pJailed]) {
		case 1: {
				SetSpawnInfo(
				playerid,
				1,
				GetJailedSkin(playerid),
				264.6288,
				77.5742,
				1001.0391,
				0.0, 0, 0, 0, 0, 0, 0
				);
			}
		case 2 : {
				SetSpawnInfo(
				playerid,
				1,
				GetJailedSkin(playerid),
				1413.5350,
				-28.7661,
				1000.9248,
				90.5306,
				0, 0, 0, 0, 0, 0
				);
			}
		}

		return ;
	}

	i = Pl::Info[playerid][pHouseKey];
	if(IsValidHouse(i) && !SpawnChange[playerid]) {
		SetSpawnInfo(
		playerid,
		1,
		Pl::Info[playerid][pChar],
		HouseInfo[i][hExit][0],
		HouseInfo[i][hExit][1],
		HouseInfo[i][hExit][2],
		HouseInfo[i][hExit][3],
		0, 0, 0, 0, 0, 0
		);
	} else {
		i = Pl::FracID(playerid);
		if(IsValidFrac(i)) {
			SetSpawnInfo(
			playerid,
			1,
			Pl::Info[playerid][pChar],
			FracInfo[i][fSpawn][fSpawnPos][0],
			FracInfo[i][fSpawn][fSpawnPos][1],
			FracInfo[i][fSpawn][fSpawnPos][2],
			FracInfo[i][fSpawn][fSpawnPos][3],
			0, 0, 0, 0, 0, 0
			);
		} else {
			i = Pl::Info[playerid][pOrigin];
			if(1 <= i < sizeof SpawnInfo) {
				SetSpawnInfo(
				playerid,
				1,
				Pl::Info[playerid][pChar],
				SpawnInfo[i][spX],
				SpawnInfo[i][spY],
				SpawnInfo[i][spZ],
				SpawnInfo[i][spA],
				0, 0, 0, 0, 0, 0
				);
			} else {
				SetSpawnInfo(
				playerid,
				1,
				Pl::Info[playerid][pChar],
				SpawnInfo[1][spX],
				SpawnInfo[1][spY],
				SpawnInfo[1][spZ],
				SpawnInfo[1][spA],
				0, 0, 0, 0, 0, 0
				);
			}
		}
	}
}

stock GetIDFromName(playername[]) {
	new id = -1;
	format(query, sizeof query, "SELECT `ID` FROM `"#__TableUsers__"` WHERE BINARY `Name` = '%s'", playername);
	new Cache:result = Db::query(connDb, query, true);
	if(cache_get_row_count()) {
		cache_get_int(0, 0, id);
	}
	cache_delete(result);
	return id;
}

stock OnPlayerPickupExit(playerid) {
	if(PickupInfo[playerid][pDelay] != 0) PickupInfo[playerid][pDelay] --;
	else if(PickupInfo[playerid][pOld] != -1) {
		if(!IsPlayerInRangeOfPoint(playerid, 1.5, PickupInfo[playerid][pOldPos][0], PickupInfo[playerid][pOldPos][1], PickupInfo[playerid][pOldPos][2])) {
			PickupInfo[playerid][pOld] = -1;
		}
	}
	return 1;
}

stock IsPlayerInHouse(playerid, Float:radi = 5.0, houseid) {
	return (IsPlayerInRangeOfPoint(playerid, radi, HouseInfo[houseid][hExit][0], HouseInfo[houseid][hExit][1], HouseInfo[houseid][hExit][2]) && Pl::Info[playerid][pLocal] == (OFFSET_HOUSE + houseid));
}

stock IsPlayerInBiz(playerid, Float:radi = 5.0, bizid) {
	new id = GetIndexFromBizID(bizid);
	if(id != -1) {
		return (IsPlayerInRangeOfPoint(playerid, radi, BizzInfo[id][bExit][0], BizzInfo[id][bExit][1], BizzInfo[id][bExit][2]) && Pl::Info[playerid][pLocal] == (OFFSET_BIZZ + id));
	}
	return 0;
}


public OnQueryError(errorid, error[], callback[], querystr[], connectionHandle) {
	switch(errorid) {
	case CR_SERVER_LOST : {
			Db::reconnect(connectionHandle);
			Db::FixCharset();
			if(strfind(querystr, "UPDATE", true) != -1) Db::tquery(connDb, querystr, "", "");
			return 1;
		}
	}

	format(temp, sizeof temp, "(SQL) Query error! ( eID: %i; callback: %s )", errorid, callback),
	SendToAdmin(COLOR_LIGHTBLUE, temp, 4, 5);
	format(temp, sizeof temp, "(SQL) Error: %s", error),
	SendToAdmin(COLOR_LIGHTBLUE, temp, 4, 5);

	SendLog(LOG_MYSQL_ERROR,	querystr);
	DEBUG[TOTAL_QUERY_ERRORS]++;
	return 1;
}

stock AddPickup(model, type, Float:x, Float:y, Float:z, vw = -1, text[] = " ", color = 0xFFFFFFFF, Float:offsetX = 0.0, Float:offsetY = 0.0, Float:offsetZ = 0.6) {
	if(text[0] != ' ') {
		offsetX += x;
		offsetY += y;
		offsetZ += z;

		Add3DText(text, color, offsetX, offsetY, offsetZ, 40.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, vw);
	}
	return CreateDynamicPickup(model, type, x, y, z, vw);
}

stock _AddPickup(model, type, Float:pos[], vw = -1, text[] = " ", color = 0xFFFFFFFF, Float:offset[] = {0.0,0.0,0.6}) {
	if(text[0] != ' ') {
		offset[0] += pos[0];
		offset[1] += pos[1];
		offset[2] += pos[2];

		Add3DText(text, color, offset[0], offset[2], offset[3], 40.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, vw);
	}

	return CreateDynamicPickup(model, type, pos[0], pos[1], pos[2], vw);
}

stock Veh::Init() {
	comptruck[0] = Veh::Create(456,2747.96093750,-2470.80297852,13.89799976,270.00000000,-1,-1,600); // Component Truck <!-- Yankee -->
	Veh::Create(456,2747.80908203,-2461.05297852,13.89799976,270.00000000,-1,-1,600); // Component Truck <!-- Yankee -->
	Veh::Create(440,2748.37597656,-2440.50805664,13.85599995,270.00000000,-1,-1,600); // Component Truck <!-- Rumpo -->
	Veh::Create(440,2748.32617188,-2446.39843750,13.86100006,270.00000000,-1,-1,600); // Component Truck <!-- Rumpo -->
	Veh::Create(440,-1885.72399902,-193.76400757,18.60899925,270.00000000,-1,-1,600); // Component Truck <!-- Rumpo -->
	Veh::Create(440,-1885.72204590,-188.01600647,18.60899925,270.00000000,-1,-1,600); // Component Truck <!-- Rumpo -->
	Veh::Create(440,-1885.65002441,-182.01899719,18.60899925,270.00000000,-1,-1,600); // Component Truck <!-- Rumpo -->
	comptruck[1] = Veh::Create(456,-1851.85900879,-190.76899719,18.62500000,180.00000000,-1,-1,600); // Component Truck <!-- Yankee -->

	Veh::Create(591,0.66930000,-377.47270000,6.08020000,1.84030000,-1,-1,600); //Trailer 3
	Veh::Create(435,-6.37590000,-377.50960000,6.03120000,1.82230000,-1,-1,600); //Trailer 1
	Veh::Create(591,-13.11540000,-377.66600000,6.09380000,358.75850000,-1,-1,600); //Trailer 3
	Veh::Create(435,-19.57920000,-377.77120000,6.07290000,359.77210000,-1,-1,600); //Trailer 1
	Veh::Create(591,-32.75900000,-377.77610000,6.06800000,2.68620000,-1,-1,600); //Trailer 3
	Veh::Create(450,-43.65100098,-1153.68395996,1.73199999,334.00000000,-1,-1,600); //Trailer 2
	Veh::Create(591,-49.62799835,-1150.57702637,1.73199999,334.00000000,-1,-1,600); //Trailer 3
	Veh::Create(435,-55.85300064,-1147.68005371,1.73199999,334.00000000,-1,-1,600); //Trailer 1
	Veh::Create(435,-63.07899857,-1144.43505859,1.73199999,334.00000000,-1,-1,600); //Trailer 1
	Veh::Create(435,-26.51590000,-377.77090000,6.10030000,2.00990000,-1,-1,600); //Trailer 1

	PlayerHaul[0][pCapasity] = 150;
	PlayerHaul[1][pCapasity] = 150;
	PlayerHaul[2][pCapasity] = 100;
	PlayerHaul[3][pCapasity] = 100;
	PlayerHaul[4][pCapasity] = 50;
	PlayerHaul[5][pCapasity] = 50;
	PlayerHaul[6][pCapasity] = 50;
	PlayerHaul[7][pCapasity] = 150;

	new vehicles;
	for(new i; i++ < MAX_VEHICLES;) {
		if(IsValidVehicle(i)) vehicles ++;
	}

	return debug("Veh::Init() - Ok! Vehicles: %i", vehicles);
}

stock Area::Init() {
	Area::ASH = CreateDynamicSphere(-2027.1951, -114.5949, 1035.1719, 30.0, 1);
	Area::Shamal = CreateDynamicSphere(1.8050, 23.2547, 1199.5938, 25.0);
	Area::poppyField = CreateDynamicRectangle(-1199.7,-1065.9,-1002.0,-909.5, 0, 0, 0);
	Area::jailField = CreateDynamicRectangle(264.2168+3.0, 264.2168-34.0, 77.5795+3.0, 77.5795-3.0);

	return debug("Area::Init() - Ok! Areas: %i", CountDynamicAreas());
}

stock Obj::Init() {
	map::Load("maps/int_ambulance.map");		// »Ќ“≈–№≈– ¬ ћјЎ»Ќ≈ AMBULANCE
	map::Load("maps/cleaners.map");				// ”Ѕќ–ў» » ”Ћ»÷
	map::Load("maps/resp_cnn.map");				// –≈—ѕј –≈ѕј–“≈–ќ¬
	//	map::Load("maps/bar_in_pirce.map");			// Ѕј– Ќј ѕ»–—≈
	//	map::Load("maps/alhambra.map",11);			// ALHAMBRA
	map::Load("maps/autovokzal.map");			// ј¬“ќ¬ќ «јЋ
	map::Load("maps/int_shamal.map");			// »Ќ“≈–№≈– ЎјћјЋј
	map::Load("maps/lspd.map");					// Ѕј«ј ѕќЋ»÷»»
	//map::Load("maps/aircraft_carrier.map");		// ј¬»јЌќ—≈÷
	map::Load("maps/church.map",Bizz_Church);	// ÷≈– ќ¬№
	map::Load("maps/bomjatnik.map");			// Ѕќћ∆ј“Ќ» 
	//map::Load("maps/db_pereezd.map");			// Ѕƒ, ѕ≈–≈≈«ƒ
	map::Load("maps/fbi.map");					// ‘Ѕ–
	//map::Load("maps/autoshool.map");			// ј¬“ќЎ ќЋј
	map::Load("maps/mapping.map");				// ћјѕѕ»Ќ√ ѕќ Ў“ј“”
	map::Load("maps/sfmc_map.map");				// ћ≈ƒ≈ »
	map::Load("maps/sd_object.map");			// SD объекты
	map::Load("maps/vagos_object.map");			// ¬агос забор
	map::Load("maps/lcn_object.map");			// La Cosa Nostra
	map::Load("maps/rm_objects.map");			// RM
	map::Load("maps/sfpd_objects.map");			// LSPD & SFPD
	map::Load("maps/fermers_objects.map");		//  олхоз забор
	map::Load("maps/gov_objects.map");			// ћэри€ объекты
	map::Load("maps/cor_objects.map");			// Coronos объекты
	map::Load("maps/otel_ls.map");				// ќтель Ћ—
	map::Load("maps/grove_objects.map");		// Groove объекты
	map::Load("maps/factory.map");				// «авод —‘ (маппинг с наруже)
	// ¬орота
	housegate = CreateObject(11319,1643.5996094,-1714.9765625,16.1000004,0.0000000,0.0000000,0.0000000); // замени housegate на свою + координаты «ј –џ“џ’ ворот
	arvorota = CreateObject(2933, -1530.31, 482.44, 7.88,   0.00, 0.00, 0.00);
	armygate[0] = CreateObject(968, -1545.10, 506.38, 6.94,   0.00, 90.00, 84.00);
	armygate[1] = CreateObject(968, -1543.65, 515.57, 6.94,   0.00, 90.00, 84.00);
	licgate = CreateObject(968,-2050.3899, -80.0900, 35.0000, 0.0000, 90.0000, 0.0000);
	// јммо
    CreateObject(16769,2378.0996100,-1641.3994100,12.5000000,0.0000000,0.0000000,0.0000000); //object(desn2_ammun04) (1)
	CreateObject(1557,2375.1001000,-1648.9000200,12.5000000,0.0000000,0.0000000,0.0000000); //object(gen_doorext19) (1)
	CreateObject(3648,2394.3000500,-1641.0000000,15.2000000,0.0000000,0.0000000,90.0000000); //object(ganghous02_lax) (1)
	CreateObject(16387,1003.7999900,-1166.6999500,22.8000000,0.0000000,0.0000000,180.0000000); //object(desn2_ammun) (1)
	CreateObject(1557,1005.2999900,-1159.1999500,22.9000000,0.0000000,0.0000000,0.0000000); //object(gen_doorext19) (2)
	CreateObject(956,1012.2000100,-1158.8000500,22.8000000,0.0000000,0.0000000,182.0000000); //object(cj_ext_candy) (1)
	CreateObject(1209,2048.0000000,-1136.5999800,42.6000000,0.0000000,0.0000000,0.0000000); //object(vendmach) (1)
	CreateObject(1209,1990.4000200,-1066.0999800,23.6000000,0.0000000,0.0000000,158.0000000); //object(vendmach) (2)
	CreateObject(1302,2385.1001000,-1649.1999500,12.5000000,0.0000000,0.0000000,0.0000000); //object(vendmachfd) (1)
	// «абор у Ћ—ѕƒ
	CreateObject(16769,2378.0996100,-1641.3994100,12.5000000,0.0000000,0.0000000,0.0000000); //object(desn2_ammun04) (1)
	CreateObject(1557,2375.1001000,-1648.9000200,12.5000000,0.0000000,0.0000000,0.0000000); //object(gen_doorext19) (1)
	CreateObject(3648,2394.3000500,-1641.0000000,15.2000000,0.0000000,0.0000000,90.0000000); //object(ganghous02_lax) (1)
	CreateObject(16387,1003.7999900,-1166.6999500,22.8000000,0.0000000,0.0000000,180.0000000); //object(desn2_ammun) (1)
	CreateObject(1557,1005.2999900,-1159.1999500,22.9000000,0.0000000,0.0000000,0.0000000); //object(gen_doorext19) (2)
	CreateObject(956,1012.2000100,-1158.8000500,22.8000000,0.0000000,0.0000000,182.0000000); //object(cj_ext_candy) (1)
	CreateObject(1209,2048.0000000,-1136.5999800,42.6000000,0.0000000,0.0000000,0.0000000); //object(vendmach) (1)
	CreateObject(1209,1990.4000200,-1066.0999800,23.6000000,0.0000000,0.0000000,158.0000000); //object(vendmach) (2)
	CreateObject(1302,2385.1001000,-1649.1999500,12.5000000,0.0000000,0.0000000,0.0000000); //object(vendmachfd) (1)
	CreateObject(983,1539.5999800,-1619.5000000,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (1)
	CreateObject(984,1546.0000000,-1622.6999500,13.2000000,0.0000000,0.0000000,90.0000000); //object(fenceshit2) (1)
	CreateObject(984,1558.8000500,-1622.6999500,13.2000000,0.0000000,0.0000000,90.0000000); //object(fenceshit2) (2)
	CreateObject(984,1562.0000000,-1622.6999500,13.2000000,0.0000000,0.0000000,90.0000000); //object(fenceshit2) (3)
	CreateObject(984,1556.0000000,-1617.6999500,13.2000000,0.0000000,0.0000000,270.0000000); //object(fenceshit2) (4)
	CreateObject(984,1562.4000200,-1617.6999500,13.2000000,0.0000000,0.0000000,270.0000000); //object(fenceshit2) (5)
	CreateObject(672,1542.8000500,-1619.9000200,12.6000000,0.0000000,0.0000000,0.0000000); //object(sm_veg_tree5) (1)
	CreateObject(984,1534.5999800,-1644.5999800,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit2) (6)
	CreateObject(984,1534.5999800,-1657.4000200,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit2) (7)
	CreateObject(982,1534.5999800,-1694.4000200,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit) (1)
	CreateObject(983,1534.5999800,-1710.4000200,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (2)
	CreateObject(983,1534.6999500,-1716.9000200,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (3)
	CreateObject(983,1537.5999800,-1667.1999500,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (4)
	CreateObject(983,1537.5999800,-1673.5999800,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (5)
	CreateObject(983,1537.5999800,-1678.3000500,13.2000000,0.0000000,0.0000000,0.0000000); //object(fenceshit3) (6)
	CreateObject(1215,1536.9000200,-1663.5000000,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (1)
	CreateObject(1215,1535.6999500,-1663.5000000,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (2)
	CreateObject(1215,1536.9000200,-1681.9000200,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (3)
	CreateObject(1215,1535.5000000,-1681.9000200,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (4)
	CreateObject(1215,1537.1999500,-1714.4000200,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (5)
	CreateObject(1215,1537.1999500,-1640.1999500,13.1000000,0.0000000,0.0000000,0.0000000); //object(bollardlight) (6)
	// ћэри€ в Ћ—
	CreateObject(987,2101.8000000,-1450.7000000,22.9000000,0.0000000,0.0000000,90.0000000); //object(elecfence_bar) (1)
	CreateObject(987,2101.8999000,-1438.7000000,23.0000000,0.0000000,0.0000000,180.0000000); //object(elecfence_bar) (2)
	CreateObject(987,2009.2000000,-1351.6000000,23.0000000,0.0000000,0.0000000,180.0000000); //object(elecfence_bar) (3)
	CreateObject(987,2009.5000000,-1363.5000000,23.0000000,0.0000000,0.0000000,91.9950000); //object(elecfence_bar) (4)
	CreateObject(3881,2002.4000000,-1441.9000000,14.4000000,0.0000000,0.0000000,46.0000000); //object(airsecbooth_sfse) (1)
	CreateObject(717,1997.9000000,-1440.3000000,11.9000000,0.0000000,0.0000000,0.0000000); //object(sm_bevhiltreepv) (1)
	CreateObject(717,2008.1000000,-1450.3000000,11.9000000,0.0000000,0.0000000,0.0000000); //object(sm_bevhiltreepv) (2)
	CreateObject(1337,1977.4765600,-1438.8465600,13.2995800,0.0000000,0.0000000,0.0000000); //object(binnt07_la) (1)
    CreateObject(980,2003.9000000,-1446.2000000,13.4000000,0.0000000,0.0000000,136.0000000); //object(airportgate) (1)
	// ћэри€ в Ћ¬/—‘
	CreateObject(8651,2251.9004000,2506.2002000,2.1000000,0.0000000,0.0000000,0.0000000); //object(shbbyhswall07_lvs) (1)
	CreateObject(8651,2251.9004000,2507.1006000,3.9000000,0.0000000,0.0000000,0.0000000); //object(shbbyhswall07_lvs) (2)
	CreateObject(8651,2251.9004000,2506.7002000,5.9000000,0.0000000,0.0000000,0.0000000); //object(shbbyhswall07_lvs) (3)
	CreateObject(8651,2251.8999000,2506.2000000,7.9000000,0.0000000,0.0000000,0.0000000); //object(shbbyhswall07_lvs) (3)
	CreateObject(910,2295.0000000,2496.7000000,3.5000000,0.0000000,0.0000000,80.0000000); //object(bust_cabinet_4) (1)
	CreateObject(980,2334.2000000,2443.2000000,7.3000000,0.0000000,0.0000000,60.0000000); //object(airportgate) (1)
	CreateObject(3851,2335.0000000,2443.5000000,6.0000000,0.0000000,0.0000000,330.0000000); //object(carshowwin_sfsx) (1)
	CreateObject(3851,2334.7000000,2443.1001000,10.0000000,0.0000000,0.0000000,330.0000000); //object(carshowwin_sfsx) (2)
	CreateObject(8651,2293.3999000,2506.5000000,2.9000000,0.0000000,0.0000000,182.0000000); //object(shbbyhswall07_lvs) (1)
	CreateObject(8651,2293.3999000,2506.3999000,4.9000000,0.0000000,0.0000000,182.0000000); //object(shbbyhswall07_lvs) (1)
	CreateObject(8651,2293.3999000,2507.3999000,6.9000000,0.0000000,0.0000000,182.0000000); //object(shbbyhswall07_lvs) (1)
	CreateObject(970,2415.3999000,1119.3000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (1)
	CreateObject(970,2415.5000000,1128.5000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (2)
	CreateObject(970,2417.5000000,1117.2000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (3)
	CreateObject(970,2417.5000000,1113.1000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (4)
	CreateObject(970,2415.3999000,1111.0000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (6)
	CreateObject(970,2415.3999000,1104.1000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (7)
	CreateObject(970,2415.3999000,1095.7000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (5)
	CreateObject(970,2417.5000000,1097.8000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (8)
	CreateObject(970,2417.5000000,1102.0000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (9)
	CreateObject(970,2417.6001000,1130.6000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (10)
	CreateObject(970,2417.6001000,1134.8000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (11)
	CreateObject(970,2417.6001000,1139.0000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (12)
	CreateObject(970,2417.6001000,1143.2000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (13)
	CreateObject(970,2417.6001000,1147.4000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (14)
	CreateObject(970,2417.6001000,1151.6000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (15)
	CreateObject(970,2417.6001000,1155.8000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (16)
	CreateObject(970,2417.6001000,1160.0000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (18)
	CreateObject(970,2417.6001000,1164.2000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (17)
	CreateObject(970,2417.6001000,1168.4000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (19)
	CreateObject(970,2417.6001000,1172.6000000,10.4000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (20)
	CreateObject(970,2415.5000000,1174.6000000,10.4000000,0.0000000,0.0000000,0.0000000); //object(fencesmallb) (21)
	CreateObject(1364,2418.3000000,1123.7000000,10.6000000,0.0000000,0.0000000,90.0000000); //object(cj_bush_prop) (1)
	CreateObject(640,2415.6001000,1132.1000000,10.5000000,0.0000000,0.0000000,180.0000000); //object(kb_planter_bush2) (1)
	CreateObject(640,2415.6001000,1138.3000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (2)
	CreateObject(640,2415.6001000,1144.6000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (3)
	CreateObject(640,2415.6001000,1150.8000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (4)
	CreateObject(640,2415.6001000,1157.0000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (5)
	CreateObject(640,2415.6001000,1163.3000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (6)
	CreateObject(640,2415.6001000,1169.4000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (7)
	CreateObject(640,2415.2000000,1115.2000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (8)
	CreateObject(640,2415.2000000,1099.9000000,10.5000000,0.0000000,0.0000000,179.9950000); //object(kb_planter_bush2) (9)
	CreateObject(11319,2412.1001000,1107.5000000,11.0000000,0.0000000,0.0000000,0.0000000); //object(sprayshpdr2_sfse) (1)
	CreateObject(1339,2412.7000000,1111.3000000,10.5000000,0.0000000,0.0000000,0.0000000); //object(binnt09_la) (1)
	CreateObject(1339,2412.8000000,1103.8000000,10.5000000,0.0000000,0.0000000,178.0000000); //object(binnt09_la) (2)
	CreateObject(1339,2412.7000000,1127.7000000,10.5000000,0.0000000,0.0000000,0.0000000); //object(binnt09_la) (3)
	CreateObject(1339,2412.8000000,1120.0000000,10.5000000,0.0000000,0.0000000,177.9950000); //object(binnt09_la) (4)
	CreateObject(970,-2016.6000000,489.1000100,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (22)
	CreateObject(970,-2016.6000000,484.8999900,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (23)
	CreateObject(970,-2016.6000000,480.7000100,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (24)
	CreateObject(970,-2016.6000000,476.5000000,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (25)
	CreateObject(970,-2016.6000000,472.2999900,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (26)
	CreateObject(970,-2016.6000000,468.1000100,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (27)
	CreateObject(970,-2016.6000000,463.8999900,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (28)
	CreateObject(970,-2016.6000000,459.7000100,34.7000000,0.0000000,0.0000000,270.0000000); //object(fencesmallb) (29)
	CreateObject(970,-2016.8000000,455.5000000,34.7000000,0.0000000,0.0000000,264.0000000); //object(fencesmallb) (30)
	CreateObject(970,-2021.7000000,494.2999900,34.7000000,0.0000000,0.0000000,180.0000000); //object(fencesmallb) (31)
	CreateObject(970,-2025.9000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (32)
	CreateObject(970,-2030.1000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (33)
	CreateObject(970,-2034.3000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (34)
	CreateObject(970,-2038.5000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (35)
	CreateObject(970,-2042.7000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (36)
	CreateObject(970,-2046.9000000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (37)
	CreateObject(970,-2051.1001000,494.2999900,34.7000000,0.0000000,0.0000000,179.9950000); //object(fencesmallb) (38)
	CreateObject(970,-2055.3000000,494.2000100,34.7000000,0.0000000,0.0000000,183.9950000); //object(fencesmallb) (39)
	CreateObject(717,-2016.8000000,491.2000100,34.2000000,0.0000000,0.0000000,0.0000000); //object(sm_bevhiltreepv) (1)
	CreateObject(717,-2019.7000000,494.1000100,34.2000000,0.0000000,0.0000000,0.0000000); //object(sm_bevhiltreepv) (2)
	CreateObject(11319,-2066.2000000,493.0000000,35.1000000,0.0000000,0.0000000,90.0000000); //object(sprayshpdr2_sfse) (2)
	// јвтоЎколаGW
	AddObject(6134, -2043.7000, -100.6000, 38.2000, 0.0000, 0.0000, 180.0000); // object (38)
	AddObject(19425, -2050.5000, -79.3300, 34.1700, 0.0000, 0.0000, 0.0000); // object (54)
	AddObject(966, -2050.3999, -80.1000, 34.1000, 0.0000, 0.0000, 179.9900); // object (56)
	AddObject (640, -2057.5000, -84.3000, 35.0000, 0.0000, 0.0000, 0.0000); // object (59)
	AddObject(19425, -2043.8400, -79.3300, 34.1600, 0.0000, 0.0000, 0.0000); // object (60)
	AddObject(982, -2065.1001, -80.4000, 36.4000, 0.0000, 0.0000, 90.0000); // object (61)
	AddObject(967, -2051.3999, -81.2200, 34.0400, 0.0000, 0.0000, 270.0000); // object (57)
	AddObject(19425, -2047.1600, -79.3300, 34.1700, 0.0800, 0.0000, 0.0000); // object (58)
	AddObject(649339, -2065.3000, -80.4000, 35.0000, 0.0000, 0.0000, 90.0000); // object (62)
	AddObject(19076, -2057.3601, -90.4600, 33.4000, 0.0000, 0.0000, 0.0000); // object (63)
	AddObject(640, -2037.8000, -84.0000, 35.0000, 0.0000, 0.0000, 0.0000); // object (64)
	AddObject(870, -2035.2000, -85.5000, 34.8000, 0.0000, 0.0000, 0.0000); // object (65)
	AddObject(870, -2033.9000, -83.1000, 34.8000, 0.0000, 0.0000, 0.0000); // object (66)
	AddObject(1231, -2037.1000, -90.5000, 37.1000, 0.0000, 0.0000, 0.0000); // object (67)
	AddObject(870, -2032.1000, -85.7000, 34.8000, 0.0000, 0.0000, 0.0000); // object (68)
	AddObject(870, -2031.1000, -82.7000, 34.8000, 0.0000, 0.0000, 0.0000); // object (69)
	AddObject(9339, -2030.0000, -80.1000, 35.0000, 0.0000, 0.0000, 90.0000); // object (70)
	AddObject(982, -2029.9000, -80.1000, 36.4000, 0.0000, 0.0000, 90.0000); // object (71)
	AddObject(1257, -2028.5699, -78.8900, 35.5400, 0.0000, 0.0000, -90.0000); // object (72)
	AddObject(1569, -2061.8496, -102.2378, 34.1618, 0.0000, 0.0000, 90.2000); // object (73)
	AddObject(745, -2028.4000, -83.5000, 34.5000, 0.0000, 0.0000, 230.0000); // object (74)
	AddObject(18720, -2028.1000, -83.9100, 38.7600, 0.0000, 0.0000, 0.0000); // object (75)
	AddObject(9833, -2027.8000, -83.8000, 31.3000, 0.0000, 0.0000, 0.0000); // object (76)
	AddObject(745, -2026.1000, -83.7000, 34.4000, 0.0000, 0.0000, 100.0000); // object (77)
	AddObject(982, -2029.9803, -59.8073, 35.0054, 0.0000, 0.0000, 268.0052); // object (78)
	AddObject(870, -2023.8000, -82.7000, 34.8000, 0.0000, 0.0000, 0.0000); // object (79)
	AddObject(9339, -2084.6001, -80.4000, 35.0000, 0.0000, 0.0000, 90.0000); // object (81)
	AddObject(10183, -2077.3000, -98.4000, 34.2000, 0.0000, 0.0000, 226.0000); // object (82)
	AddObject(870, -2022.9000, -85.4000, 34.8000, 0.0000, 0.0000, 0.0000); // object (83)
	AddObject(10245, -2071.8999, -105.6000, 36.3000, 0.0000, 0.0000, 44.0000); // object (84)
	AddObject(870, -2020.8000, -82.9000, 34.8000, 0.0000, 0.0000, 0.0000); // object (85)
	AddObject(982, -2087.5000, -80.4000, 36.4000, 0.0000, 0.0000, 90.0000); // object (86)
	AddObject(1231, -2022.5000, -90.5000, 37.1000, 0.0000, 0.0000, 0.0000); // object (87)
	AddObject(870, -2020.0000, -85.5000, 34.8000, 0.0000, 0.0000, 0.0000); // object (88)
	AddObject(984, -2017.1000, -86.5000, 36.3000, 0.0000, 0.0000, 0.0000); // object (89)
	AddObject(9339, -2017.1000, -93.3000, 35.0000, 0.0000, 0.0000, 0.0000); // object (90)
	AddObject(1215, -2056.2251, -117.9260, 34.8790, 0.0000, 0.0000, 0.0000); // object (91)
	AddObject(1215, -2047.0870, -118.0710, 34.8050, 0.0000, 0.0000, 0.0000); // object (92)
	AddObject(984, -2017.1000, -96.1000, 36.3000, 0.0000, 0.0000, 0.0000); // object (93)
	AddObject(1215, -2038.1410, -118.0930, 34.7470, 0.0000, 0.0000, 0.0000); // object (94)
	AddObject(982, -2017.8386, -45.0887, 35.0079, 0.0000, 0.0000, 2.4993); // object (95)
	AddObject(1238, -2041.0081, -149.0200, 34.6400, 0.0000, 0.0000, 0.0000); // object (97)
	AddObject(1238, -2073.1799, -147.9700, 34.6400, 0.0000, 0.0000, 0.0000); // object (98)
	AddObject(19425, -2075.1101, -147.9700, 34.3200, 0.0000, 0.0000, 0.0000); // object (99)
	AddObject(1238, -2076.9700, -147.9700, 34.6400, 0.0000, 0.0000, 0.0000); // object (100)
	AddObject(1238, -2072.9399, -152.7400, 34.6400, 0.0000, 0.0000, 0.0000); // object (101)
	AddObject(1238, -2077.0400, -152.7400, 34.6400, 0.0000, 0.0000, 0.0000); // object (103)
	AddObject(1238, -2080.5601, -152.7400, 34.6400, 0.0000, 0.0000, 0.0000); // object (104)
	AddObject(1238, -2041.0500, -157.5200, 34.6400, 0.0000, 0.0000, 0.0000); // object (105)
	AddObject(1238, -2080.5601, -157.6000, 34.6400, 0.0000, 0.0000, 0.0000); // object (106)
	AddObject(1238, -2033.6140, -160.1230, 34.6380, 0.0000, 0.0000, 0.0000); // object (107)
	AddObject(19425, -2031.0480, -160.1290, 34.3270, 0.0000, 0.0000, 1.9995); // object (108)
	AddObject(1238, -2072.5601, -161.5400, 34.6400, 0.0000, 0.0000, 0.0000); // object (109)
	AddObject(1238, -2028.6030, -160.1230, 34.6460, 0.0000, 0.0000, 0.0000); // object (110)
	AddObject(1238, -2077.0801, -161.5400, 34.6400, 0.0000, 0.0000, 0.0000); // object (111)
	AddObject(19467, -2026.2960, -160.3560, 34.1870, 311.9952, 0.0000, 180.7472); // object (112)
	AddObject(1238, -2023.8210, -160.1230, 34.6380, 0.0000, 0.0000, 0.0000); // object (113)
	AddObject(1238, -2080.5601, -161.5400, 34.6400, 0.0000, 0.0000, 0.0000); // object (114)
	AddObject(1238, -2041.0520, -165.4300, 34.6000, 0.0000, 0.0000, 0.0000); // object (115)
	AddObject(1238, -2072.5596, -166.3193, 34.6400, 0.0000, 0.0000, 0.0000); // object (116)
	AddObject(1238, -2033.6140, -166.7620, 34.6460, 0.0000, 0.0000, 0.0000); // object (117)
	AddObject(19467, -2075.0898, -166.5498, 34.2600, 311.9952, 0.0000, 0.2472); // object (118)
	AddObject(1238, -2077.0801, -166.3700, 34.6400, 0.0000, 0.0000, 0.0000); // object (119)
	AddObject(19425, -2056.7598, -171.4092, 34.3400, 0.0000, 0.0000, 1.9995); // object (120)
	AddObject(1238, -2023.8210, -166.9190, 34.6380, 0.0000, 0.0000, 0.0000); // object (121)
	AddObject(19467, -2055.4299, -173.5700, 34.9900, 359.9900, 345.7500, 272.2400); // object (122)
	AddObject(19467, -2057.1899, -173.7100, 34.9900, 360.0000, 345.7500, 272.2500); // object (123)
	AddObject(1238, -2041.0760, -173.6340, 34.6200, 0.0000, 0.0000, 0.0000); // object (124)
	AddObject(1238, -2033.6140, -173.3000, 34.6380, 0.0000, 0.0000, 0.0000); // object (125)
	AddObject(1238, -2054.7300, -176.0900, 35.8800, 0.0000, 0.0000, 0.0000); // object (126)
	AddObject(1238, -2058.2000, -176.2100, 35.8800, 0.0000, 0.0000, 0.0000); // object (127)
	AddObject(1238, -2028.6030, -173.3000, 34.6380, 0.0000, 0.0000, 0.0000); // object (128)
	AddObject(1238, -2023.8210, -173.3000, 34.6380, 0.0000, 0.0000, 0.0000); // object (129)
	AddObject(1238, -2054.6299, -180.1500, 35.8800, 0.0000, 0.0000, 0.0000); // object (130)
	AddObject(1238, -2057.9800, -180.3000, 35.8800, 0.0000, 0.0000, 0.0000); // object (131)
	AddObject(3406, -2055.3000, -180.6600, 33.4900, 0.0000, 0.0000, 272.0000); // object (132)
	AddObject(3406, -2057.3000, -180.7500, 33.4900, 0.0000, 0.0000, 272.0000); // object (133)
	AddObject(19425, -2056.2400, -181.2400, 35.5600, 0.0000, 0.0000, 2.0000); // object (134)
	AddObject(1238, -2041.1281, -182.0490, 34.7700, 0.0000, 0.0000, 0.0000); // object (135)
	AddObject(1238, -2054.3301, -184.1800, 35.8800, 0.0000, 0.0000, 0.0000); // object (136)
	AddObject(1238, -2057.8799, -184.4000, 35.8800, 0.0000, 0.0000, 0.0000); // object (137)
	AddObject(19467, -2055.6899, -186.7600, 34.9900, 359.9900, 345.7500, 92.2400); // object (138)
	AddObject(19467, -2057.3401, -186.8000, 35.0000, 359.9900, 345.7400, 92.2400); // object (139)
	AddObject(19425, -2056.1899, -189.1000, 34.3900, 0.0000, 0.0000, 2.0000); // object (140)
	AddObject(19076, -2116.6799, -212.1800, 34.3200, 0.0000, 0.0000, 0.0000); // object (141)
	AddObject(10184, -2221.1631, -118.1000, 36.7903, 0.0000, 0.0000, 270.0000); // object (142)
	AddObject(10575, -2028.1000, -280.4000, 36.3000, 0.0000, 0.0000, 270.0000); // object (143)
	AddObject(10575, -2028.2000, -281.4000, 36.5000, 0.0000, 0.0000, 90.0000); // object (144)
	AddObject(1536, -2270.1599, -126.4600, 34.3000, 0.0000, 0.0000, 270.0000); // object (145)
	AddObject(16387, -2277.6499, -124.9600, 34.3000, 0.0000, 0.0000, 90.0000); // object (146)
	AddObject(11548, -1837.3000, -6.1000, 14.2000, 0.0000, 179.5000, 210.5000); // object (147)
	AddObject(17070, -1832.6000, -15.8000, 14.0000, 358.9970, 360.0000, 1.9960); // object (148)
	AddObject(3052, -1870.3000, -218.0000, 17.5000, 0.0000, 0.0000, 0.0000); // object (149)
	AddObject(955, -1980.7891, 142.6641, 27.0703, 0.0000, 0.0000, 270.0000); // object (150)
	AddObject(3052, -1869.4000, -219.3000, 19.2000, 0.0000, 0.0000, 0.0000); // object (151)
	AddObject(3761, -1868.2000, -219.4000, 19.4000, 0.0000, 0.0000, 90.0000); // object (152)
	AddObject(3052, -1867.4000, -219.3000, 18.4000, 0.0000, 0.0000, 0.0000); // object (153)
	AddObject(3052, -1866.0000, -219.3000, 17.6000, 0.0000, 0.0000, 0.0000); // object (154)
	AddObject(1676, -2026.8256, 156.7586, 29.5449, 0.0000, 0.0000, 270.0000); // object (155)
	AddObject(11417, -2018.1582, 156.3455, 31.1967, 0.0000, 0.0000, 45.0000); // object (156)
	AddObject(2780, -1836.5100, 3.1600, 86.2410, 0.0000, 0.0000, 0.0000); // object (157)
	AddObject(11548, -1831.8000, 8.5000, 14.2000, 0.0000, 0.0000, 60.0000); // object (158)
	AddObject(3052, -1860.6000, -219.1000, 18.3000, 0.0000, 0.0000, 0.0000); // object (159)
	AddObject(3761, -1859.5996, -219.2998, 19.4000, 0.0000, 0.0000, 270.0000); // object (160)
	AddObject(3052, -1859.2000, -219.2000, 19.2000, 0.0000, 0.0000, 0.0000); // object (161)
	AddObject(3052, -1859.3000, -219.2000, 17.6000, 0.0000, 0.0000, 0.0000); // object (162)
	AddObject(3052, -1857.0000, -218.0000, 17.5000, 0.0000, 0.0000, 0.0000); // object (163)
	AddObject(1536, -1827.6250, 40.6055, 14.1219, 0.0000, 0.0000, 270.0000); // object (164)
	AddObject(983, -1829.2330, 48.6310, 14.8890, 0.0000, 0.0000, 270.0000); // object (165)
	AddObject(3334, -1791.5000, -106.4700, 8.0000, 0.0000, 0.0000, 270.0000); // object (166)
	AddObject(983, -1820.6000, 48.6310, 14.8060, 0.0000, 0.0000, 270.0000); // object (167)
	AddObject(984, -1859.9200, 111.2540, 16.1290, 0.0000, 0.0000, 0.0000); // object (168)
	AddObject(2991, -1858.6580, 113.2560, 16.1200, 0.0000, 0.0000, 270.2500); // object (169)
	AddObject(1508, -1853.5050, 110.0020, 17.1500, 0.0000, 0.0000, 269.7473); // object (170)
	AddObject(3513, -1853.1730, 109.9260, 14.7840, 0.0000, 0.0000, 0.0000); // object (171)
	AddObject(18765, -1855.0120, 112.6550, 12.9920, 0.0000, 0.0000, 0.0000); // object (172)
	AddObject(3633, -1858.1790, 116.6180, 15.9670, 0.0000, 0.0000, 0.0000); // object (173)
	AddObject(3633, -1856.6030, 116.0420, 15.9670, 0.0000, 0.0000, 0.0000); // object (174)
	AddObject(8572, -1849.3970, 114.1330, 14.2420, 0.0000, 0.0000, 85.2446); // object (175)
	AddObject(8572, -1841.8199, 114.3930, 14.2420, 0.0000, 0.0000, 269.5000); // object (176)
	AddObject(3627, -1844.4871, 118.8980, 17.9070, 0.0000, 0.0000, 266.9945); // object (177)
	AddObject(1508, -1835.8510, 110.0000, 16.5470, 0.0000, 0.0000, 269.7500); // object (178)
	AddObject(19479, -1854.0000, 129.0000, 14.1200, 0.0000, 270.0000, 90.0000); // object (179)
	AddObject(18765, -1835.9890, 110.9560, 12.9920, 0.0000, 0.0000, 0.0000); // object (180)
	AddObject(2358, -1838.6410, 115.6620, 15.6090, 0.0000, 0.0000, 0.0000); // object (181)
	AddObject(2358, -1838.2860, 115.6260, 15.8310, 0.0000, 0.0000, 0.0000); // object (182)
	AddObject(3630, -1844.3820, 122.2570, 15.6100, 0.0000, 0.0000, 0.0000); // object (183)
	AddObject(2358, -1837.7870, 115.6260, 15.6090, 0.0000, 0.0000, 0.0000); // object (184)
	AddObject(984, -1831.0760, 109.5600, 16.1040, 0.0000, 0.0000, 0.0000); // object (185)
	AddObject(925, -1832.7419, 111.7920, 16.5540, 0.0000, 0.0000, 0.0000); // object (186)
	AddObject(3633, -1833.3910, 114.8810, 17.2250, 0.0000, 0.0000, 0.0000); // object (187)
	AddObject(2991, -1833.2020, 114.6410, 16.1200, 0.0000, 0.0000, 0.0000); // object (188)
	AddObject(982, -1817.8610, 100.3610, 14.8010, 0.0000, 0.0000, 359.7494); // object (189)

	// јвианосец
	AddObject(9623, -1543.94, 514.13, 7.95,   0.00, 0.00, 263.50);
	AddObject(16769, -1533.40, 549.91, 6.18,   0.00, 0.00, 0.00);
	AddObject(1536, -1536.39, 542.41, 6.18,   0.00, 0.00, 0.00);
	AddObject(987, -1549.51, 504.93, 5.70,   0.00, 0.00, 249.50);
	AddObject(987, -1553.69, 493.71, 5.68,   0.00, 0.00, 249.50);
	AddObject(987, -1557.99, 482.50, 5.61,   0.00, 0.00, 298.25);
	AddObject(987, -1547.10, 532.98, 5.70,   0.00, 0.00, 266.50);
	AddObject(987, -1547.18, 544.99, 5.70,   0.00, 0.00, 270.50);
	AddObject(987, -1547.24, 556.94, 5.70,   0.00, 0.00, 270.49);
	AddObject(987, -1535.98, 560.98, 5.70,   0.00, 0.00, 200.24);
	AddObject(987, -1518.21, 566.91, 5.70,   0.00, 0.00, 200.24);
	AddObject(8210, -1631.49, 344.63, 6.61,   0.00, 0.00, 0.00);
	AddObject(987, -1338.86, 433.90, 6.18,   0.00, 0.00, 89.25);
	AddObject(982, -1518.50, 504.30, 7.01,   0.00, 0.00, 0.00);
	AddObject(982, -1518.51, 529.93, 7.01,   0.00, 0.00, 0.00);
	AddObject(982, -1518.50, 553.92, 7.01,   0.00, 0.00, 0.00);
	AddObject(997, -1521.67, 491.76, 9.80,   0.00, 0.00, 0.00);
	AddObject(997, -1525.42, 491.75, 9.80,   0.00, 0.00, 0.00);
	AddObject(997, -1525.78, 491.81, 9.80,   0.00, 0.00, 269.75);
	AddObject(997, -1525.77, 488.39, 9.80,   0.00, 0.00, 269.75);
	AddObject(997, -1525.82, 485.13, 9.85,   0.00, 0.00, 269.75);
	AddObject(19124, -1521.95, 491.65, 10.37,   0.00, 0.00, 0.00);
	AddObject(19124, -1525.59, 491.70, 10.37,   0.00, 0.00, 0.00);
	AddObject(7091, -1547.53, 514.95, 10.13,   0.00, 292.00, 174.00);
	AddObject(10183, -1522.39, 512.01, 6.19,   0.00, 0.00, 315.50);
	AddObject(3796, -1547.85, 495.57, 6.18,   0.00, 0.00, 152.00);
	AddObject(3066, -1553.99, 479.64, 7.24,   0.00, 0.00, 28.00);
	AddObject(3066, -1548.57, 482.72, 7.23,   0.00, 0.00, 334.00);
	AddObject(2973, -1552.50, 488.62, 6.18,   0.00, 0.00, 0.00);
	AddObject(3279, -1540.14, 477.46, 6.19,   0.00, 0.00, 0.00);
	AddObject(3787, -1542.36, 483.93, 6.75,   0.00, 0.00, 0.00);
	AddObject(3787, -1542.19, 485.67, 6.75,   0.00, 0.00, 0.00);
	AddObject(3787, -1538.56, 483.97, 6.75,   0.00, 0.00, 0.00);
	AddObject(3787, -1538.38, 485.71, 6.75,   0.00, 0.00, 0.00);
	AddObject(3786, -1547.52, 496.10, 6.76,   0.00, 0.00, 0.00);
	AddObject(3786, -1548.05, 494.89, 6.76,   0.00, 0.00, 0.00);
	AddObject(3789, -1543.40, 488.92, 6.52,   0.00, 0.00, 330.00);
	AddObject(3790, -1543.33, 489.19, 6.66,   0.00, 0.00, 330.00);
	AddObject(3790, -1543.59, 488.68, 6.66,   0.00, 0.00, 330.00);
	AddObject(967, -1548.84, 522.32, 6.18,   0.00, 0.00, 176.00);
	AddObject(967, -1550.09, 507.54, 6.18,   0.00, 0.00, 176.00);
	AddObject(982, -1494.02, 481.57, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1468.43, 481.56, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1462.02, 481.55, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1432.31, 481.58, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1406.64, 481.58, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1381.03, 481.58, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1355.39, 481.57, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1332.96, 481.56, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1304.45, 481.64, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1278.85, 481.61, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1253.19, 481.59, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1246.82, 481.61, 6.87,   0.00, 0.00, 90.00);
	AddObject(984, -1229.48, 477.11, 6.82,   0.00, 0.00, 45.25);
	AddObject(984, -1224.94, 472.60, 6.82,   0.00, 0.00, 45.25);
	AddObject(982, -1220.40, 455.30, 6.87,   0.00, 0.00, 0.00);
	AddObject(982, -1220.42, 450.51, 6.87,   0.00, 0.00, 0.00);
	AddObject(1278, -1220.72, 437.20, 20.38,   0.00, 0.00, 276.50);
	AddObject(983, -1223.78, 435.46, 6.87,   0.00, 0.00, 298.00);
	AddObject(982, -1239.55, 433.92, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1265.14, 433.91, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1290.74, 433.91, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1316.35, 433.88, 6.87,   0.00, 0.00, 90.00);
	AddObject(982, -1325.97, 433.88, 6.87,   0.00, 0.00, 90.00);
	AddObject(5130, -1335.17, 478.73, 8.23,   0.00, 0.00, 225.75);
	AddObject(4199, -1470.51, 455.48, 8.30,   0.00, 0.00, 90.00);
	AddObject(8172, -1421.18, 426.67, 29.11,   0.00, 0.00, 90.00);
	AddObject(3268, -1241.16, 445.61, 6.19,   0.00, 0.00, 268.74);
	AddObject(3268, -1273.48, 446.35, 6.19,   0.00, 0.00, 268.74);
	AddObject(3268, -1314.44, 446.40, 6.19,   0.00, 0.00, 268.74);
	AddObject(9241, -1360.54, 390.82, 30.87,   0.00, 0.00, 270.00);
	AddObject(9241, -1358.81, 351.42, 30.87,   0.00, 0.00, 270.00);
	AddObject(9241, -1405.66, 351.03, 30.87,   0.00, 0.00, 270.00);
	AddObject(9241, -1405.10, 390.65, 30.87,   0.00, 0.00, 270.00);
	AddObject(9241, -1444.42, 351.14, 30.87,   0.00, 0.00, 270.00);
	AddObject(9241, -1443.78, 390.86, 30.87,   0.00, 0.00, 270.00);
	AddObject(1508, -1362.05, 451.78, 7.85,   0.00, 0.00, 270.00);
	AddObject(1508, -1486.45, 392.54, 30.74,   0.00, 0.00, 180.00);
	AddObject(1508, -1504.94, 360.17, 42.92,   0.00, 0.00, 269.74);
	AddObject(982, -1454.43, 488.39, 17.92,   0.00, 0.00, 90.00);
	AddObject(982, -1428.84, 488.37, 17.91,   0.00, 0.00, 90.00);
	AddObject(982, -1403.20, 488.36, 17.91,   0.00, 0.00, 90.00);
	AddObject(982, -1454.40, 513.88, 17.92,   0.00, 0.00, 90.00);
	AddObject(982, -1438.43, 513.87, 17.92,   0.00, 0.00, 90.00);
	AddObject(982, -1414.72, 510.34, 17.92,   0.00, 0.00, 90.00);
	AddObject(982, -1390.93, 513.67, 17.92,   0.00, 0.00, 90.00);
	AddObject(966, -1543.63, 515.57, 6.04,   0.00, 0.00, 264.00);
	AddObject(966, -1545.07, 506.63, 6.18,   0.00, 0.00, 264.00);
	
	
	AddObject(19176,2146.1540527344,1603.0279541016,1002.4520263672,0,0,270); 						// ѕерегародка в инте —ЌЌ
	AddObject(3037,238.78999329,185.72000122,1004.22198486,90.00000000,0.00000000,270.00000000);	// ѕерегародка в инте ‘Ѕ–
	AddObject(5302,371.95800781,155.18600464,1017.30401611,0.00000000,0.00000000,270.00000000);		// прегародка между мэрией и медиками
	AddObject(3749,1523.46533203,2773.23779297,15.53028965,0.00000000,0.00000000,270.00000000);		// YAKUZA

	// ƒверь в Ѕорделе
	AddObject(19428,968.58398438,-52.86700058,1001.87500000,0.00000000,0.00000000,0.00000000);
	AddObject(19428,968.57702637,-54.03900146,1001.87500000,0.00000000,0.00000000,0.00000000);
	AddObject(1491,968.49798584,-52.43099976,1000.16699219,0.00000000,0.00000000,268.00000000);

	//«аглушки в инте баллас
	AddObject(2957,2176.69799805,1594.29797363,1000.59600830,0.00000000,0.00000000,0.00000000);
	AddObject(2957,2224.27294922,1598.30505371,1000.59600830,0.00000000,0.00000000,0.00000000);

	// «ј¬ќƒ
	AddObject(2957,2522.2880859,-1301.9320068,1048.9090576,0.0000000,0.0000000,270.0000000, 2); //object(chinatgaragedoor) (1)
	AddObject(2957,2577.8959961,-1290.1700439,1044.4589844,0.0000000,0.0000000,89.7500000, 2); //object(chinatgaragedoor) (2)
	AddObject(1499,2574.9331055,-1279.9379883,1043.1250000,0.0000000,0.0000000,0.0000000, 2); //object(gen_doorint05) (1)

	// ‘» — ¬ќ–ќ“ ¬ »Ќ“≈–№≈–≈ √ј–ј∆
	AddObject(10182,608.7999900,-123.0000000,998.7000100,0.0000000,0.0000000,0.0000000); //object(michdr) (1)
	AddObject(10182,608.7999900,-129.3000000,998.7000100,0.0000000,0.0000000,0.0000000); //object(michdr) (2)

	SetDynamicObjectMaterialText(
	AddObject(19482, 2217.0000, -1155.5000, 1026.4000, 0.0000, 0.0000, 90.0000), 0,
	"F6 - чат\nTAB - список игроков\n\
		G   - сесть в машину пассажиром\n\
		F8  - сделать скриншот\n\
		/вопрос - задать вопрос хелперам\n\
		/help - доступные команды",
	OBJECT_MATERIAL_SIZE_256x128,
	"Arial", 18, 1, -16776961
	);

	return debug("Obj::Init() - Ok! Objects: %i", CountDynamicObjects());
}

stock Pup::Init() {
	GarageParkPickup[0] = AddPickup(1239, 14, 823.5468,-1553.1484,13.5236, 0, "* «агнать в гараж *", 0x268DAEAA);
	GarageParkPickup[1] = AddPickup(1239, 14, 1631.7609,980.2023,10.5921, 0, "* «агнать в гараж *", 0x268DAEAA);
	GarageParkPickup[2] = AddPickup(1239, 14, -2444.6260,525.1984,29.6734, 0, "* «агнать в гараж *", 0x268DAEAA);

	weapon1 = AddPickup(1239, 23,296.6332,-38.2177,1001.5156, -1); //аммо лс
	weapon2 = AddPickup(1239, 23,312.2767,-166.1406,999.6010, -1); //аммо лв
	weapon3 = AddPickup(1239, 23,291.2473,-84.0021,1001.5156, -1); //аммо лв
	weapon4 = AddPickup(1239, 23,287.5871,-106.4027,1001.5156, -1); //аммо копы

	barn[0] = AddPickup(1239, 14, -1060.2505,-1195.5034,129.5133, 0, "* јмбар *", 0x268DAEAA);
	barn[1] = AddPickup(1239, 14, 2162.8804,-1660.0884,15.0859, 0, "* —дача наркоты *", 0x268DAEAA);

	EstateAgency = AddPickup(1239, 23, 1721.8441,-1651.8345,20.0625, Bizz_EstateAgency);

	AddPickup(1239, 14, 2799.0696,-2356.5588,13.6368, 0, "* —клад материалов *", 0x268DAEAA);
	AddPickup(1239, 14, -2119.6609,-178.9174,35.3203, 0, "* ѕродажа материалов *", 0x268DAEAA);
	AddPickup(1239, 14, 1173.2563,-1323.3102,15.3943, 0, "* √оспиталь *", 0x268DAEAA);
	AddPickup(1239, 14, 2029.5945,-1404.6426,17.2512, 0, "* √оспиталь *", 0x268DAEAA);
	AddPickup(1239, 14, 597.1277,-1248.6479,18.2734, 0, "* ѕакаеты дл€ материалов *", 0x268DAEAA);
	AddPickup(1239, 14, -2115.7246,-78.0859,35.3203, 0, "*  упить матиреалы *", 0x268DAEAA);
	AddPickup(1239, 14, 323.0781,1118.6022,1083.8828, -1, "* Ќакотики *", 0x268DAEAA);
	AddPickup(1239, 14, 253.9280,69.6094,1003.6406, -1, "* ќправдать преступника *", 0x268DAEAA);
	AddPickup(1239, 14, 256.7318,188.2524,1008.1719, -1, "* ќправдать преступника *", 0x268DAEAA);

	//============================================================================
	ammozakona[0] = AddPickup(1239, 23, 313.863555, -133.838562, 999.601562, -1); // ѕикап покупки оружи€
	ammozakona[1] = AddPickup(1275, 23, 308.373474, -131.458786, 999.608337, 4); // ѕикап маскировки
	ammozakona[2] = AddPickup(1275, 23, 308.373474, -131.458786, 999.608337, 555); // ѕикап снены одежды јрми€
	ammozakona[3] = AddPickup(1242, 23, 308.097839, -140.963485, 999.601562, 4); // ѕикап хеала
	Streamer::AppendArrayData(1, ammozakona[3], E_STREAMER_WORLD_ID, 4);
	Streamer::AppendArrayData(1, ammozakona[3], E_STREAMER_WORLD_ID, 15);
	Streamer::AppendArrayData(1, ammozakona[3], E_STREAMER_WORLD_ID, 555);

	//============================================================================
	healash = AddPickup(1240,20,-2027.2445,-118.8632,1035.1719,11);
	healcnn = AddPickup(1240,20,2189.1300,-1168.2600,25.5700,12);
	healfbi = AddPickup(1240,20,228.6945,154.2483,1003.0234,2);
	Parashut = AddPickup(1310,19,1544.4170,-1353.1135,329.4746,0);
	//============================================================================
	Bank[0] = AddPickup(1239, 23, 2308.8254,-13.2494,26.7422,-1);
	Bank[1] = AddPickup(1239, 23, 2309.4783,-8.4624,26.7422,-1, "—чета фракций/банд/мафий", 0xFF6347AA, 0, 0, 0.9);
	testpdd = AddPickup(1239, 23, -2022.3630,-116.5412,1035.1719, 11);
	//============================================================================
	boj = AddPickup(1239,23,756.4068,-48.0776,1000.7802,-1);
	Piza = AddPickup(1239,23,375.8968,-119.4092,1001.4995,-1);
	proba = AddPickup(1239,23,450.4001,-83.6821,999.5547,-1);
	buy[0] = AddPickup(1239,23,-27.5047,-89.9378,1003.5469,-1);
	buy[1] = AddPickup(1239,23,-29.1611,-184.6501,1003.5469,-1);

	mak[0] = AddPickup(1239,23,375.7963,-67.9685,1001.5151,-1);
	mak[1] = AddPickup(1239,23,369.6309,-6.2745,1001.8589,-1);

	fire_ext = AddPickup(366, 1,369.8291,188.5891,1008.3893,7);

	prolaps[0] = AddPickup(1275, 23, 207.0993, -129.1810,1003.5078, -1, "* ќдежда *", 0x268DAEAA);
	prolaps[1] = AddPickup(1275, 23, 209.6147, -8.2010,1005.2109, -1, "* ќдежда *", 0x268DAEAA);
	saveTuning = AddPickup(1239, 23, -1663.8300,1208.2209,7.2546, 0, "* –егистраци€ тюнинга *", 0x268DAEAA);
	givepasport = AddPickup(1239, 23, 303.9906,1876.3062,904.3759, -1, "* ѕаспортный стол *", 0x268DAEAA);

	hitpickup[0] = AddPickup(1275, 23, 948.5044,2104.2209,1011.0234, 8);
	hitpickup[1] = AddPickup(1210, 23, 963.1935,2101.9546,1011.0272, 8);

	helpp[0] = AddPickup(1239, 23, 2214.9100,-1188.0800,25.7500, 12, "*** ѕомощь по игре ***", 0xFF6347AA);
	helpp[1] = AddPickup(1239, 23, 2271.1892,1647.2826,1084.2344,  1, "*** ѕомощь по игре ***", 0xFF6347AA);
	helpp[2] = AddPickup(1239, 23, 1474.5907,-1771.5734,18.7958, 0, "*** ѕомощь по игре ***", 0xFF6347AA);

    respuk[0] = AddPickup(1318,23,2239.7529,-1161.9849,29.4159,12); // 1
    respuk[1] = AddPickup(1318,23,2239.8999,-1167.1819,29.4159,12); // 2
    respuk[2] = AddPickup(1318,23,2240.0906,-1173.2942,29.4159,12); // 3
    respuk[3] = AddPickup(1318,23,2239.8057,-1178.9138,29.4159,12); // 4
    
	static const jnames[][] = {
		{"Ѕезработным"},
		{"ƒетективом"},
		{"јдвокатом"},
		{"ѕроституткой"},
		{"Ќаркодилером"},
		{"јвтоугонщиком"},
		{"јвтомехаником"},
		{"√андилером"},
		{"јвтодилером"},
		{"јвтобусником"},
		{"ƒальнобойщиком"}
	};
	for(new i=1; i < sizeof(JobsInfo); i++) {
		format(temp, sizeof temp, "*** –јЅќ“ј ***\n«десь можно устроитс€\n%s", jnames[JobsInfo[i][jID]]);
		JobsInfo[i][jP] = AddPickup(1239, 23, JobsInfo[i][jPos][0], JobsInfo[i][jPos][1], JobsInfo[i][jPos][2], JobsInfo[i][jV], temp, 0x268DAEAA);
	}

	new Float:hz = 1044.1250 - 0.5;
	FactoryPickup[0] = AddPickup(19135, 2, 2551.1204, -1300.0930, hz, 2);
	AddPickup(19135, 2, 2559.1130, -1300.0895, hz, 2);
	AddPickup(19135, 2, 2543.0723, -1300.0941, hz, 2);
	AddPickup(19135, 2, 2543.1548, -1287.2231, hz, 2);
	AddPickup(19135, 2, 2551.1267, -1287.2209, hz, 2);
	FactoryPickup[1] = AddPickup(19135, 2, 2559.1338, -1287.2196, hz, 2);
	FactoryPickup[2] = AddPickup(1275, 23, 2564.1899, -1281.3265, 1044.1, 2);

	for(new i; i < sizeof l_FactoryCP; i++) {
		CreateDynamicCP(l_FactoryCP[i][0], l_FactoryCP[i][1], l_FactoryCP[i][2], 0.3, 2, -1, -1, 0.5);
		CreateDynamicCP(r_FactoryCP[i][0], r_FactoryCP[i][1], r_FactoryCP[i][2], 0.3, 2, -1, -1, 0.5);
	}
	FactorySklad = CreateDynamicCP(2564.7886, -1292.9886, 1044.1250,2.0, -1, -1, -1, 3.0);

	CreateDynamicMapIcon(-2647.4233,695.6075,27.9370, 22, 0, -1, -1, -1, 200.0);

	return debug("Pup::Init() - Ok! Pickups: %i", CountDynamicPickups());
}

stock T3d::Init() {
	format(string_ah,sizeof(string_ah),">> ќчередь допущенных к практической части экзамена: <<\n");
	ah_text = Add3DText(string_ah, 0x42aaffFF,-2036.0808,-115.1422,1036, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 11);

	Add3DText("ѕравила ƒорожного ƒвижени€\n/pdd", 0xFF6347AA, -2026.8050537,-113.6340027,1035.1550293+1, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 11);
	Add3DText("*** ѕродовольственный —клад ***",0xBFF600FF,2771.2314,-2437.2632,13.6377,40.0);
	Add3DText("*** ¬Ќ»ћјЌ»≈ ***\n\
		ƒл€ получени€ водительских прав\n\
		необходимо сдать теорию у доски\n\
		и зан€ть место в очереди к двери.",
	0xFF6347AA, -2024.8572, -118.6570, 1035.1719, 10.0,
	INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, 11
	);

	Add3DText("*** ¬Ќ»ћјЌ»≈ ***\n\
		ѕеред покупкой/продажей/обеном дома\n\
		необходимо очистить сейф.\n\
		≈сли вы покупаете дом, удостоверьтесь,\n\
		что вы не снимаете комнату (введите /unrent)",
	0xFF6347AA, 1730.1852, -1636.3838, 20.2171, 15.0,
	INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 0
	);

	for(new p; p < sizeof GangInfo; p++) {
		format(src, sizeof(src),
		"*** GANG INFO ***\n\n.::%s::.\nЅизнесы: %d\n”важение: %d\n Ѕанк: $%d\n«ахват с %d ранга",
		GetGangName(GangInfo[p][fID]),
		GangBiznes{GangInfo[p][fID]},
		GangInfo[p][gRespect],
		GetFracMoney(GangInfo[p][fID]),
		GetZRank(GangInfo[p][fID])
		);
		GangInfo[p][gText] = Add3DText(src, GetFracColor(GangInfo[p][fID]), GangInfo[p][gPosX], GangInfo[p][gPosY], GangInfo[p][gPosZ], 30.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, 0);
	}

	format(temp, sizeof(temp),"{ffffff}Cклад:\n {f4c430}“опливо: %d литров\n{00ff00}ѕродукты: %d кг\n{f4c430}ћеталл: %d кг", Gm::Info[Gm::FactoryFuel], Gm::Info[Gm::FactoryProds], Gm::Info[Gm::FactoryMetal]);
	FactoryInfo[0] = Add3DText(temp, -1, -1847.7107,113.5725,16.3751, 25.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 0);
	format(temp, sizeof(temp),"{ffffff}—клад:\n {f4c430}“опливо: %d л\nѕродукты: %d кг\nћеталл: %d кг", Gm::Info[Gm::FactoryFuel], Gm::Info[Gm::FactoryProds], Gm::Info[Gm::FactoryMetal]);
	FactoryInfo[1] = Add3DText(temp, -1, 2565.5071,-1293.0293, 1045.0704, 40.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 2);

	Add3DText("«агрузка ѕродуктов\n/loadprods", 0xFF6347AA, -1857.7770, 110.9073, 15.7994, 25.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 0);
	Add3DText("–азгрузка ћеталла и “оплива\n/unloadstuff", 0xFF6347AA, -1837.0381, 111.2696, 15.6467, 25.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, 0);

	return debug("T3d::Init() - Ok! 3DTexts: %i", CountDynamic3DTextLabels());
}

stock Mnu::Init() {
	MainMenu = CreateMenu("~w~Welcome", 1, 250.0, 120.0, 110.0, 0.0);
	AddMenuItem(MainMenu, 0, "> Log in");
	AddMenuItem(MainMenu, 0, "> Register");
	AddMenuItem(MainMenu, 0, "> ~r~Rules");
	AddMenuItem(MainMenu, 0, "> ~g~About");

	BuyMenu = CreateMenu("24/7", 1, 10, 127, 150.0, 100.0);
	AddMenuItem(BuyMenu, 0, "Phone ($"#TelephonePrice")");
	AddMenuItem(BuyMenu, 0, "Scrath Card ($"#ScrathCardPrice")");
	AddMenuItem(BuyMenu, 0, "Phone Book ($"#PhoneBookPrice")");
	AddMenuItem(BuyMenu, 0, "Dice ($"#DicePrice")");
	AddMenuItem(BuyMenu, 0, "Car's Key's ($"#CarKeyPrice")");
	AddMenuItem(BuyMenu, 0, "Condom ($"#CandomPrice")");
	AddMenuItem(BuyMenu, 0, "CD-Player ($"#CDPlayerPrice")");
	AddMenuItem(BuyMenu, 0, "GPS ($"#GPSPrice")");


	ClothesMenu = CreateMenu("~g~Clothes", 1, 15.0, 200.0, 150.0, 150.0);
	AddMenuItem(ClothesMenu, 0, "Next");
	AddMenuItem(ClothesMenu, 0, "Previous");
	AddMenuItem(ClothesMenu, 0, "Select");
	AddMenuItem(ClothesMenu, 0, "Exit");


	SkinMenu = CreateMenu("~b~Skins", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(SkinMenu, 0, "Next");
	AddMenuItem(SkinMenu, 0, "Previous");
	AddMenuItem(SkinMenu, 0, "Select");


	IntMenu = CreateMenu("Interiors", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(IntMenu, 0, "Next");
	AddMenuItem(IntMenu, 0, "Previous");
	AddMenuItem(IntMenu, 0, "Select");
	AddMenuItem(IntMenu, 0, "Exit");


	SAInteriorsMenu = CreateMenu("Interiors", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(SAInteriorsMenu, 0, "Next");
	AddMenuItem(SAInteriorsMenu, 0, "Previous");
	AddMenuItem(SAInteriorsMenu, 0, "Exit");


	AutoSolonMenu = CreateMenu("~w~CarShop", 1, 15.0, 200.0, 150.0, 150.0);
	AddMenuItem(AutoSolonMenu, 0, "Next");
	AddMenuItem(AutoSolonMenu, 0, "Previous");
	AddMenuItem(AutoSolonMenu, 0, "Buy");
	AddMenuItem(AutoSolonMenu, 0, "Exit");


	GarageMenu = CreateMenu("~w~CarGarage", 1, 15.0, 200.0, 150.0, 150.0);
	AddMenuItem(GarageMenu, 0, "Next");
	AddMenuItem(GarageMenu, 0, "Select");
	AddMenuItem(GarageMenu, 0, "Exit");

	//
	rifflegun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(rifflegun, 0, "50($1750)");
	AddMenuItem(rifflegun, 0, "200($5500)");
	AddMenuItem(rifflegun, 0, "500($13000)");
	AddMenuItem(rifflegun, 0, "Previous");
	//
	ak47gun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(ak47gun, 0, "50($1750)");
	AddMenuItem(ak47gun, 0, "200($5500)");
	AddMenuItem(ak47gun, 0, "500($13000)");
	AddMenuItem(ak47gun, 0, "Previous");
	//
	m4a1gun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(m4a1gun, 0, "50($1750)");
	AddMenuItem(m4a1gun, 0, "200($5500)");
	AddMenuItem(m4a1gun, 0, "500($13000)");
	AddMenuItem(m4a1gun, 0, "Previous");
	//
	mp5gun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(mp5gun, 0, "50($1750)");
	AddMenuItem(mp5gun, 0, "200($5500)");
	AddMenuItem(mp5gun, 0, "500($13000)");
	AddMenuItem(mp5gun, 0, "Previous");
	//
	shotgun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(shotgun, 0, "50($1750)");
	AddMenuItem(shotgun, 0, "200($5500)");
	AddMenuItem(shotgun, 0, "500($13000)");
	AddMenuItem(shotgun, 0, "Previous");
	//
	sdgun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(sdgun, 0, "50($1750)");
	AddMenuItem(sdgun, 0, "200($5500)");
	AddMenuItem(sdgun, 0, "500($13000)");
	AddMenuItem(sdgun, 0, "Previous");
	//
	degun = CreateMenu("~w~Bullets", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(degun, 0, "50($4250)");
	AddMenuItem(degun, 0, "200($8000)");
	AddMenuItem(degun, 0, "500($15500)");
	AddMenuItem(degun, 0, "Previous");
	
	//
	ammonac = CreateMenu("~w~Guns", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(ammonac, 0, "Desert Eagle");
	AddMenuItem(ammonac, 0, "SD pistol");
	AddMenuItem(ammonac, 0, "Shotgun");
	AddMenuItem(ammonac, 0, "MP5");
	AddMenuItem(ammonac, 0, "M4A1");
	AddMenuItem(ammonac, 0, "AK47");
	AddMenuItem(ammonac, 0, "Riffle");
	AddMenuItem(ammonac, 0, "Next");
	
	//
	ammonac2 = CreateMenu("~w~Guns", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(ammonac2, 0, "Shovel ($300)");
	AddMenuItem(ammonac2, 0, "Golfclub ($400)");
	AddMenuItem(ammonac2, 0, "Poolcue ($100)");
	AddMenuItem(ammonac2, 0, "Cane ($600)");
	AddMenuItem(ammonac2, 0, "Flowers ($200)");
	AddMenuItem(ammonac2, 0, "Nightstick ($300)");
	AddMenuItem(ammonac2, 0, "Baseball Bat ($700)");
	AddMenuItem(ammonac2, 0, "Next");
	AddMenuItem(ammonac2, 0, "Previous");
	
	//
	ammonac3 = CreateMenu("~w~Guns", 1, 15.0, 150.0, 100.0, 100.0);
	AddMenuItem(ammonac3, 0, "Purple Dildo ($400)");
	AddMenuItem(ammonac3, 0, "White Dildo ($700)");
	AddMenuItem(ammonac3, 0, "Long White Didlo ($500)");
	AddMenuItem(ammonac3, 0, "White didlo 2 ($500)");
	AddMenuItem(ammonac3, 0, "Parachute ($500)");
	AddMenuItem(ammonac3, 0, "Previous");
	
	BarMenu = CreateMenu("Drinks", 1, 15.000, 150.0, 150.0);
	for(new i; i < sizeof(DrinkInfo); i++) {
		format(temp, sizeof temp, "%s [$%i]", DrinkInfo[i][dName], DrinkInfo[i][dPrice]);
		AddMenuItem(BarMenu, 0, temp);
	}

	Ammu1Menu = CreateMenu("BuyGuns", 1, 15.000, 150.0, 150.0);
	for(new i; i < sizeof(Ammu1Info); i++) {
		format(temp, sizeof temp, "> %s [$%i]", Ammu1Info[i][gName], Ammu1Info[i][gPrice]);
		AddMenuItem(Ammu1Menu, 0, temp);
	}

	Ammu2Menu = CreateMenu("BuyGuns", 1, 15.000, 150.0, 150.0);
	for(new i; i < sizeof(Ammu2Info); i++) {
		format(temp, sizeof temp, "> %s [$%i]", Ammu2Info[i][gName], Ammu2Info[i][gPrice]);
		AddMenuItem(Ammu2Menu, 0, temp);
	}

	HitmanMenu = CreateMenu("Ammo", 1, 15.000, 200.0, 150.0, 200.0);
	for(new i; i < sizeof(HitmanAmmo); i++) {
		format(temp, sizeof temp, "> %s", HitmanAmmo[i][gName]);
		AddMenuItem(HitmanMenu, 0, temp);
	}

	BurgerMenu = CreateMenu("Burger", 1, 15.000, 150.0, 150.0);
	for(new i; i < sizeof(BurgerInfo); i++) {
		format(temp, sizeof temp, "> %s [$%i]", BurgerInfo[i][bDescription], BurgerInfo[i][bPrice]);
		AddMenuItem(BurgerMenu, 0, temp);
	}

	PizaMenu = CreateMenu("PiZZa", 1, 15.000, 150.0, 150.0);
	for(new i; i < sizeof(PizzaInfo); i++) {
		format(temp, sizeof temp, "> %s [$%i]",  PizzaInfo[i][bDescription], PizzaInfo[i][bPrice]);
		AddMenuItem(PizaMenu, 0, temp);
	}
	return 1;
}

stock ToggleVehicleEngine(vehid, value) {
	switch(GetVehicleType(GetVehicleModel(vehid))) {
	case VEHICLE_TYPE_BIKE, VEHICLE_TYPE_AUTO : {
			if(!value) {
				isEngined{vehid}=false;
				Iter::Remove(enginedVehicles, vehid);
				GetVehicleParamsEx(vehid,engine,light,alarm,doors,bonnet,boot,objective);
			} else {
				isEngined{vehid}=true;
				Iter::Add(enginedVehicles, vehid);
				GetVehicleParamsEx(vehid,engine,light,alarm,doors,bonnet,boot,objective);
			}
			SetVehicleParamsEx(vehid,isEngined{vehid},light,alarm,doors,bonnet,boot,objective);
		}
	}
	return 1;
}

stock RespawnUnoccupiedVehicles() {
	new vehid, bool:occupied[MAX_VEHICLES char] = {false, ...};
	foreach(new i: Player) {
		if((vehid = GetPlayerVehicleID(i))) {
			occupied{vehid} = true;
		}
	}

	for(new i; i < MAX_VEHICLES; i++) {
		if(!occupied{i}) {
			SetVehicleToRespawn(i);
		}
	}
}

stock ShowOnline(playerid, id) {
	new num;
	dialogtext[0]='\0';
	switch(id) {
	case 0: {
			foreach(new i : LeaderPlayers) {
				GetPlayerName(i, plname, 24);
				scf(dialogtext, src, "{FFFF00}%s: {FFFFFF}%s [id: %i]\n", FracInfo[Pl::Info[i][pLeader]][fName], plname, i);
			}
			if(!strlen(dialogtext)) strcat(dialogtext, "Ќет лидеров онлайн!");
			return SPD(playerid, D_ONLINE+1, 0, "Ћидеры", dialogtext, "OK", "");
		}
	case 1: {
			Send(playerid, COLOR_LIGHTRED, "Ћицензиары онлайн:");
			foreach(new i: TeamPlayers[TEAM_LICENZERS]) {
				GetPlayerName(i, plname, 24);
				format(temp, sizeof temp, "* Ћицензиар: %s. ѕозвонить /call %i", plname, Pl::Info[i][pNumber]);
				Send(playerid, COLOR_YELLOW, temp);
			}
		}
	case 2: {
			new fracid = Pl::FracID(playerid);
			if(fracid != 0)
			{
			    new memstr[1024];
				foreach(new i: TeamPlayers[fracid])
				{
					num ++;
					GetPlayerName(i, plname, 24);
					if(AFKInfo[i][afk_State] != 0)
					{
						if(Pl::Info[i][pLeader] == fracid)
						{
							format(temp, sizeof temp, "{FFFF00}* %i. %s [id:%i] - %s (%i) {AA3333}|LEADER| {33AA33}<AFK: %i sec>\n", num, plname, i, RankInfo[fracid][Pl::Info[i][pRank]], Pl::Info[i][pRank], AFKInfo[i][afk_Time][0]);
						}
						else
						{
							format(temp, sizeof temp, "{FFFF00}* %i. %s [id:%i] - %s (%i) {33AA33}<AFK: %i sec>\n", num, plname, i, RankInfo[fracid][Pl::Info[i][pRank]], Pl::Info[i][pRank], AFKInfo[i][afk_Time][0]);
						}
					}
					else
					{
						if(Pl::Info[i][pLeader] == fracid)
						{
							format(temp, sizeof temp, "{FFFF00}* %i. %s [id:%i] - %s (%i) {AA3333}|LEADER|\n", num, plname, i, RankInfo[fracid][Pl::Info[i][pRank]], Pl::Info[i][pRank]);
						}
						else
						{
							format(temp, sizeof temp, "{FFFF00}* %i. %s [id:%i] - %s (%i)\n", num, plname, i, RankInfo[fracid][Pl::Info[i][pRank]], Pl::Info[i][pRank]);
						}
					}
					strcat(memstr,temp);
				}
				SPD(playerid,D_NONE,DIALOG_STYLE_MSGBOX,"{E5D81E}„лены организации онлайн",memstr,"«акрыть","");
			}
			else
			{
				Send(playerid, COLOR_GREY, "* ¬ы не состоите в этой организации!");
			}
		}

	case 3: {
			Send(playerid, COLOR_LIGHTRED, "јдвокаты онлайн:");
			foreach(new i: JobPlayers[2]) {
				GetPlayerName(i, plname, 24);
				format(temp, sizeof temp, "* Ћицензиар: %s. ѕозвонить /call %i", plname, Pl::Info[i][pNumber]);
				Send(playerid, COLOR_YELLOW, temp);
			}
		}

	case 4: {
			Send(playerid, COLOR_GREY, "јдмины онлайн:");
			foreach(new i : AdminPlayers) {
				num ++;
				GetPlayerName(i, plname, 24);
				format(temp, sizeof temp, "* %i. јдмин: %s [id: %i]", num, plname, i);
				Send(playerid, COLOR_GREY, temp);
			}
		}

	case 5: {
			Send(playerid, COLOR_LIGHTRED, "ѕомощники онлайн:");
			foreach(new i : HelperPlayers) {
				num ++;
				GetPlayerName(i, plname, 24);
				format(temp, sizeof temp, "* %i. %s[id:%i] Hlvl: %i", num, plname, i, Pl::Info[i][pHelper]);
				Send(playerid, COLOR_YELLOW, temp);
			}
		}

	case 6: {
			new hid = Pl::Info[playerid][pHouseKey];
			if(!IsValidHouse(hid)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет дома!");
			Send(playerid, COLOR_LIGHTRED, " вартиранты онлайн:");
			foreach(new i: Player) {
				if(i != playerid && Pl::isLogged(i) && hid == Pl::Info[i][pHouseKey]) {
					GetPlayerName(i, plname, 24);
					format(temp, sizeof temp, "* %s. ѕозвонить /call %i", plname, i, Pl::Info[i][pNumber]);
					Send(playerid, COLOR_YELLOW, temp);
				}
			}
		}
	}

	return 1;
}

stock LoadVehicles() {
	new time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableVehicles__"` ORDER BY `ID` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i, veh; i < rows; i++) {
			cache_get_int(i, 0, VehicleInfo[i][vID]);
			cache_get_int(i, 1, VehicleInfo[i][vModel]);
			cache_get_float(i, 2, VehicleInfo[i][vPosX]);
			cache_get_float(i, 3, VehicleInfo[i][vPosY]);
			cache_get_float(i, 4, VehicleInfo[i][vPosZ]);
			cache_get_float(i, 5, VehicleInfo[i][vPosA]);
			cache_get_int(i, 6, VehicleInfo[i][vColor1]);
			cache_get_int(i, 7, VehicleInfo[i][vColor2]);
			cache_get_int(i, 8, VehicleInfo[i][vRespTime]);
			cache_get_int(i, 9, VehicleInfo[i][vJob]);
			cache_get_float(i, 10, AutoInfo[0][aMileage]);

			veh = Veh::Create(
			VehicleInfo[i][vModel],
			VehicleInfo[i][vPosX],
			VehicleInfo[i][vPosY],
			VehicleInfo[i][vPosZ],
			VehicleInfo[i][vPosA],
			VehicleInfo[i][vColor1],
			VehicleInfo[i][vColor2],
			VehicleInfo[i][vRespTime]
			);
			cache_get_str(i, 11, "p<,>a<i>[14]i", AutoInfo[veh][aTuning], AutoInfo[veh][aPaintJob]);
			AddTuning(veh);
			SetVehicleNumber(veh);
			AutoInfo[veh][aMileage] = AutoInfo[0][aMileage];
			Iter::Add(JobVehicles[VehicleInfo[i][vJob]], veh);
			AutoInfo[veh][aFuel] = float(rndNum(20,30));
			VehicleInfo[i][cID] = veh;
			TOTAL_VEHICLES ++;
		}
		debug("LoadVehicles() - Ok! Vehicles: %i. Run time: %i (ms)", TOTAL_VEHICLES, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadATM() {
	ATMp[0] = CountDynamicPickups()+1;
	for(new i, Float:x, Float:y; i < sizeof ATMs; i++) {
		x = ATMs[i][0]; y = ATMs[i][1];
		AddObject(2942, ATMs[i][0], ATMs[i][1], ATMs[i][2], 0, 0, ATMs[i][3], 0);
		GetXYInFrontOfPoint(x, y, ATMs[i][3], -0.6);
		AddPickup(1239, 23, x, y, ATMs[i][2], 0);
	}
	ATMp[1] = CountDynamicPickups();
}

public: Veh::Destroy(&i) {
	if(IsValidVehicle(i)) {
		if(isEngined{i}) {
			ToggleVehicleEngine(i, 0);
		}
		AutoInfo[i][aOwner] = INVALID_PLAYER_ID;
		AutoInfo[i][aUpdate] = 25;
		AutoInfo[i][aMats] = 0;
		AutoInfo[i][aDrugs] = 0;
		AutoInfo[i][aMaxMats] = 2000;
		AutoInfo[i][aMaxDrugs] = 100;
		AutoInfo[i][aPaintJob] = 3;
		AutoInfo[i][aColor][COLOR_ONE] = 0;
		AutoInfo[i][aColor][COLOR_TWO] = 0;
		Rac::SetVehicleHealth(i, 1000.0);
		Iter::Clear(vehiclePassengers[i]);
		DestroyVehicle(i);
		i = INVALID_VEHICLE_ID;
	}
	return 1;
}

public: Veh::Create(model, Float:x, Float:y, Float:z, Float:a, color1, color2, resptime) {
	new i = CreateVehicle(model, x, y, z, a, color1, color2, resptime);
	AutoInfo[i][aOwner] = INVALID_PLAYER_ID;
	AutoInfo[i][aUpdate] = 0;
	AutoInfo[i][aMats] = 0;
	AutoInfo[i][aDrugs] = 0;
	AutoInfo[i][aMaxMats] = 2000;
	AutoInfo[i][aMaxDrugs] = 100;
	AutoInfo[i][aPaintJob] = 3;
	AutoInfo[i][aColor][COLOR_ONE] = color1;
	AutoInfo[i][aColor][COLOR_TWO] = color2;
	AutoInfo[i][aFuel] = 99.0;
	AutoInfo[i][aLimit] = 300;
	Rac::SetVehicleHealth(i, 1000.0);
	isEngined{i} = false;
	return i;
}

stock CreateZahvatTD(&Text:txdw) {
	txdw = Td::Create(320.000000, 100.000000, "~r~240");
	Td::Alignment(txdw, 2);
	Td::BackgroundColor(txdw, 255);
	Td::Font(txdw, 3);
	Td::LetterSize(txdw, 0.889998, 3.299998);
	Td::Color(txdw, -1);
	Td::SetOutline(txdw, 1);
	Td::SetProportional(txdw, 0);
	return 1;
}


stock get_tab(name[], l=sizeof name) {
	switch(strlen(name)) {
	case 0..5	: strcat(name, "\t\t\t\t", l);
	case 6..12	: strcat(name, "\t\t\t", l);
	case 13..20 : strcat(name, "\t\t", l);
		default		: strcat(name, "\t", l);
	}
}


stock ShowOffline(playerid, id) {
	switch(id) {
	case 0 : format(query, sizeof query, "SELECT `Name`,`Leader`,FROM_UNIXTIME(`Online`,'%%Y-%%m-%%d, %%H:%%i') FROM `"#__TableUsers__"` WHERE `Leader` >= '1' ORDER BY `Leader` ASC");
	case 1 : format(query, sizeof query, "SELECT `Name`,`Helper`,FROM_UNIXTIME(`Online`,'%%Y-%%m-%%d, %%H:%%i') FROM `"#__TableUsers__"` WHERE `Helper` >= '1' ORDER BY `Helper` DESC");
	case 2 : format(query, sizeof query, "SELECT `Name`,`Admin`,FROM_UNIXTIME(`Online`,'%%Y-%%m-%%d, %%H:%%i') FROM `"#__TableUsers__"` WHERE `Admin` >= '1' ORDER BY `Admin` DESC");
	}
	Db::tquery(connDb, query, "_ShowOffline", "ii", playerid, id);
	return 1;
}

public: _ShowOffline(playerid, id) {
	new name[24], lastdate[28];
	dialogtext[0]='\0';

	switch(id) {
	case 0 : {
			new num, rows = cache_get_row_count(rows);
			if(rows > 0) {
				new leaderid, leader;
				strcat(dialogtext, "Ћидер\t\tѕоследний везит\t‘ракци€\n\n");
				while(rows--) {
					cache_get_row(rows, 0, name);
					cache_get_int(rows, 1, leader);
					cache_get_row(rows, 2, lastdate);

					if(IsValidFrac(leader)) {
						leaderid = ReturnUser(name);
						if(!Pl::isLogged(leaderid)) {
							num ++;
							get_tab(name);
							scf(dialogtext, src, "{ffffff}Х %s {AA3333}%s{ffffff} \t{%h}%s\n", name, lastdate, rgb<GetFracColor(leader)>, FracInfo[leader][fName]);
						}
					}
				}
			}

			if(!num) {
				SPD(playerid, D_OFFLINE+1, 0, "Ћидеры оффлайн", "Х Ќет лидеров оффлайн Х", "OK", "CANCEL");
			} else {
				format(temp, sizeof temp, "Ћидеры оффлайн | Ћидеров: %i", num);
				SPD(playerid, D_OFFLINE+1, 0, temp, dialogtext, "OK", "CANCEL");
			}
		}

	case 1 : {
			new num, rows = cache_get_row_count(rows);
			if(rows) {
				new helperid, helper;
				strcat(dialogtext, "’елпер\t\tѕоследний везит\t–анг\n\n");
				while(rows--) {
					cache_get_row(rows, 0, name);
					cache_get_int(rows, 1, helper);
					cache_get_row(rows, 2, lastdate);
					if(1 <= helper <= 3) {
						helperid = ReturnUser(name);
						if(!Pl::isLogged(helperid)) {
							num ++;
							get_tab(name);
							scf(dialogtext, src, "{ffffff}Х %s {AA3333}%s{ffffff} \t{33AA33}%s\n", name, lastdate, GetHelperRank(helper));
						}
					}
				}
			}

			if(!num) {
				SPD(playerid, D_OFFLINE+1, 0, "’елперы оффлайн", "Х Ќет хелперов оффлайн Х", "OK", "CANCEL");
			} else {
				SPD(playerid, D_OFFLINE+1, 0, "’елперы оффлайн", dialogtext, "OK", "CANCEL");
			}
		}

	case 2 : {
			new num, rows = cache_get_row_count(rows);
			if(rows) {
				new adminid, admin;
				strcat(dialogtext, "јдмин\t\t\tѕоследний везит\t–анг\n\n");
				while(rows--) {
					cache_get_row(rows, 0, name);
					cache_get_int(rows, 1, admin);
					cache_get_row(rows, 2, lastdate);
					if(1 <= admin <= 5) {
						adminid = ReturnUser(name);
						if(!Pl::isLogged(adminid)) {
							num ++;
							get_tab(name);
							scf(dialogtext, src, "{FFFFFF} Х %s {AA3333}%s{FFFFFF} \t{33AA33}%s\n", name, lastdate, GetAdminRank(admin));
						}
					}
				}
			}

			if(!num) {
				SPD(playerid, D_OFFLINE+1, 0, "јдминистраторы оффлайн", "Х Ќет админов оффлайн Х", "OK", "CANCEL");
			} else {
				SPD(playerid, D_OFFLINE+1, 0, "јдминистраторы оффлайн", dialogtext, "OK", "CANCEL");
			}
		}
	}
	return 1;
}

stock GetCarID(playerid) {
	for(new i; i < TOTAL_VEHICLES; i++) {
		if(IsPlayerInVehicle(playerid, VehicleInfo[i][cID])) {
			return i;
		}
	}
	return -1;
}

stock SafeMenu(playerid, hid, type = 0) {
	if(IsValidHouse(hid)) {
		switch(type) {
		case 0: {
				new count;
				for(new i; i < MAX_HWEAP; i++) if(HouseInfo[hid][hGuns][i] != 0) count ++;
				format(dialog, sizeof dialog, ""#_GREY_ARROW"ƒеньги [{33AA33}$%i{ffffff}] [Ћимит: {AA3333}$10000000 {ffffff}]\n", HouseInfo[hid][hSafe][0]);
				scf(dialog, src, ""#_GREY_ARROW"Ќаркотики [{33AA33}%i{ffffff}] [Ћимит: {AA3333}1000 грамм {ffffff}]\n", HouseInfo[hid][hSafe][1]);
				scf(dialog, src, ""#_GREY_ARROW"ћатиреалы [{33AA33}%i{ffffff}] [Ћимит: {AA3333}100000 матов {ffffff}]\n", HouseInfo[hid][hSafe][2]);
				scf(dialog, src, ""#_GREY_ARROW"ќружие [{33AA33}%i{ffffff}] [Ћимит: {AA3333}6 слотов {ffffff}]\n", count);
				scf(dialog, src, ""#_GREY_ARROW"јптечки [{33AA33}%i{ffffff}] [Ћимит: {AA3333}100 штук{ffffff}]\n", HouseInfo[hid][hSafe][3]);
				scf(dialog, src, ""#_GREY_ARROW"Ѕронежилеты [{33AA33}%i{ffffff}] [Ћимит: {AA3333}10 штук{ffffff}]\n", HouseInfo[hid][hSafe][4]);
				SPD(playerid, D_HMENU+14, DIALOG_STYLE_LIST, "[House Menu] > —ейф", dialog, "SELECT", "CANCEL");
			}
		case 1: {
				dialog[0] = '\0';
				for(new i; i < MAX_HWEAP; i++) {
					if(HouseInfo[hid][hGuns][i] != 0) {
						GetWeaponName(HouseInfo[hid][hGuns][i], temp, 24);
						scf(dialog, src, "[{33AA33}%s{ffffff} - ѕатрон: {AA3333}%i {ffffff}]\n", temp, HouseInfo[hid][hAmmos][i]);
					} else {
						strcat(dialog, "[{33AA33}ѕусто{ffffff} - ѕатрон: {AA3333}0 {ffffff}]\n");
					}
				}
				SPD(playerid, D_HMENU+21, DIALOG_STYLE_LIST, "[House Menu] > —ейф > ќружие", dialog, "SELECT", "CANCEL");
			}
		}
		return 1;
	}
	return 0;
}

stock ClearBiz(biz) {
	if(BizzInfo[biz][bOwned] != 0) {
		new playerid = ReturnUser(BizzInfo[biz][bOwner]);
		new targetid = ReturnUser(BizzInfo[biz][bExtortion]);
		if(!Pl::isLogged(playerid)) {
			format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Busines` = %i WHERE `Busines` = %i", INVALID_BIZ_ID, BizzInfo[biz][bID]);
			Db::tquery(connDb, query, "", "");
		} else {
			Pl::Info[playerid][pBizKey] = INVALID_BIZ_ID;
			Send(playerid, COLOR_LIGHTRED, "* ¬аш бизнес был продан!");
		}

		if(!Pl::isLogged(targetid)) {
			format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `Busines` = %i WHERE `Busines` = %i", INVALID_BIZ_ID, BizzInfo[biz][bID]);
			Db::tquery(connDb, query, "", "");
		} else {
			Pl::Info[playerid][pBizKey] = INVALID_BIZ_ID;
			Send(targetid, COLOR_LIGHTRED, "* ¬аш бизнес был продан!");
		}
	}
	BizzInfo[biz][bLocked] = 1;
	BizzInfo[biz][bOwned] = 0;
	BizzInfo[biz][bSafe] = 0;
	BizzInfo[biz][bProfit] = 0;
	strmid(BizzInfo[biz][bOwner], "The State", 0, strlen("The State"), 255);
	strmid(BizzInfo[biz][bExtortion], "No-one", 0, strlen("No-one"), 255);
	UpdateBizzPickups(biz);

	return 1;
}

stock ClearHouse(houseid) {
	if(IsValidVehicle(HouseInfo[houseid][hAuto])) {
		HouseInfo[houseid][hvModel] = 0;
		HouseInfo[houseid][hvColor][0] = -1;
		HouseInfo[houseid][hvColor][1] = -1;
		for(new i; i < 4; i++) HouseInfo[houseid][hvSpawn][i] = 0.0;
		AutoInfo[HouseInfo[houseid][hAuto]][aMileage] = 0.0;
		ResetTuning(HouseInfo[houseid][hAuto], 1, houseid);
		Veh::Destroy(HouseInfo[houseid][hAuto]);
	}
	if(HouseInfo[houseid][hOwned] != 0) {
		new playerid = ReturnUser(HouseInfo[houseid][hOwner]);
		if(Pl::isLogged(playerid)) {
			Pl::Info[playerid][pHouseKey] = INVALID_HOUSE_ID;
			foreach(new i : ExtraVehicles[playerid]) {
				if(ExtraVehicles[playerid][i][evPark] == PARK_HOME) {
					ExtraVehicles[playerid][i][evPark] = PARK_GARAGE;
					AddExtraVehicleToGarage(playerid, i);
					UpdateExtraVehicle(playerid, i);
					Veh::Destroy(ExtraVehicles[playerid][i][evID2]);
				}
				else if((ExtraVehicles[playerid][i][evPark] / houseid) == PARK_HOME_GARAGE) {
					ExtraVehicles[playerid][i][evPark] = PARK_GARAGE;
					AddExtraVehicleToGarage(playerid, i);
					UpdateExtraVehicle(playerid, i);
					Veh::Destroy(ExtraVehicles[playerid][i][evID2]);
				}
			}
			Send(playerid, COLOR_LIGHTRED, "* ¬аш дом был продан!");
		} else {
			format(query, sizeof query, "UPDATE `"#__TableExtraVehicles__"` SET `park` = '%i' WHERE `park` = '%i'", PARK_GARAGE, PARK_HOME_GARAGE*houseid);
			Db::tquery(connDb, query, "", "");

			format(query, sizeof query, "UPDATE `"#__TableUsers__"` SET `House` = '%i' WHERE BINARY `House` = '%i'", INVALID_HOUSE_ID, houseid);
			Db::tquery(connDb, query, "", "");
		}
	}
	HouseInfo[houseid][hTv] = 0;
	HouseInfo[houseid][hLock] = 1;
	HouseInfo[houseid][hOwned] = 0;
	for(new i; i < 5; i++) HouseInfo[houseid][hSafe][i] = 0;
	HouseInfo[houseid][hvPark] = NONE_VEHICLE;
	for(new i; i < MAX_HWEAP; i++) {
		HouseInfo[houseid][hGuns][i] = 0;
		HouseInfo[houseid][hAmmos][i] = 0;
	}
	DeleteHouseGarage(houseid);
	strmid(HouseInfo[houseid][hOwner], "The State", 0, strlen("The State"), 255);
	UpdateHousePickups(houseid);
	return 1;
}

stock GetClosestBiz(playerid, Float:radi) {
	foreach(new i : Biznes) {
		if(IsPlayerInRangeOfPoint(playerid, radi, BizzInfo[i][bEnter][0], BizzInfo[i][bEnter][1], BizzInfo[i][bEnter][2])) {
			return i;
		}
	}
	return -1;
}

stock ShowDialog(playerid, dialogid, style, title[], filename[], buttom1[], buttom2[]) {
	static textbuff[2048];
	if(LoadFile(filename, textbuff)) {
		return SPD(playerid, dialogid, style, title, textbuff, buttom1, buttom2);
	}
	return SPD(playerid, D_NONE, 0, "ERROR", "* File dialog is not found!", "CLOSE", "");
}

stock Fc::GetInfo(vehicleid, format[]="", ...) {
	for(new i; i < FC_TOTAL; i++) {
		if(Fc::Info[i][Fc::Id][1] == vehicleid) {
			if(!isnull(format)) {
				new _f_pos, _p_pos = 2, _params = numargs();
				while(_p_pos < _params) {
					switch(format[_f_pos++]) {
					case 'i' : setarg(_p_pos, 0, i);
					case 'r' : setarg(_p_pos, 0, Fc::Info[i][Fc::RankId]);
					case 'f' : setarg(_p_pos, 0, Fc::Info[i][Fc::FracId]);
					case 'm' : setarg(_p_pos, 0, Fc::Info[i][Fc::Model]);
					case 'x' : setarg(_p_pos, 0, _:Fc::Info[i][Fc::RespPos][0]);
					case 'y' : setarg(_p_pos, 0, _:Fc::Info[i][Fc::RespPos][1]);
					case 'z' : setarg(_p_pos, 0, _:Fc::Info[i][Fc::RespPos][2]);
					case 'a' : setarg(_p_pos, 0, _:Fc::Info[i][Fc::RespPos][3]);
					}
					_p_pos++;
				}
			}
			return 1;
		}
	}
	return 0;
}

stock Fc::FracID(vehicleid) {
	for(new i; i < MAX_FRAC; i++) {
		if(Iter::Contains(TeamVehicles[i], vehicleid)) {
			return i;
		}
	}
	return 0;
}

stock isTeamVehicle(fracid, vehicleid) {
	if(0 <= fracid <= MAX_FRAC) {
		if(1 <= vehicleid <= MAX_VEHICLES) {
			return Iter::Contains(TeamVehicles[fracid], vehicleid);
		}
	}
	return 0;
}

stock isJobVehicle(jobid, vehicleid) {
	if(0 <= jobid <= MAX_JOBS) {
		if(1 <= vehicleid <= MAX_VEHICLES) {
			return Iter::Contains(JobVehicles[jobid], vehicleid);
		}
	}
	return 0;
}

stock GetVehDescription(vehicleid, format[]="", ...) {
	for(new i; i < TOTAL_VEHICLES; i++) {
		if(VehicleInfo[i][cID] == vehicleid) {
			if(!isnull(format)) {
				new a, b = 2, params = numargs();
				while(b < params) {
					switch(format[a++]) {
					case 'i' : setarg(b, 0, i);
					case 'j' : setarg(b, 0, VehicleInfo[i][vJob]);
					case 'm' : setarg(b, 0, VehicleInfo[i][vModel]);
					case 'x' : setarg(b, 0, _:VehicleInfo[i][vPosX]);
					case 'y' : setarg(b, 0, _:VehicleInfo[i][vPosY]);
					case 'z' : setarg(b, 0, _:VehicleInfo[i][vPosZ]);
					case 'a' : setarg(b, 0, _:VehicleInfo[i][vPosA]);
					}
					b++;
				}
			}
			return 1;
		}
	}
	return 0;
}


stock Fc::IsEditMode(playerid) return (Pl::Info[playerid][pAdmin]>=5&&EditMode[playerid]);

stock Fc::IsForbiddenVeh(modelid) {
	return binarySearch(Fc::FORBIDDEN_VEH, modelid) != -1;
}

stock Fc::IsThereModel(fracid, modelid) {
	format(query, sizeof query, "SELECT * FROM `"#__TableFracModels__"` WHERE `frac_id` = '%i' AND `model_id` = '%i'", fracid, modelid);
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	cache_delete(result);
	return rows > 0;
}

stock Fc::ShowModel( playerid, fracid, dialogid) {
	format(query, sizeof query, "SELECT `model_id` FROM `"#__TableFracModels__"` WHERE `frac_id` = '%i'", fracid);
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		new model_id;
		dialog[0] = '\0';
		for(new i; i < rows; i++) {
			Db::fetch_row( query );
			cache_get_int(i, 0, model_id);
			scf(dialog, query, "%s\n", VehicleNames[model_id-400], model_id );
		}
		if( Pl::Info[playerid][pAdmin] >= 5 && dialogid != D_ADD_FC && dialogid != D_LMENU+7 ) strcat( dialog, "------------\nƒобавить");
		SPD( playerid, dialogid, DIALOG_STYLE_LIST, "Frac Models", dialog, "SELECT", "CANCEL");
	} else {
		if(Pl::Info[playerid][pAdmin] >= 5 && dialogid != D_ADD_FC && dialogid != D_LMENU+7) {
			SPD(playerid, dialogid, 2, "Frac Models", "ƒобавить", "ENTER", "CANCLE");
		} else {
			SPD(playerid, dialogid, 0, "Frac Models", "Ќет моделей дл€ выбора!", "ok", "");
		}
	}
	SetPVarInt( playerid, "SelectFrac", fracid);
	cache_delete(result);
	return 1;
}

stock Fc::RecreateVehicle(idx) {
	if(0 <= idx < sizeof Fc::Info) {
		Veh::Destroy(Fc::Info[idx][Fc::Id][1]);
		Fc::Info[idx][Fc::Id][1] = Veh::Create(
		Fc::Info[idx][Fc::Model],
		Fc::Info[idx][Fc::RespPos][0],
		Fc::Info[idx][Fc::RespPos][1],
		Fc::Info[idx][Fc::RespPos][2],
		Fc::Info[idx][Fc::RespPos][3],
		Fc::Info[idx][Fc::Color][0],
		Fc::Info[idx][Fc::Color][1],
		1200
		);
		return 1;
	}
	return 0;
}

stock Fc::Delete(idx) {
	if(0 <= idx < sizeof Fc::Info) {
		format(query, sizeof query, "DELETE FROM `"#__TableFracVehicles__"` WHERE `ID` = '%i'", Fc::Info[idx][Fc::Id][0]);
		Db::tquery(connDb, query, "", "");

		Fc::TOTAL --;
		Veh::Destroy(Fc::Info[idx][Fc::Id][1]);

		for(new i; i < 2; i++) {
			Fc::Info[idx][Fc::Id][i] = Fc::Info[Fc::TOTAL][Fc::Id][i];
			Fc::Info[idx][Fc::Color][i] = Fc::Info[Fc::TOTAL][Fc::Color][i];
		}

		Fc::Info[idx][Fc::Model] = Fc::Info[Fc::TOTAL][Fc::Model];
		Fc::Info[idx][Fc::FracId] = Fc::Info[Fc::TOTAL][Fc::FracId];

		strmid(Fc::Info[idx][Fc::Number], Fc::Info[Fc::TOTAL][Fc::Number], 0, strlen(Fc::Info[Fc::TOTAL][Fc::Number]), 255);

		Fc::Info[idx][Fc::RespPos][0] = Fc::Info[Fc::TOTAL][Fc::RespPos][0];
		Fc::Info[idx][Fc::RespPos][1] = Fc::Info[Fc::TOTAL][Fc::RespPos][1];
		Fc::Info[idx][Fc::RespPos][2] = Fc::Info[Fc::TOTAL][Fc::RespPos][2];
		Fc::Info[idx][Fc::RespPos][3] = Fc::Info[Fc::TOTAL][Fc::RespPos][3];

		return 1;
	}
	return 0;
}

stock name_to_id(string[], &modelid) {
	if('0' <= string[0] <= '9') {
		modelid = strval(string);
		if(400 <= modelid <= 611) return 1;
	} else {
		for(new i; i < sizeof(VehicleNames); i++) {
			if(strfind(VehicleNames[i], string, true) != -1) {
				modelid += i + 400;
				return 1;
			}
		}
	}
	return 0;
}

stock UpdateStuffTD(playerid, vehid, type) {
	if(IsPlayerConnected(playerid)) {
		new model = GetVehicleModel(vehid);
		format(src, sizeof src, "~w~VEHICLE: ~g~%s [id: %i]      %.1f (miles)", VehicleNames[model-400], model, AutoInfo[vehid][aMileage]);
		switch(type) {
		case 1 : scf(src, temp, "      MATS: ~r~%i/%i", AutoInfo[vehid][aMats], AutoInfo[vehid][aMaxMats]);
		case 2 : scf(src, temp, "      MAK: ~r~%i/%i", AutoInfo[vehicle][aDrugs], AutoInfo[vehicle][aMaxDrugs]);
		case 3 : scf(src, temp, "      PRODS: ~r~%i/%i", PlayerHaul[vehid-comptruck[0]][pLoad], PlayerHaul[vehid-comptruck[0]][pCapasity]);
		}
		Pt::SetString(playerid, Pt::Name[playerid], src);
	}
	return 1;
}

stock LoadSkins() {
	Container::AddArray(100, {78, 79, 135, 200, 230, 212, 213});
	Container::AddArray(101, {55, 152, 138, 201, 63, 54, 85});

	new time = GetTickCount();
	format(query, sizeof query, "SELECT `f_id`,`skin_id` FROM `frac_skins`");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, query[0]);
			cache_get_int(i, 1, query[1]);
			Container::Add(query[0], query[1]);
		}
		debug("Loadskins() - Ok! Skins: %i. Run time: %i (ms)", rows, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadRanks( ) {
	new time = GetTickCount();
	format( query, sizeof query, "SELECT * FROM `"#__TableFracRanks__"` ORDER BY `r_id`");
	new Cache:result = Db::query(connDb, query, true);
	for(new i; i < MAX_RANK; i++) strmid(RankInfo[0][i], "-", 0, strlen("-"), 255);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i, fracid, rankid; i < rows; i++) {
			cache_get_int(i, 0, fracid);
			cache_get_int(i, 1, rankid);
			cache_get_row(i, 2, RankInfo[fracid][rankid], connDb, 36);
			RankNums[fracid] ++;
		}
		debug("LoadRanks() - Ok! Ranks: %i. Run time: %i (ms)", rows, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadPortals(){
	new allowed, time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TablePickups__"` ORDER BY `id`");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_str(i, 0, "p<,>a<i>[2]", Portal::Info[i][Portal::Id]);
			cache_get_str(i, 1, "p<,>a<i>[2]", Portal::Info[i][Portal::Model]);
			cache_get_str(i, 2, "p<,>a<i>[2]", Portal::Info[i][Portal::Type]);
			cache_get_str(i, 3, "p<,>a<i>[2]", Portal::Info[i][Portal::Inter]);
			cache_get_str(i, 4, "p<,>a<i>[2]", Portal::Info[i][Portal::World]);
			cache_get_str(i, 5, "p<,>a<f>[4]", Portal::Info[i][Portal::Portal1]);
			cache_get_str(i, 6, "p<,>a<f>[4]", Portal::Info[i][Portal::Portal2]);
			cache_get_int(i, 7, allowed);

			Portal::Info[i][Portal::Pickup][0]=_AddPickup(Portal::Info[i][Portal::Model][0],Portal::Info[i][Portal::Type][0],Portal::Info[i][Portal::Portal1],Portal::Info[i][Portal::World][0]);
			Portal::Info[i][Portal::Pickup][1]=_AddPickup(Portal::Info[i][Portal::Model][1],Portal::Info[i][Portal::Type][1],Portal::Info[i][Portal::Portal2],Portal::Info[i][Portal::World][1]);
			binToArray(allowed, Portal::Info[i][Portal::Allowed], MAX_FRAC);
		}
		TOTAL_PORTAL = rows;
		debug("LoadPortals() - Ok! Portals: %i. Run time: %i (ms)", TOTAL_PORTAL, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}

stock LoadAntiDmZones() {
	new index, time = GetTickCount();
	format(query, sizeof query, "SELECT * FROM `"#__TableAntidmzones__"` ORDER BY `id` ASC");
	new Cache:result = Db::query(connDb, query, true);
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, AntiDmInfo[index][e_AntiDmZoneId]);
			cache_get_int(i, 1, AntiDmInfo[index][e_AntiDmWorld]);
			cache_get_str(i, 2, "a<f>[4]", AntiDmInfo[index][e_AntiDmCoord]);

			AntiDmInfo[index][e_AntiDmZone] = CreateDynamicSphere(
			AntiDmInfo[i][e_AntiDmCoord][0],
			AntiDmInfo[i][e_AntiDmCoord][1],
			AntiDmInfo[i][e_AntiDmCoord][2],
			AntiDmInfo[i][e_AntiDmCoord][3],
			AntiDmInfo[i][e_AntiDmWorld]
			);
		}
		TOTAL_ANTIDM_ZONES = rows;
		debug("LoadAntiDmZones() - Ok! Zones: %i. Run time: %i (ms)", TOTAL_ANTIDM_ZONES, GetTickCount()-time);
	}
	cache_delete(result);
	return 1;
}


/// :: ::: ::: BL ::: ::: ::
stock Bl::Add(playerid, accuser, reason[]) {
	new escstring[36];
	new currtime = gettime(), fracid = Pl::FracID(accuser);
	Db::escape_string(reason, escstring);
	Bl::Info[playerid][Bl::onFrac][fracid] = 1;
	Bl::Info[playerid][Bl::Kills][fracid] = 0;
	format(query, sizeof query, "INSERT INTO `"#__TableBlacklist__"` (`f_id`,`accused`,`date`,`accuser`,`reason`,`lastvisit`) VALUES (");
	scf(query, src, "'%i','%i','%i',", fracid, Pl::Info[playerid][pID], currtime);
	scf(query, src, "'%i','%s','%i')", Pl::Info[accuser][pID], escstring, currtime+DAY*15);
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock Bl::Remove(playerid, fracid) {
	new name[24];
	GetPlayerName(playerid, name, 24);
	format(query, sizeof query, "DELETE FROM `"#__TableBlacklist__"` WHERE `f_id`='%i' AND `accused`='%i'", fracid, Pl::Info[playerid][pID]);
	Bl::Info[playerid][Bl::onFrac][fracid] = 0;
	Bl::Info[playerid][Bl::Kills][fracid] = 0;
	Db::tquery(connDb, query, "", "");
	return 1;
}

stock Bl::Update(playerid, fracid) {
	format(query, sizeof query, "UPDATE `"#__TableBlacklist__"` SET `mink`='%i' WHERE `accused`='%i' AND `f_id`='%i'",
	Bl::Info[playerid][Bl::Kills][fracid], Pl::Info[playerid][pID], fracid);
	Db::tquery(connDb, query, "", "");
	return 1;
}

public: Bl::Check(playerid) {
	new rows = cache_get_row_count();
	if(rows) {
		new name[24];
		GetPlayerName(playerid, name, 24);
		format(temp, sizeof temp, "[BLACK LIST] ¬ы находитесь в черном списке ");
		for(new i, fracid, kills; i < rows; i++) {
			sscanf(query, "p<|>ii", fracid, kills);
			cache_get_int(i, 0, fracid);
			cache_get_int(i, 1, kills);
			Bl::Info[playerid][Bl::onFrac][fracid] = 1;
			Bl::Info[playerid][Bl::Kills][fracid] = kills;
			format(query, sizeof query, "[BLACK LIST] «апахло дичью, в штате был(а) замечен(а) %s", name);
			sendToFamily(fracid, COLOR_AZTECAS, query);
			scf(temp, src, "%s, ", FracInfo[fracid][fName]);
		}

		temp[strlen(temp)-2] = '\0';
		Send(playerid, COLOR_AZTECAS, temp);

		format(query, sizeof query, "UPDATE `"#__TableBlacklist__"` SET `lastvisit` = '%i' WHERE `accused` = '%i'", (gettime()+DAY*15), Pl::Info[playerid][pID]);
		Db::tquery(connDb, query, "", "");
	}
}


stock Bl::Clear( ) {
	format(query, sizeof query, "DELETE FROM `"#__TableBlacklist__"` WHERE `lastvisit` <= '%i'", gettime());
	Db::tquery(connDb, query, "", "");
	return 1;
}

public: Bl::Show(playerid, fracid) {
	Send(playerid, COLOR_WHITE, "______________ „ерный —писок ______________");

	new accuser[24], _date[24], reason[36];
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_str(i, 0, "u", query[0]);
			cache_get_int(i, 1, query[1]);
			cache_get_row(i, 2, _date);
			cache_get_row(i, 3, accuser);
			cache_get_row(i, 4, reason);

			if(Pl::isLogged(query[0])) {
				GetPlayerName(query[0], plname, 24);
				format(temp, sizeof temp, "* %s[ID: %i] | —татус: %i/%i | ƒата: %s | «анес: %s | ѕричина: %s", plname, query[0], query[1], FracInfo[fracid][fBConf][bKILLS], _date, accuser, reason);
				Send(playerid, COLOR_AZTECAS, temp);
			}
		}
	}
	return 1;
}

stock Bl::ValidState(playerid) {
	switch(GetPlayerState(playerid)) {
	case 1..3, 7, 8 : return 1;
	}
	return 0;
}

stock GetGunInfo(wname[], &weaponid, &ammo, &mats) {
	for(new i; i < sizeof(GunInfo); i++) {
		if(!strcmp( wname, GunInfo[i][g_name], true)) {
			weaponid = GunInfo[i][g_id];
			ammo = GunInfo[i][g_ammo];
			mats = GunInfo[i][g_mats];
			return 1;
		}
	}

	return 0;
}

stock IsATeamF(fracid) {
	for(new i; i < sizeof(Teams); i++) {
		if(Teams[i] == fracid) {
			return 1;
		}
	}
	return 0;
}

stock IsATeam(playerid, mode = 0) {
	if(!mode) {
		mode = Pl::FracID(playerid);
		for(new i; i < sizeof(Teams); i++) {
			if(Teams[i] == mode) {
				return true;
			}
		}
	} else {
		for(new i; i < sizeof(Teams); i++) {
			if(Teams[i] == mode) {
				return true;
			}
		}
	}

	return false;
}

stock IsAFamily(playerid) {
	switch(Pl::FracID(playerid)) {
	case 5, 6	: return 1;
	case 8..20	: return 1;
	}
	return 0;
}

stock IsALawyer(playerid) {
	return (Pl::Info[playerid][pJob] == 2 && Pl::FracID(playerid) == 7 && Pl::Info[playerid][pRank] == 10);
}

stock GetPayCheck(lvl) {
	new p;
	switch(lvl) {
	case 1..3	: p = 1000;
	case 4..10	: p = 1300;
	case 11..20	: p = 1500;
	case 21..30 : p = 1800;
	case 31..40 : p = 2000;
	}
	return (lvl*p);
}

stock checkvar(varname[], string[]) {
	new value[36];
	GetServerVarAsString(varname, value, sizeof value);
	return strcmp(value, string, false) == 0;
}

stock BlockPickupForPlayer(playerid, pickupid, delay=2) {
	PickupInfo[playerid][pOld] = pickupid;
	PickupInfo[playerid][pDelay] = delay;
	Streamer::GetFloatData(STREAMER_TYPE_PICKUP, pickupid, E_STREAMER_X, PickupInfo[playerid][pOldPos][0]);
	Streamer::GetFloatData(STREAMER_TYPE_PICKUP, pickupid, E_STREAMER_Y, PickupInfo[playerid][pOldPos][1]);
	Streamer::GetFloatData(STREAMER_TYPE_PICKUP, pickupid, E_STREAMER_Z, PickupInfo[playerid][pOldPos][2]);
	return 1;
}

stock Add_To_Iterator(playerid) {
	Iter::Add(TeamPlayers[Pl::FracID(playerid)], playerid);
	if(Pl::Info[playerid][pAdmin]) Iter::Add(AdminPlayers, playerid);
	if(Pl::Info[playerid][pHelper]) Iter::Add(HelperPlayers, playerid);
	if(Pl::Info[playerid][pLeader]) Iter::Add(LeaderPlayers, playerid);
	if(Pl::Info[playerid][pJob  ]) Iter::Add(JobPlayers[Pl::Info[playerid][pJob]], playerid);
}

stock Del_Of_Iterator(playerid) {
	Iter::Clear(inStreamVehicles[playerid]);

	Iter::Remove(AdminPlayers, playerid);
	Iter::Remove(ToglogPlayers, playerid);
	Iter::Remove(WantedPlayers, playerid);
	Iter::Remove(HelperPlayers, playerid);
	Iter::Remove(LeaderPlayers, playerid);

	Iter::Remove(TeamPlayers[Pl::FracID(playerid)], playerid);
	Iter::Remove(JobPlayers[Pl::Info[playerid][pJob]], playerid);

	foreach(new i : inStreamPlayers[playerid]) {
		Iter::Remove(inStreamPlayers[i], playerid);
	}
	Iter::Clear(inStreamPlayers[playerid]);

	if(Iter::Contains(MechanicCalls, playerid)) {
		Iter::Remove(MechanicCalls, playerid);
		GetPlayerName(playerid, plname, 24);
		format(temp, sizeof(temp), "*  лиент %s, вышел из игры!", plname);
		SendJobMessage(6, COLOR_AZTECAS, temp);
	}
	if(Iter::Contains(MedicCalls, playerid)) {
		Iter::Remove(MedicCalls, playerid);
		GetPlayerName(playerid, plname, 24);
		format(temp, sizeof(temp), "*  лиент %s, вышел из игры!", plname);
		sendToFamily(4, COLOR_AZTECAS, temp);
	}
}

stock HideNameTag(playerid, bool:hide) {
	if(Pl::isLogged(playerid)) {
		Pl::Info[playerid][pMaskOn] = hide;
		foreach(new i : inStreamPlayers[playerid]) {
			ShowPlayerNameTagForPlayer(i, playerid, !hide);
		}
	}
	return 1;
}

stock ClosestVeh(playerid, Float:radi = 200.0, exc = INVALID_VEHICLE_ID) {
	new Float: dist, vehicleid = INVALID_VEHICLE_ID;
	foreach(new i: inStreamVehicles[playerid]) {
		GetVehiclePos(i, vehx, vehy, vehz);
		dist = GetPlayerDistanceFromPoint(playerid, vehx, vehy, vehz);
		if(dist <= radi && i != exc) {
			radi = dist;
			vehicleid = i;
		}
	}
	return vehicleid;
}

stock GetPlayerBootVehicle(playerid, vehicleid) {
	new Float:x, Float:y, Float:z, Float:a;
	GetVehiclePos(vehicleid, x, y, z);
	GetVehicleZAngle(vehicleid, a);
	GetXYInFrontOfPoint(x, y, a, -6.0);
	foreach(new i: inStreamVehicles[playerid]) {
		if(GetVehicleDistanceFromPoint(i, x, y, z) <= (vehicleSize(i)/2.0)) {
			if(i != vehicleid) {
				return i;
			}
		}
	}
	return INVALID_VEHICLE_ID;
}

stock IsVehicleClosestForPlayer(playerid, vehicleid, Float:radi = 200.0, exc = INVALID_VEHICLE_ID) {
	new Float:x, Float:y, Float:z;
	GetVehiclePos(vehicleid, x, y, z);
	return (radi >= GetPlayerDistanceFromPoint(playerid, x, y, z) && exc == INVALID_VEHICLE_ID);
}

stock GetVehicleDriver(vehicleid) {
	if(1 <= vehicleid <= MAX_VEHICLES) {
		foreach(new p : vehiclePassengers[vehicleid]) {
			if(GetPlayerState(p) == 2) {
				return p;
			}
		}
	}
	return INVALID_PLAYER_ID;
}

stock GetVehiclePassengers(vehicleid) {
	return ((1 <= vehicleid <= MAX_VEHICLES) && Iter::Count(vehiclePassengers[vehicleid]));
}

stock GetVehicleFreeSeat(vehicleid) {
	new seatid;
	for(new i = 1; i < 3; i++) {
		if(Pl::isLogged(GetVehiclePlayerSeat(vehicleid, i))) {
			return seatid;
		}
	}
	return seatid;
}

stock GetVehiclePlayerSeat(vehicleid, seatid) {
	if(vehicleid != INVALID_VEHICLE_ID && vehicleid != 0) {
		foreach(new p : vehiclePassengers[vehicleid]) {
			if(GetPlayerVehicleSeat(p) == seatid) {
				return p;
			}
		}
	}
	return INVALID_PLAYER_ID;
}

stock Pl::setCamPos(playerid, i, vw=0xFFFF) {
	Rac::SetPlayerInterior(playerid,EnterPos[i][iteriorid]);
	Rac::SetPlayerVirtualWorld(playerid, (vw != 0xFFFF) ? vw : (playerid+EnterPos[i][virtworld]));
	Rac::SetPlayerPos(playerid, EnterPos[i][p_pos][0], EnterPos[i][p_pos][1], EnterPos[i][p_pos][2]);
	Rac::SetPlayerFacingAngle(playerid, EnterPos[i][p_pos][3]);
	SetPlayerCameraPos(playerid, EnterPos[i][c_pos][0],EnterPos[i][c_pos][1], EnterPos[i][c_pos][2]);
	SetPlayerCameraLookAt(playerid, EnterPos[i][c_lookAt][0],EnterPos[i][c_lookAt][1], EnterPos[i][c_lookAt][2]);
	PlayerPlaySound(playerid, EnterPos[i][musicid], 0.0, 0.0, 0.0);
}

stock SlapPlayer(playerid, Float:height) {
	new Float:x, Float:y, Float:z;
	GetPlayerPos(playerid, x, y, z);
	return Rac::SetPlayerPos(playerid, x, y, z+height);
}

stock SetZahvatMapIcon(bizz, attack, defend) {
	foreach(new playerid : TeamPlayers[attack]) {
		SetPlayerCheckpointEx(playerid, ZAHVAT_ICON, BizzInfo[bizz][bEnter][0], BizzInfo[bizz][bEnter][1], BizzInfo[bizz][bEnter][2], 19, 0, -1, -1, true);
	}
	foreach(new playerid : TeamPlayers[defend]) {
		SetPlayerCheckpointEx(playerid, ZAHVAT_ICON, BizzInfo[bizz][bEnter][0], BizzInfo[bizz][bEnter][1], BizzInfo[bizz][bEnter][2], 19, 0, -1, -1, true);
	}
	return 1;
}

stock DisableZahvatMapIcon(attack, defend) {
	foreach(new playerid : TeamPlayers[attack]) {
		DisablePlayerCheckpointEx(playerid, ZAHVAT_ICON);
	}
	foreach(new playerid : TeamPlayers[defend]) {
		DisablePlayerCheckpointEx(playerid, ZAHVAT_ICON);
	}
	return 1;
}

stock SetPlayerCheckpointEx(playerid, slot, Float:x, Float:y, Float:z, icon, color, world, interior, global) {
	if(Rac::isValidPlayer(playerid)) {
		if(0 <= slot <= 5) {
			if(PlayerCheckpoints[playerid][slot] != -1) {
				DestroyDynamicMapIcon(PlayerCheckpoints[playerid][slot]);
			}
			PlayerCheckpoints[playerid][slot] = CreateDynamicMapIcon(x, y, z, icon, color, world, interior, playerid, (global)?(99999.9):(200.0));
			Streamer::SetIntData(4, PlayerCheckpoints[playerid][slot], E_STREAMER_STYLE, (global)?(MAPICON_GLOBAL_CHECKPOINT):(MAPICON_LOCAL_CHECKPOINT));
		}
	}
	return 1;
}

stock SetPlayerCheckpointPos(playerid, slot, Float:x, Float:y, Float:z) {
	if(Rac::isValidPlayer(playerid)) {
		if(0 <= slot <= 5) {
			if(PlayerCheckpoints[playerid][slot] != -1) {
				Streamer::SetFloatData(4, PlayerCheckpoints[playerid][slot], E_STREAMER_X, x);
				Streamer::SetFloatData(4, PlayerCheckpoints[playerid][slot], E_STREAMER_Y, y);
				Streamer::SetFloatData(4, PlayerCheckpoints[playerid][slot], E_STREAMER_Z, z);
				return 1;
			}
		}
	}
	return 0;
}
stock DisablePlayerCheckpointEx(playerid, slot) {
	if(Rac::isValidPlayer(playerid)) {
		if(0 <= slot <= 5) {
			if(PlayerCheckpoints[playerid][slot] != -1) {
				DestroyDynamicMapIcon(PlayerCheckpoints[playerid][slot]);
			}
		}
	}
	return 1;
}

public: onSobeitCheck(playerid) {
	new Float:x, Float:y, Float:z;
	GetPlayerCameraFrontVector(playerid, x, y, z);
	Rac::TogglePlayerControllable(playerid, true);
	format(temp, sizeof temp, "[AdmWarn] * %s[%i] прошел тест на собейт, результат - собейт %s", GetName(playerid), playerid, (y < -0.75) ? ("{AA3333}установлен"):("{33AA33}не установлен"));
	SendToAdmin(COLOR_YELLOW, temp, 1, 3);
}

public: onPTMCheck(playerid, targetid, Float:x, Float:y, Float:z) {
	if(Pl::isLogged(targetid)) {
		Rac::SetPlayerPos(targetid, x, y, z);
		format(temp, sizeof temp, "[AdmWarn] * %s[%i] прошел тест на PTM, результат - %s PTM", GetName(playerid), playerid, (GetPlayerTargetPlayer(playerid)==targetid)?("{AA3333}использует"):("{33AA33}не использует"));
		SendToAdmin(COLOR_YELLOW, temp, 1, 3);
	}
}

public: onGMTest(playerid) {
	format(temp, sizeof temp, "[AdmWarn] * %s[%i] прошел тест на GM, результат - GM %s", GetName(playerid), playerid, (GMTest{playerid})?("{AA3333}обнаружен"):("{33AA33}не обнаружен"));
	SendToAdmin(COLOR_YELLOW, temp, 1, 3);
}

stock IsPlayerInVehiclePlayer(playerid, targetid) {
	new vehicleid = GetPlayerVehicleID(playerid);
	if(vehicleid != 0) {
		if(IsPlayerInVehicle(targetid, vehicleid)) {
			return 1;
		}
	}
	return 0;
}

stock PreloadAnimlib(playerid) {
	static const animlib[][] = {
		"BOMBER"		,
		"RAPPING"		,
		"SHOP"			,
		"BEACH"			,
		"SMOKING"		,
		"FOOD"			,
		"ON_LOOKERS"	,
		"DEALER"		,
		"CRACK"			,
		"CARRY"			,
		"COP_AMBIENT"	,
		"PARK"			,
		"INT_HOUSE"		,
		"FOOD"			,
		"CRIB"			,
		"ROB_BANK"		,
		"JST_BUISNESS"	,
		"PED"			,
		"OTB"			,
		"FAT"			,
		"FIGHT_E"
	};
	for(new i; i < sizeof animlib; i++) {
		ApplyAnimation(playerid, animlib[i], "null", 0.0, 0, 0, 0, 0, 0);
	}
}


stock IsFactoryCP(playerid, lr) {
	switch(lr) {
	case 1 : {
			for(new i; i < sizeof l_FactoryCP; i++) {
				if(IsPlayerInRangeOfPoint(playerid, 0.5, l_FactoryCP[i][0], l_FactoryCP[i][1], l_FactoryCP[i][2])) {
					return 1;
				}
			}
		}

	case 2 : {
			for(new i; i < sizeof r_FactoryCP; i++) {
				if(IsPlayerInRangeOfPoint(playerid, 0.5, r_FactoryCP[i][0], r_FactoryCP[i][1], r_FactoryCP[i][2])) {
					return 1;
				}
			}
		}
	}
	return 0;
}

public: OnPlayerEndJob(playerid, jobid) {
	if(StartJob[playerid]) {
		switch(jobid) {
		case 1 : {
				KG[playerid][0] = 0;
				StartJob[playerid] = 0;
				DestroyObject(PlayerObject[playerid]);
				PlayerObject[playerid] = INVALID_OBJECT_ID;
				if(IsPlayerAttachedObjectSlotUsed(playerid,1)) RemovePlayerAttachedObject(playerid,1);
				if(IsPlayerAttachedObjectSlotUsed(playerid,2)) RemovePlayerAttachedObject(playerid,2);
				ApplyAnimation(playerid,"CARRY","crry_prtial",4.1,1,0,0,1,1);
				SetPlayerAttachedObject(playerid, 1 , 1279, 1, 0.062397, 0.453746, 0.000000, 0.000000, 94.689308, 0.000000);
				GameTextForPlayer(playerid,"~y~ success", 2500, 1);
			}
		}
	}
}

stock UpdateFactory() {
	new string[150];
	format(string,sizeof(string),"{ffffff}Cклад:\n {f4c430}“опливо: %d литров\n{00ff00}ѕродукты: %d кг\n{f4c430}ћеталл:%d кг",Gm::Info[Gm::FactoryFuel], Gm::Info[Gm::FactoryProds], Gm::Info[Gm::FactoryMetal]);
	UpdateDynamic3DTextLabelText(FactoryInfo[0], -1, string);
	format(string,sizeof(string),"{ffffff}—клад:\n {f4c430}“опливо: %d л\nѕродукты: %d кг\nћеталл:%d кг", Gm::Info[Gm::FactoryFuel], Gm::Info[Gm::FactoryProds], Gm::Info[Gm::FactoryMetal]);
	UpdateDynamic3DTextLabelText(FactoryInfo[1], -1, string);
	return 1;
}


stock ShowLMenu(playerid, dialogid=D_LMENU-1) {
	dialog[0] = '\0';
	new fracid = Pl::FracID(playerid);
	switch(dialogid) {
	case D_LMENU-1 : {
			if(isTeamVehicle(fracid, GetPlayerVehicleID(playerid))) {
				strcat(dialog, ""#_GREY_ARROW"“ранспорт\n");
			}
			strcat(dialog, ""#_GREY_ARROW"–анги\n");
			switch(Pl::FracID(playerid)) {
			case 1..4, 7, 10 : {
					scf(dialog, temp, ""#_GREY_ARROW"–анг новостей {AA3333}[%i]\n", GetGRank(fracid));
				}
			case 5, 6, 13 : {
					strcat(dialog, ""#_GREY_ARROW"„ерный список\n");
				}

			case 11 : {
					scf(dialog, temp, ""#_GREY_ARROW"–анг новостей {AA3333}[%i]\n", GetGRank(fracid));
					strcat(dialog, ""#_GREY_ARROW"”правление автошколой\n");
				}
			case 12, 14..19 : {
					strcat(dialog, ""#_GREY_ARROW"„ерный список\n");
					scf(dialog, temp, ""#_GREY_ARROW"–анг захвата {AA3333}[%i]\n", GetZRank(fracid));
				}
			}
			SPD(playerid, dialogid, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": LEADER MENU", dialog, "SELECT", "CANCEL");
		}

	case D_LMENU+9 : {
			format(dialog, sizeof dialog, ""#_GREY_ARROW"–анг дл€ добавлени€ в „— {AA3333}[%i]\n"#_GREY_ARROW"—умма выхода из „— {AA3333}[$%i]\n"#_GREY_ARROW"”бийств дл€ выхода из „— {AA3333}[%i]",
			GetBRank(fracid), FracInfo[fracid][fBConf][bPRICE], FracInfo[fracid][fBConf][bKILLS]);
			SPD(playerid, D_LMENU+9, DIALOG_STYLE_LIST, "L-Menu. „ерный список", dialog, "SELECT", "CANCEL");
		}
	}
	return 1;
}

stock updateBenzinTD(playerid, vehicleid) {
	if(0 <= playerid <= MAX_PLAYERS) {
		if(1 <= vehicleid <= MAX_VEHICLES) {
			format(temp, sizeof temp, (AutoInfo[vehicleid][aFuel] < 16.0)?("~w~Benzin: ~r~%.1fL"):("~w~Benzin: ~b~%.1fL"), AutoInfo[vehicleid][aFuel]);
			Pt::SetString(playerid, Pt::Fuel[playerid], temp);
		}
	}
	return 1;
}

stock ShowCantina(playerid) {
	dialog[0] = '\0';
	if(Pl::FracID(playerid) == 3) {
		for(new i; i < sizeof EatInfo; i++) {
			scf(dialog, temp, ""#_GREY_ARROW" %s\n", EatInfo[i][bDescription], EatInfo[i][bPrice]);
		}
	} else {
		for(new i; i < sizeof EatInfo; i++) {
			scf(dialog, temp, ""#_GREY_ARROW" %s ({33AA33}%i${FFFFFF})\n", EatInfo[i][bDescription], EatInfo[i][bPrice]);
		}
	}
	return SPD(playerid, 149, 2, "—толова€", dialog, "¬з€ть", "ќтмена");
}

public: OnPlayerBankTransfer(playerid) {
	if(Pl::isLogged(playerid)) {
		if(GetPVarInt(playerid, "TransferPlayer")) {
			SetPVarInt(playerid, "TransferPlayer", INVALID_PLAYER_ID);
			SetPVarInt(playerid, "TransferAmount", 0);
		}
	}
}

stock ShowLoginForm(playerid, id) {
	switch(id) {
	case 0 : {
			format(dialog, sizeof dialog, "\tƒл€ регистрации персанажа %s\n\
			\tвведите пароль и нажите \"REGISTER\"\n\nЌе рекомендуетс€ использовать простые пароли. „тобы\n\
			ѕароль был надежным, он должен содержать цифры, \nзаглавные и малые буквы латинского алфавита.", GetName(playerid));
			SPD(playerid, D_REGG + 1, 1, ""#__SERVER_PREFIX""#__SERVER_NAME_C" REGISTRATION", dialog, "REGISTER", "CANCEL");
		}

	case 1 : {
			format(dialog, sizeof dialog, "¬ы зашли как %s! ѕожалуйста, авторизуйтесь!\n¬ случаии 3-х кратного неверного ввода  » !\n\
			ќталось папыток ввода: %i", GetName(playerid), WrongLogin[playerid]);
			SPD(playerid, D_AUTH, DIALOG_STYLE_PASSWORD, ""#__SERVER_PREFIX""#__SERVER_NAME_C" AUTORISATION. ¬ведите ваш пароль!", dialog, "LOGIN", "CANCEL");
		}

	case 2 : {
			ShowDialog(playerid, D_REGG, DIALOG_STYLE_MSGBOX, "ѕравила сервера", "dialog/rules.txt", "I AGREE", "CANCEL");
		}
	}
	return 1;
}

public: LoadExtraVehicles(playerid) {
	new rows = cache_get_row_count();
	if(rows) {
		for(new i; i < rows; i++) {
			cache_get_int(i, 0, ExtraVehicles[playerid][i][evID1]);
			cache_get_int(i, 1, ExtraVehicles[playerid][i][evOwner]);
			cache_get_int(i, 2, ExtraVehicles[playerid][i][evModel]);
			cache_get_int(i, 3, ExtraVehicles[playerid][i][evPark]);
			cache_get_str(i, 4, "p<,>ii", ExtraVehicles[playerid][i][evColor1], ExtraVehicles[playerid][i][evColor2]);
			cache_get_str(i, 5, "p<,>ffff", ExtraVehicles[playerid][i][evSpawnX], ExtraVehicles[playerid][i][evSpawnY], ExtraVehicles[playerid][i][evSpawnZ], ExtraVehicles[playerid][i][evSpawnA]);

			if(ExtraVehicles[playerid][i][evPark] == PARK_HOME) {
				ExtraVehicles[playerid][i][evID2] = Veh::Create(
				ExtraVehicles[playerid][i][evModel],
				ExtraVehicles[playerid][i][evSpawnX],
				ExtraVehicles[playerid][i][evSpawnY],
				ExtraVehicles[playerid][i][evSpawnZ],
				ExtraVehicles[playerid][i][evSpawnA],
				ExtraVehicles[playerid][i][evColor1],
				ExtraVehicles[playerid][i][evColor2],
				INFINITY
				);
				AutoInfo[ExtraVehicles[playerid][i][evID2]][aOwner] = playerid;
				SetVehicleNumber(ExtraVehicles[playerid][i][evID2]);
				SetVehicleNumber(ExtraVehicles[playerid][i][evID2]);
				ToggleVehicleDoor(ExtraVehicles[playerid][i][evID2], false);

			} else if((ExtraVehicles[playerid][i][evPark] / Pl::Info[playerid][pHouseKey]) == PARK_HOME_GARAGE) {
				ExtraVehicles[playerid][i][evID2] = Veh::Create(
				ExtraVehicles[playerid][i][evModel],
				ExtraVehicles[playerid][i][evSpawnX],
				ExtraVehicles[playerid][i][evSpawnY],
				ExtraVehicles[playerid][i][evSpawnZ],
				ExtraVehicles[playerid][i][evSpawnA],
				ExtraVehicles[playerid][i][evColor1],
				ExtraVehicles[playerid][i][evColor2],
				INFINITY
				);
				AutoInfo[ExtraVehicles[playerid][i][evID2]][aOwner] = playerid;
				SetVehicleNumber(ExtraVehicles[playerid][i][evID2]);
				ToggleVehicleDoor(ExtraVehicles[playerid][i][evID2], false);
				LinkVehicleToInterior(ExtraVehicles[playerid][i][evID2], 3);
				SetVehicleVirtualWorld(ExtraVehicles[playerid][i][evID2], Pl::Info[playerid][pHouseKey]);

			} else {
				AddExtraVehicleToGarage(playerid, i);
				ExtraVehicles[playerid][i][evID2] = INVALID_VEHICLE_ID;
			}
			Iter::Add(ExtraVehicles[playerid], i);
		}
		TotalExtraVehicles[playerid] = rows;
	}
	return 1;
}

stock AddExtraVehicle(playerid, model, Float:spawn_x, Float:spawn_y, Float:spawn_z, Float:spawn_a, color1, color2, park = PARK_GARAGE, create = 1, resptime = INFINITY) {
	if(Pl::isLogged(playerid)) {
		if(TotalExtraVehicles[playerid] < MAX_EXTRA_VEHICLES) {
			new id = TotalExtraVehicles[playerid] ++;
			format(query, sizeof query, "INSERT INTO `"#__TableExtraVehicles__"` (`owner`,`model`,`park`,`color`,`spawn`) VALUES (");
			scf(query, temp, "'%i',", Pl::Info[playerid][pID]);
			scf(query, temp, "'%i',", model);
			scf(query, temp, "'%i',", park);
			scf(query, temp, "'%i,%i',", color1, color2);
			scf(query, temp, "'%.3f,%.3f,%.3f,%.3f')", spawn_x, spawn_y, spawn_z, spawn_a);
			new Cache:result = Db::query(connDb, query, true);

			ExtraVehicles[playerid][id][evID1] = cache_insert_id();
			ExtraVehicles[playerid][id][evModel] = model;
			ExtraVehicles[playerid][id][evOwner] = Pl::Info[playerid][pID];
			ExtraVehicles[playerid][id][evPark] = park;
			ExtraVehicles[playerid][id][evColor1] = color1;
			ExtraVehicles[playerid][id][evColor2] = color2;
			ExtraVehicles[playerid][id][evSpawnX] = spawn_x;
			ExtraVehicles[playerid][id][evSpawnY] = spawn_y;
			ExtraVehicles[playerid][id][evSpawnZ] = spawn_z;
			ExtraVehicles[playerid][id][evSpawnA] = spawn_a;

			if(create) {
				ExtraVehicles[playerid][id][evID2] = Veh::Create(model, spawn_x, spawn_y, spawn_z, spawn_a, color1, color2, resptime);
				AutoInfo[ExtraVehicles[playerid][id][evID2]][aOwner] = playerid;
				SetVehicleNumber(ExtraVehicles[playerid][id][evID2]);
			} else {
				AddExtraVehicleToGarage(playerid, id);
				ExtraVehicles[playerid][id][evID2] = INVALID_PLAYER_ID;
			}

			Iter::Add(ExtraVehicles[playerid], id);
			cache_delete(result);
			return id;
		}
	}
	return INVALID_VEHICLE_ID;
}

stock AddExtraVehicleToGarage(playerid, slot) {
	if(TotalVehicleInGarage[playerid] < MAX_EXTRA_VEHICLES) {
		for(new i; i < TotalVehicleInGarage[playerid]; i++) {
			if(VehicleInGarage[playerid][i] == slot) return 1;
		}
		VehicleInGarage[playerid][TotalVehicleInGarage[playerid]++] = slot;
	}
	return 1;
}

stock RemoveExtraVehicleFromGarage(playerid, slot) {
	if(0 <= slot < MAX_EXTRA_VEHICLES) {
		for(new i; i < TotalVehicleInGarage[playerid]; i++) {
			if(VehicleInGarage[playerid][i] == slot) {
				VehicleInGarage[playerid][i] = VehicleInGarage[playerid][--TotalVehicleInGarage[playerid]];
				return 1;
			}
		}
	}
	return 1;
}

stock RemoveExtraVehicle(playerid, slot) {
	if(0 <= slot < MAX_EXTRA_VEHICLES) {
		format(query, sizeof query, "DELETE FROM `"#__TableExtraVehicles__"` WHERE `owner` = '%i' AND `id` = '%i'", Pl::Info[playerid][pID], ExtraVehicles[playerid][slot][evID1]);
		Db::tquery(connDb, query, "", "");

		Veh::Destroy(ExtraVehicles[playerid][slot][evID2]);
		new i = --TotalExtraVehicles[playerid];

		ExtraVehicles[playerid][slot][evID1] = ExtraVehicles[playerid][i][evID1];
		ExtraVehicles[playerid][slot][evID2] = ExtraVehicles[playerid][i][evID2];
		ExtraVehicles[playerid][slot][evOwner] = ExtraVehicles[playerid][i][evOwner];
		ExtraVehicles[playerid][slot][evModel] = ExtraVehicles[playerid][i][evModel];
		ExtraVehicles[playerid][slot][evPark] = ExtraVehicles[playerid][i][evPark];
		ExtraVehicles[playerid][slot][evColor1] = ExtraVehicles[playerid][i][evColor1];
		ExtraVehicles[playerid][slot][evColor2] = ExtraVehicles[playerid][i][evColor2];
		ExtraVehicles[playerid][slot][evSpawnX] = ExtraVehicles[playerid][i][evSpawnX];
		ExtraVehicles[playerid][slot][evSpawnY] = ExtraVehicles[playerid][i][evSpawnY];
		ExtraVehicles[playerid][slot][evSpawnZ] = ExtraVehicles[playerid][i][evSpawnZ];
		ExtraVehicles[playerid][slot][evSpawnA] = ExtraVehicles[playerid][i][evSpawnA];
		RemoveExtraVehicleFromGarage(playerid, i);
		Iter::Remove(ExtraVehicles[playerid], i);

		if(ExtraVehicles[playerid][slot][evPark] == PARK_GARAGE) {
			AddExtraVehicleToGarage(playerid, slot);
		} else {
			RemoveExtraVehicleFromGarage(playerid, slot);
		}
		return 1;
	}
	return 0;
}

stock UpdateExtraVehicle(playerid, slot) {
	if(0 <= slot < MAX_EXTRA_VEHICLES) {
		format(query, sizeof query, "UPDATE `"#__TableExtraVehicles__"` SET ");
		scf(query, temp, "`owner`='%i',", ExtraVehicles[playerid][slot][evOwner]);
		scf(query, temp, "`model`='%i',", ExtraVehicles[playerid][slot][evModel]);
		scf(query, temp, "`park`='%i',", ExtraVehicles[playerid][slot][evPark]);
		scf(query, temp, "`color`='%i,%i',", ExtraVehicles[playerid][slot][evColor1], ExtraVehicles[playerid][slot][evColor2]);
		scf(query, temp, "`spawn`='%.3f,%.3f,%.3f,%.3f' ", ExtraVehicles[playerid][slot][evSpawnX], ExtraVehicles[playerid][slot][evSpawnY], ExtraVehicles[playerid][slot][evSpawnZ], ExtraVehicles[playerid][slot][evSpawnA]);
		scf(query, temp, "WHERE `id` = '%i'", ExtraVehicles[playerid][slot][evID1]);
		Db::tquery(connDb, query, "", "");
	}
	return 1;
}

stock ShowExtraVehiclesMenu(playerid, dialogid=D_EV_MENU) {
	switch(dialogid) {
	case D_EV_MENU : {
			dialog[0] = '\0';
			new listitem;
			foreach(new i : ExtraVehicles[playerid]) {
				format(temp, sizeof temp, "extra[%i]", listitem++), SetPVarInt(playerid, temp, i);
				if(ExtraVehicles[playerid][i][evID2] != INVALID_VEHICLE_ID) {
					scf(dialog, temp, "%s %s %s\n", VehicleNames[ExtraVehicles[playerid][i][evModel] - 400],\
					gCarLock{ExtraVehicles[playerid][i][evID2]} ? ("{AA3333}[закрыт]") : ("{33AA33}[открыт]"),\
					ExtraVehicles[playerid][i][evPark] == PARK_HOME ? ("{33AA33}[домашний]") : (" "));
				} else {
					scf(dialog, temp, "%s {AA3333}[закрыт] [в гараже]\n", VehicleNames[ExtraVehicles[playerid][i][evModel] - 400]);
				}
			}
			if(!strlen(dialog)) return Send(playerid, COLOR_GREY, "* ” ¬ас нет доп. машин!");
			SPD(playerid, D_EV_MENU, DIALOG_STYLE_LIST, "¬аш личный транспорт", dialog, "SELECT", "CANCEL");
		}
	}
	return 1;
}


stock IsPlayerTakeExtraVehicle(playerid) {
	foreach(new i : ExtraVehicles[playerid]) {
		if(ExtraVehicles[playerid][i][evID2] != INVALID_VEHICLE_ID && ExtraVehicles[playerid][i][evPark] == PARK_GARAGE) {
			return 1;
		}
	}
	return 0;
}

stock GetIdxExtraVehicleFromVehicleID(playerid, vehicleid) {
	foreach(new i : ExtraVehicles[playerid]) {
		if(ExtraVehicles[playerid][i][evID2] == vehicleid) {
			return i;
		}
	}
	return -1;
}

stock IsPlayerInHouseGarage(playerid) {
	return (IsPlayerInRangeOfPoint(playerid, 10.0, 616.0352, -124.1155, 997.7648) && Pl::Info[playerid][pLocal] == (OFFSET_HOUSE + Pl::Info[playerid][pHouseKey]));
}

stock GetPlayerPosEx(playerid, &Float:x, &Float:y, &Float:z, &Float:a) {
	new veh = GetPlayerVehicleID(playerid);
	if(veh != 0) {
		GetVehiclePos(veh, x, y, z);
		GetVehicleZAngle(veh, a);
	} else {
		GetPlayerPos(playerid, x, y, z);
		GetPlayerFacingAngle(playerid, a);
	}
	return 1;
}

stock LoadGates()
{
	for(new i; i < MAX_FRAC_GATE; i++)
	{
		for(new j; j < MAX_FRAC; j++)
		{
			SET_GATE_ACCESS(i, j, 0);
		}
	}

	new gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-2655.23974609,-224.56163025,6.21994114,0.0,0.0,0.0}, Float:{-2655.4502,-226.9722,-2.0665,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2654.1416,-233.0185,4.7038}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2656.9939,-220.3907,3.9517}, 0);
	SET_GATE_ACCESS(gateid, TEAM_RUSSIAN, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-2801.18750000,-329.59487915,8.81994534,0.0,0.0,88.25}, Float:{-2800.2183,-330.0354,-1.0900,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2807.0947,-331.3463,6.7380}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2794.3726,-328.2372,6.7450}, 0);
	SET_GATE_ACCESS(gateid, TEAM_RUSSIAN, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{952.16387939,-1098.89575195,24.20000076,0.0,0.0,270.0}, Float:{952.28033447,-1091.89526367,24.20000076,-1000.0,-1000.0,-1000.0}, 0);
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{952.30175781,-1106.84375000,24.21918869,0.0,0.0,271.9}, Float:{952.06695557,-1114.79016113,24.21918869,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{957.4088,-1100.7209,23.7031}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{946.1330,-1104.5739,24.2657}, 0);
	SET_GATE_ACCESS(gateid, TEAM_BALLAS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{1810.3319091797,-1885.6104736328,14.4115,0.0,0.0,270.0}, Float:{1810.3319091797,-1880.7103271484,14.41153,-1000.0,-1000.0,-1000.0}, 0);
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{1810.3541259766,-1893.5799560547,14.4054,0.0,0.0,270.0}, Float:{1810.3541259766,-1898.8791503906,14.405469,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1816.4958,-1886.7698,13.4141}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1805.3655,-1891.8104,13.4079}, 0);
	SET_GATE_ACCESS(gateid, TEAM_CORONOS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-1644.6872558594, 682.34130859375, 9.4969673156738, 0.0, 0.0, 90.0}, Float:{-1644.6865234375, 682.3408203125, 1.9969673156738,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1639.8580,684.3269,7.1875}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1649.8622,679.5843,9.5154}, 0);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-1571.8803710938, 661.48571777344, 8.9608917236328, 0.0, 0.0, 270.67565917969}, Float:{-1571.8798828125, 661.4853515625, 1.7108917236328,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1567.8168,663.8288,7.1875}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1577.6217,660.2245,7.1901}, 0);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{-1050.39794922,-1345.34973145,131.0,0.0,0.0,335.0}, Float:{-1043.14575195,-1348.43676758,131.0,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1049.9319,-1349.2209,129.8002}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1050.5951,-1339.5038,130.0538}, 0);
	SET_GATE_ACCESS(gateid, TEAM_FARMERS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-2127.4970703125,-80.352951049805,37.093704223633,0.0,0.0,0.0}, Float:{-2127.4970703125,-80.3525390625,30.093704223633,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2130.9324,-75.0402,34.8844}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2123.7227,-85.2543,35.0273}, 0);
	SET_GATE_ACCESS(gateid, TEAM_RIFA, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 986, Float:{2439.3210449219,-1664.3826904297,14.108180999756,0.0,0.0,90.0}, Float:{2439.3210449219,-1668.0817871094,14.108180999756,-1000.0,-1000.0,-1000.0}, 0);
	AddLeafToGate(FracGate[gateid][GateID], 985, Float:{2439.31640625,-1656.4501953125,14.104577064514,0.0,0.0,90.0}, Float:{2439.31640625,-1649.9501953125,14.104577064514,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{2447.4922,-1656.3556,13.3047}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{2428.3591,-1661.5132,13.3828}, 0);
	SET_GATE_ACCESS(gateid, TEAM_GROVE, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{1017.50000000,2133.40820312,12.59399986,0.0,0.0,90.0}, Float:{1017.47497559,2133.40698242,6.59399986,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1011.7426,2132.1584,10.6719}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1022.4524,2135.8928,10.8203}, 0);
	SET_GATE_ACCESS(gateid, TEAM_STREETDOGS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 985, Float:{2797.19482422,-1599.36096191,11.63015938,0.0,0.0,1.25}, Float:{2802.63452148,-1598.97546387,11.63015938,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{2797.1755,-1604.2877,10.9304}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{2797.2551,-1592.6169,10.9290}, 0);
	SET_GATE_ACCESS(gateid, TEAM_VAGOS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{1264.04602051,-2048.85009766,61.09500122,0.0,0.0,0.0}, Float:{1264.04602051,-2048.85009766,65.87000275,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1265.8107,-2052.7319,59.2848}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1261.8234,-2041.6759,59.3539}, 0);
	SET_GATE_ACCESS(gateid, TEAM_LCN, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{1525.08374023,2773.18920898,12.44526672,0.0,0.0,90.0}, Float:{1524.80664062,2773.15625000,6.44526672,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1516.4744,2770.6680,10.6719}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1531.0181,2775.5930,10.6719}, 0);
	SET_GATE_ACCESS(gateid, TEAM_YAKUZA, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 10184, Float:{773.53601074,-1330.10705566,13.92199993,0.0,0.0,268.75}, Float:{765.56298828,-1329.99401855,13.92199993,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{779.1375,-1336.2466,13.7000}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{775.9797,-1325.6351,13.5469}, 0);
	SET_GATE_ACCESS(gateid, TEAM_PRESS, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 10184, Float:{-2666.6979980469,577.875,15.800000190735,0.0,0.0,90.0}, Float:{-2666.6979980469, 577.875, 20.325000762939,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2669.3008,583.7839,14.4545}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-2665.1614,573.7731,14.4621}, 0);
	SET_GATE_ACCESS(gateid, TEAM_MEDIC, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{-1771.3582763672, 985.01013183594,25.74254989624,0.0,0.0,91.309509277344}, Float:{-1771.3575439453,985.03479003906,32.24254989624,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1763.2059,987.0810,21.6091}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{-1776.1466,981.9849,23.2704}, 0);
	SET_GATE_ACCESS(gateid, TEAM_TAXI, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	new leafid = AddLeafToGate(FracGate[gateid][GateID], 968, Float:{1544.69995117, -1630.80004883,13.10000038,0.0,270.0,270.0}, Float:{1544.69921875,-1630.79980469,13.10000038, 0.0,0.0,270.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1537.6506,-1629.3037,13.0889}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1549.0046,-1626.0970,13.0881}, 0);
	SetLeafType(FracGate[gateid][GateID], leafid, TYPE_BARRIER);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{1544.07495117,-1841.32495117,15.31999969,0.0,0.0,268.75}, Float:{1544.00305176,-1848.04101562,15.31999969, -1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1548.6178,-1837.7350,13.5469}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1538.5789,-1840.9468,13.5469}, 0);
	SET_GATE_ACCESS(gateid, TEAM_GOV, 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 988, Float:{96.800,1920.376,18.183,0.0,0.0,-90.000}, Float:{96.934,1920.112,13.026, -1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{98.7371,1922.6504,18.2074}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{93.5390,1919.1776,18.0495}, 0);
	SET_GATE_ACCESS(gateid, TEAM_ARMY, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2927, Float:{211.95550537,1875.55676270,13.93265820,0.0,0.0,0.0}, Float:{207.70809937,1875.70617676,13.93265820, -1000.0,-1000.0,-1000.0}, 0);
	AddLeafToGate(FracGate[gateid][GateID], 2927, Float:{216.06652832,1875.56518555,13.93265820,0.0,0.0,0.0}, Float:{220.31614685,1875.51049805,13.93265820, -1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{212.1943,1879.5664,13.1406}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{215.3050,1871.1914,13.1406}, 0);
	SET_GATE_ACCESS(gateid, TEAM_ARMY, 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 980, Float:{1590.0573730469, -1637.974609375, 14.743314743042,0.0,0.0,0.0}, Float:{1590.056640625,-1637.974609375,7.3683304786682,-1000.0,-1000.0,-1000.0}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1590.2843,-1641.8308,12.9507}, 0);
	AddPickupToGate(FracGate[gateid][GateID], 1239, Float:{1586.6178,-1634.0077,13.3828}, 0);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);


	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{228.24499512,151.34700012,1003.64300537,0.0,0.0,269.5}, Float:{228.24400330,151.34700012,1006.19598389,0.0,0.0,269.4}, 2);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{228.21899414,161.11799622,1003.64300537,0.0,0.0,270.2}, Float:{228.21899414,161.11700439,1006.19598389,0.0,0.0,270.2}, 2);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{230.89100647,169.83099365,1003.64300537,0.0,0.0,180.0}, Float:{230.89100647,169.83000183,1006.19598389,0.0,0.0,179.9}, 2);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{275.57101440,189.32000732,1007.79199219,0.0,0.0,0.0}, Float:{275.57000732,189.31900024,1010.26898193,0.0,0.0,0.0}, 2);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{296.51800537,189.32499695,1007.79199219,0.0,0.0,0.0}, Float:{296.51800537,189.32400513,1010.29400635,0.0,0.0,0.0}, 2);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2957, Float:{247.005905,72.448440,1003.640625,0.0,0.0,1260.0}, Float:{247.005905,72.448440,1006.912902,-1000.0,-1000.0,-1000.0}, 1);
	for(new i; i < sizeof Teams; i++) SET_GATE_ACCESS(gateid, Teams[i], 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 1566, Float:{363.94100952148,187.08000183105,1020.125,0.0,0.0,0.0}, Float:{362.40301513672,187.05000305176,1020.125,-1000.0,-1000.0,-1000.0}, 4);
	SET_GATE_ACCESS(gateid, TEAM_MEDIC, 1);

	gateid = FracGateCount++;
	FracGate[gateid][GateID] = CreateGate();
	AddLeafToGate(FracGate[gateid][GateID], 2949, Float:{372.75192261,166.50007629,1007.38281250,0.0,0.0,270.0}, Float:{374.19226074, 166.50007629, 1007.38281250,-1000.0,-1000.0,-1000.0}, 7);
	SET_GATE_ACCESS(gateid, TEAM_GOV, 1);

	return 1;
}


public: EnterHouse(playerid, house) {
	Pl::Info[playerid][pLocal] = OFFSET_HOUSE + house;
	new Float:x, Float:y;
	GetXYInFrontOfPoint(x, y, HouseInfo[house][hExit][3], 1.3);
	Rac::SetPlayerPos(playerid, HouseInfo[house][hExit][0] + x, HouseInfo[house][hExit][1] + y, HouseInfo[house][hExit][2]);
	SetPlayerFacingAngle(playerid, HouseInfo[house][hExit][3]);
	Rac::SetPlayerInterior(playerid, HouseInfo[house][hInt]);
	Rac::SetPlayerVirtualWorld(playerid, HouseInfo[house][hVirtual]);
	SetCameraBehindPlayer(playerid);
	return 1;
}

public: ExitHouse(playerid, house) {
	Pl::Info[playerid][pLocal] = 0;
	new Float:x, Float:y;
	GetXYInFrontOfPoint(x, y, HouseInfo[house][hEnter][3], 1.3);
	Rac::SetPlayerPos(playerid, HouseInfo[house][hEnter][0] + x, HouseInfo[house][hEnter][1] + y, HouseInfo[house][hEnter][2]);
	SetPlayerFacingAngle(playerid, HouseInfo[house][hEnter][3]);
	Rac::SetPlayerInterior(playerid, 0);
	Rac::SetPlayerVirtualWorld(playerid, 0);
	SetCameraBehindPlayer(playerid);
	BlockPickupForPlayer(playerid, HouseInfo[house][hPickup]);
	return 1;
}

public: EnterBiz(playerid, biz) {
	Pl::Info[playerid][pLocal] = OFFSET_BIZZ + biz;
	new Float:x, Float:y;
	if(BizzInfo[biz][bID] == 14)
	{
	    if(!IsACop(playerid)) return Send(playerid, COLOR_GREY, "* ¬ы не входите в ѕќ!");
	    GetXYInFrontOfPoint(x, y, BizzInfo[biz][bExit][3], 1.3);
		Rac::SetPlayerInterior(playerid,BizzInfo[biz][bInterior]);
		Rac::SetPlayerVirtualWorld(playerid, BizzInfo[biz][bVirtual]);
		Rac::SetPlayerPos(playerid, BizzInfo[biz][bExit][0] + x, BizzInfo[biz][bExit][1] + y, BizzInfo[biz][bExit][2]);
		SetPlayerFacingAngle(playerid, BizzInfo[biz][bExit][3]);
		SetCameraBehindPlayer(playerid);
		BlockPickupForPlayer(playerid, BizzInfo[biz][bPickupExit]);
	}
	GetXYInFrontOfPoint(x, y, BizzInfo[biz][bExit][3], 1.3);
	Rac::SetPlayerInterior(playerid,BizzInfo[biz][bInterior]);
	Rac::SetPlayerVirtualWorld(playerid, BizzInfo[biz][bVirtual]);
	Rac::SetPlayerPos(playerid, BizzInfo[biz][bExit][0] + x, BizzInfo[biz][bExit][1] + y, BizzInfo[biz][bExit][2]);
	SetPlayerFacingAngle(playerid, BizzInfo[biz][bExit][3]);
	SetCameraBehindPlayer(playerid);
	BlockPickupForPlayer(playerid, BizzInfo[biz][bPickupExit]);
	return 1;
}

public: ExitBiz(playerid, biz) {
	Pl::Info[playerid][pLocal] = 0;
	new Float:x, Float:y;
	GetXYInFrontOfPoint(x, y, BizzInfo[biz][bEnter][3], 1.3);
	Rac::SetPlayerInterior(playerid, 0);
	Rac::SetPlayerVirtualWorld(playerid, 0);
	Rac::SetPlayerPos(playerid, BizzInfo[biz][bEnter][0] + x, BizzInfo[biz][bEnter][1] + y, BizzInfo[biz][bEnter][2]);
	SetPlayerFacingAngle(playerid, BizzInfo[biz][bEnter][3]);
	SetCameraBehindPlayer(playerid);
	BlockPickupForPlayer(playerid, BizzInfo[biz][bPickupEnter]);
	return 1;
}

stock ShowFracBank(playerid) {
	dialog[0] = '\0';
	for(new i; i < sizeof(FracID); i++) scf(dialog, temp, "%s\n", FracInfo[FracID[i]][fName]);
	return SPD(playerid, D_FBANK, DIALOG_STYLE_LIST, ""#__SERVER_PREFIX""#__SERVER_NAME_LC": Bank", dialog, "ENTER", "CANCLE");
}


stock GiveBizzProfit(biz, money) {
	BizzInfo[biz][bProfit] += money;
	BizzInfo[biz][bSafe] += money;
	return 1;
}

/*
stock DeleteHouse(i) {
	Iter::Remove(Houses, i);
	new last = Iter::Count(Houses);
	HouseInfo[h][hID] = HouseInfo[last][hID];
	HouseInfo[h][hOwned] = HouseInfo[last][hOwned];
	HouseInfo[h][hLock] = HouseInfo[last][hLock];
	strmid(HouseInfo[h][hOwner], HouseInfo[last][hOwner], 0, strlen(HouseInfo[last][hOwner]), 24);
	strmid(HouseInfo[h][hDescription], HouseInfo[last][hDescription], 0, strlen(HouseInfo[last][hDescription]), 24);
	HouseInfo[h][hPrice] = HouseInfo[last][hPrice];
	HouseInfo[h][hLevel] = HouseInfo[last][hLevel];
	HouseInfo[h][hInt] = HouseInfo[last][hInt];
	HouseInfo[h][hTv] = HouseInfo[last][hTv];
	HouseInfo[h][hDate] = HouseInfo[last][hDate];
	CopyArray(HouseInfo[h][hRent], HouseInfo[last][hRent], 2);
	CopyArray(HouseInfo[h][hSafe], HouseInfo[last][hSafe], 5);
	CopyArray(HouseInfo[h][hGuns], HouseInfo[last][hGuns], MAX_HWEAP);
	CopyArray(HouseInfo[h][hAmmos], HouseInfo[last][hAmmos], MAX_HWEAP);
	CopyArray(HouseInfo[h][hEnter], HouseInfo[last][hEnter], 4);
	CopyArray(HouseInfo[h][hExit], HouseInfo[last][hExit], 4);
	HouseInfo[h][hvModel] = HouseInfo[last][hvModel];
	CopyArray(HouseInfo[h][hvColor], HouseInfo[last][hvColor], 2);
	CopyArray(HouseInfo[h][hvSpawn], HouseInfo[last][hvSpawn], 4);
	HouseInfo[h][hvPark] = HouseInfo[last][hvPark];
	CopyArray(HouseInfo[h][hvSpawn], HouseInfo[last][hvSpawn], 4);

	HouseInfo[h][hgGarage] = HouseInfo[last][hgGarage];
	CopyArray(HouseInfo[h][hgIntPos], HouseInfo[last][hgIntPos], 4);
	CopyArray(HouseInfo[h][hgStreetPos], HouseInfo[last][hgStreetPos], 4);
	HouseInfo[h][hgPickupInt] = HouseInfo[last][hgPickupInt];
	HouseInfo[h][hgPickupStreet] = HouseInfo[last][hgPickupStreet];

	HouseInfo[h][hPickup] = HouseInfo[h][hPickup];
	HouseInfo[h][hMapIcon] = HouseInfo[h][hMapIcon];
	HouseInfo[h][hVirtual] = HouseInfo[h][hVirtual];
	HouseInfo[h][hAuto] = HouseInfo[h][hAuto];

	format(query, sizeof query, "UPDATE `houses` SET `id` = '%i' WHERE `id`")
	Db::tquery(connDb, query);
}*/

stock UpdateSpeedometer(playerid, speed) {
	switch(speed) {
	case 0..9: Pt::SetString(playerid, Pt::Speed[playerid][0], "~w~~h~I");
	case 10..14: Pt::SetString(playerid, Pt::Speed[playerid][0], "~w~~h~II");
	case 15..19: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~III");
	case 20..24: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~IIII");
	case 25..29: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~IIIII");
	case 30..34: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~IIIIII");
	case 35..39: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~IIIIIII");
	case 40..44: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~IIIIIIII");
	case 45..49: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~~h~IIIIIIIII");
	case 50..59: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~~h~IIIIIIIIII");
	case 60..64: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~~h~IIIIIIIIIII");
	case 65..69: Pt::SetString(playerid, Pt::Speed[playerid][0], "~g~~h~~h~IIIIIIIIIIII");
	case 70..79: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~IIIIIIIIIIIII");
	case 80..89: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~IIIIIIIIIIIIII");
	case 90..99: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIII");
	case 100..109: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIII");
	case 110..119: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIII");
	case 120..129: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIIII");
	case 130..139: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIIIII");
	case 140..149: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIIIIII");
	case 150..164: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIIIIIII");
	case 165..174: Pt::SetString(playerid, Pt::Speed[playerid][0], "~y~~h~IIIIIIIIIIIIIIIIIIIIII");
	case 175..189: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~IIIIIIIIIIIIIIIIIIIIIII");
	case 190..199: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~IIIIIIIIIIIIIIIIIIIIIIII");
	case 200..209: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~IIIIIIIIIIIIIIIIIIIIIIIII");
	case 210..219: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~IIIIIIIIIIIIIIIIIIIIIIIIII");
	case 220..229: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~IIIIIIIIIIIIIIIIIIIIIIIIIII");
	case 230..239: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~~h~IIIIIIIIIIIIIIIIIIIIIIIIIIII");
	case 240..249: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~~h~IIIIIIIIIIIIIIIIIIIIIIIIIIIII");
	default: Pt::SetString(playerid, Pt::Speed[playerid][0], "~r~~h~~h~IIIIIIIIIIIIIIIIIIIIIIIIIIIII");
	}
	return 1;
}

stock GetSkillLevel(playerid, skill) {
	new level = Pl::Info[playerid][pSkill][skill];
	if(level >= 0 && level <= 50) return 1;
	else if(level >= 51 && level <= 100) return 2;
	else if(level >= 101 && level <= 200) return 3;
	else if(level >= 201 && level <= 400) return 4;
	else if(level >= 401) return 5;
	return 1;
}

stock ShowRefillDialog(playerid, biz) {
	if(BizzInfo[biz][bProds] <= 0) return GameTextForPlayer(playerid, "~r~Out of stock", 5000, 1);
	format(dialog, sizeof dialog, "Ќа заправке имеетс€ %i литров.\n—тоимость 1 литра: %i$\n\n¬ведите количество литров, которое хотите заправить:",
	BizzInfo[biz][bProds] * 10, BizzInfo[biz][bEnterCost]/100);
	SPD(playerid, D_REFILL, DIALOG_STYLE_INPUT, BizzInfo[biz][bDescription], dialog, "ENTER", "CENCEL");
	SetCameraBehindPlayer(playerid);
	return 1;
}
//
forward CreateObjects();
public CreateObjects()
{
	// BankSasheRossi
CreateDynamicObject(1360, 1463.42, -1023.07, 23.60,   0.00, 0.00, 0.00);
CreateDynamicObject(1360, 1460.38, -1023.11, 23.60,   0.00, 0.00, 0.00);
CreateDynamicObject(9339, 1478.98, -1023.79, 23.53,   0.00, 0.00, 270.00);
CreateDynamicObject(9339, 1445.09, -1023.79, 23.53,   0.00, 0.00, 270.00);
CreateDynamicObject(19425, 1513.97, -1039.78, 22.64,   0.00, 0.00, 90.00);
CreateDynamicObject(19425, 1513.97, -1036.55, 22.63,   0.00, 0.00, 90.00);
CreateDynamicObject(19425, 1513.97, -1033.26, 22.64,   0.00, 0.00, 90.00);
CreateDynamicObject(19425, 1378.31, -1039.81, 25.47,   0.00, 0.00, 90.00);
CreateDynamicObject(19425, 1378.31, -1036.50, 25.48,   0.00, 0.00, 90.00);
CreateDynamicObject(19425, 1378.31, -1033.20, 25.48,   0.00, 0.00, 90.00);
CreateDynamicObject(1506, 1497.66, -895.45, 57.36,   0.00, 0.00, 14.90);
CreateDynamicObject(10184, 1287.00, -1006.00, 32.00,   0.00, 0.00, 270.25);
CreateDynamicObject(7191, 1296.10, -966.40, 35.00,   0.00, 0.00, 270.25);
CreateDynamicObject(10184, 1319.74, -1159.92, 23.38,   0.00, 0.00, 90.00);
CreateDynamicObject(10184, 1305.09, -1176.15, 24.63,   0.00, 0.00, 180.00);
CreateDynamicObject(3749, 1367.73, -853.01, 45.94,   0.00, 0.00, 34.98);
CreateDynamicObject(10671, 1367.63, -850.68, 44.10,   0.00, 0.00, 304.42);
CreateDynamicObject(7191, 1362.63, -827.38, 47.64,   0.00, 0.00, 210.59);
CreateDynamicObject(1597, 1291.35, -811.15, 89.97,   0.00, 0.00, 270.68);
CreateDynamicObject(1597, 1296.28, -805.81, 89.97,   0.00, 0.00, 0.00);

	/// –есторан
	///// Cтены(текстуры)
SetObjectMaterial(CreateObject(19451, 1480.20, -1364.82, 143.09,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19451, 1480.20, -1355.19, 143.09,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19451, 1476.81, -1352.35, 143.09,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19359, 1470.41, -1352.35, 143.09,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19451, 1469.71, -1355.21, 143.09,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19451, 1469.71, -1364.82, 143.09,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1474.97, -1369.59, 143.13,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1472.82, -1357.64, 143.13,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1473.52, -1358.36, 143.13,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1474.30, -1357.64, 143.13,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1473.56, -1356.92, 143.13,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1474.30, -1363.97, 143.13,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1473.59, -1364.68, 143.13,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1472.86, -1363.96, 143.13,0.00, 0.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19432, 1473.58, -1363.24, 143.13,0.00, 0.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll05", 0);
SetObjectMaterial(CreateObject(19378, 1474.99, -1364.85, 144.78,   0.00, 90.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(19378, 1474.94, -1355.22, 144.78,   0.00, 90.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(19378, 1474.99, -1364.85, 141.31,   0.00, 90.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll03", 0);
SetObjectMaterial(CreateObject(19378, 1474.94, -1355.22, 141.31,   0.00, 90.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll03", 0);

///// ќбьекты
CreateDynamicObject(2644, 1473.54, -1360.79, 141.79,   0.00, 0.00, 0.00);
CreateDynamicObject(1720, 1473.55, -1359.75, 141.40,   0.00, 0.00, -6.00);
CreateDynamicObject(1720, 1472.56, -1360.83, 141.40,   0.00, 0.00, 94.00);
CreateDynamicObject(1720, 1474.49, -1360.80, 141.40,   0.00, 0.00, -82.00);
CreateDynamicObject(1720, 1473.57, -1361.83, 141.40,   0.00, 0.00, 178.00);
CreateDynamicObject(2644, 1473.69, -1366.58, 141.79,   0.00, 0.00, 0.00);
CreateDynamicObject(1720, 1473.59, -1365.53, 141.40,   0.00, 0.00, -6.00);
CreateDynamicObject(1720, 1473.68, -1367.56, 141.40,   0.00, 0.00, -186.00);
CreateDynamicObject(1720, 1474.60, -1366.53, 141.40,   0.00, 0.00, -82.00);
CreateDynamicObject(1720, 1472.73, -1366.54, 141.40,   0.00, 0.00, 88.00);
CreateDynamicObject(16151, 1479.26, -1364.47, 141.72,   0.00, 0.00, 0.00);
CreateDynamicObject(2001, 1474.74, -1364.03, 141.37,   0.00, 0.00, 0.00);
CreateDynamicObject(2001, 1474.70, -1357.72, 141.37,   0.00, 0.00, 0.00);
CreateDynamicObject(2644, 1471.23, -1357.60, 141.79,   0.00, 0.00, 0.00);
CreateDynamicObject(1720, 1470.31, -1357.70, 141.40,   0.00, 0.00, 94.00);
CreateDynamicObject(1720, 1472.16, -1357.59, 141.40,   0.00, 0.00, -82.00);
CreateDynamicObject(1720, 1471.24, -1358.63, 141.40,   0.00, 0.00, 178.00);
CreateDynamicObject(1720, 1471.29, -1356.51, 141.40,   0.00, 0.00, -6.00);
CreateDynamicObject(2644, 1471.32, -1364.01, 141.79,   0.00, 0.00, 0.00);
CreateDynamicObject(1720, 1471.36, -1364.93, 141.40,   0.00, 0.00, 178.00);
CreateDynamicObject(1720, 1470.35, -1363.94, 141.40,   0.00, 0.00, 88.00);
CreateDynamicObject(1720, 1472.17, -1363.98, 141.40,   0.00, 0.00, -82.00);
CreateDynamicObject(1720, 1471.30, -1362.96, 141.40,   0.00, 0.00, -6.00);
CreateDynamicObject(2644, 1473.54, -1354.82, 141.79,   0.00, 0.00, 0.00);
CreateDynamicObject(1720, 1473.48, -1353.85, 141.40,   0.00, 0.00, -6.00);
CreateDynamicObject(1720, 1473.49, -1355.90, 141.40,   0.00, 0.00, 178.00);
CreateDynamicObject(1720, 1472.63, -1354.93, 141.40,   0.00, 0.00, 94.00);
CreateDynamicObject(1720, 1474.61, -1354.72, 141.40,   0.00, 0.00, -82.00);
CreateDynamicObject(2001, 1470.26, -1352.95, 141.37,   0.00, 0.00, 0.00);
CreateDynamicObject(1566, 1480.07, -1357.72, 142.69,   0.00, 0.00, 90.00);
CreateDynamicObject(1566, 1480.06, -1354.60, 142.69,   0.00, 0.00, -90.00);
CreateDynamicObject(2001, 1479.65, -1352.94, 141.37,   0.00, 0.00, 0.00);
CreateDynamicObject(3503, 1479.60, -1361.06, 143.61,   0.00, 0.00, 0.00);
CreateDynamicObject(1649, 1477.93, -1369.57, 143.05,   0.00, 0.00, 0.00);
CreateDynamicObject(1649, 1471.98, -1369.56, 143.05,   0.00, 0.00, 0.00);
CreateDynamicObject(1649, 1477.93, -1369.57, 143.05,   0.00, 0.00, 180.00);
CreateDynamicObject(1649, 1471.98, -1369.56, 143.05,   0.00, 0.00, 180.00);
CreateDynamicObject(1670, 1473.75, -1366.57, 142.23,   0.00, 0.00, 0.00);
CreateDynamicObject(1670, 1471.39, -1364.03, 142.23,   0.00, 0.00, 0.00);
CreateDynamicObject(1670, 1473.59, -1360.78, 142.23,   0.00, 0.00, 0.00);
CreateDynamicObject(1670, 1473.53, -1354.76, 142.23,   0.00, 0.00, 0.00);
CreateDynamicObject(1670, 1471.22, -1357.49, 142.23,   0.00, 0.00, 0.00);
CreateDynamicObject(1665, 1478.54, -1361.69, 142.36,   0.00, 0.00, 0.00);
CreateDynamicObject(1668, 1478.22, -1362.37, 142.51,   0.00, 0.00, 0.00);
CreateDynamicObject(1668, 1478.59, -1361.31, 142.51,   0.00, 0.00, -33.00);
CreateDynamicObject(1951, 1478.36, -1363.91, 142.53,   0.00, 0.00, 0.00);
CreateDynamicObject(1669, 1478.23, -1366.93, 142.50,   0.00, 0.00, 0.00);
CreateDynamicObject(1669, 1478.27, -1367.05, 142.50,   0.00, 0.00, -91.00);
CreateDynamicObject(1667, 1478.25, -1366.79, 142.44,   0.00, 0.00, 0.00);
CreateDynamicObject(1667, 1478.17, -1366.70, 142.44,   0.00, 0.00, -55.00);
CreateDynamicObject(1667, 1478.12, -1366.79, 142.44,   0.00, 0.00, -11.00);
CreateDynamicObject(1533, 1469.87, -1367.75, 141.22,   0.00, 0.00, 90.00);
CreateDynamicObject(2282, 1470.29, -1364.05, 143.03,   0.00, 0.00, 90.00);
CreateDynamicObject(2281, 1470.28, -1360.84, 143.03,   0.00, 0.00, 90.00);
CreateDynamicObject(2280, 1470.32, -1357.71, 143.08,   0.00, 0.00, 90.00);
CreateDynamicObject(2283, 1469.83, -1354.46, 143.46,   0.00, 0.00, 90.00);

	      //// ћЁ–»я
      //// —тены
  	  SetObjectMaterial(CreateObject(19446, 297.89, 1894.15, 905.08,   0.00, 0.00, -45.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 300.37, 1895.19, 905.08,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 309.98, 1895.18, 905.08,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 310.16, 1894.20, 905.08,   0.00, 0.00, 45.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19384, 313.56, 1889.99, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19400, 313.56, 1886.87, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 313.55, 1880.46, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 313.56, 1873.98, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 307.33, 1870.98, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 304.10, 1870.38, 905.08,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 300.75, 1870.98, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
      SetObjectMaterial(CreateObject(19446, 299.23, 1870.99, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 299.24, 1871.00, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
      SetObjectMaterial(CreateObject(19446, 294.58, 1866.25, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 289.76, 1863.04, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 289.76, 1872.62, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19384, 289.76, 1879.03, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 289.75, 1885.34, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19400, 289.76, 1891.72, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19384, 289.75, 1894.91, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 289.76, 1901.34, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 294.58, 1899.61, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	  SetObjectMaterial(CreateObject(19446, 299.32, 1904.40, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 297.67, 1900.39, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
   	  SetObjectMaterial(CreateObject(19384, 304.06, 1900.39, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
   	  SetObjectMaterial(CreateObject(19446, 310.37, 1900.39, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
   	  SetObjectMaterial(CreateObject(19446, 308.92, 1904.37, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 313.66, 1899.62, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 318.46, 1897.95, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19384, 318.46, 1891.55, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 318.45, 1885.16, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19384, 318.45, 1878.75, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
  	  SetObjectMaterial(CreateObject(19446, 318.46, 1872.33, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 318.46, 1862.74, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 313.54, 1866.23, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 308.84, 1871.00, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 308.85, 1871.00, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 294.49, 1874.02, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 294.51, 1883.60, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(2774, 299.99, 1875.00, 908.00,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(2774, 308.07, 1874.98, 908.00,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19384, 294.52, 1889.98, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 321.50, 1888.05, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 318.34, 1884.43, 905.08,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 318.41, 1892.30, 905.08,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
	   SetObjectMaterial(CreateObject(19446, 313.55, 1896.36, 905.08,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19378, 304.00, 1875.72, 911.82,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 313.82, 1866.07, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 294.61, 1866.09, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 284.96, 1872.49, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 281.26, 1877.05, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 284.95, 1881.28, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 286.13, 1886.96, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 284.89, 1890.08, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 283.06, 1893.17, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 284.87, 1897.20, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 323.34, 1896.25, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 325.16, 1895.23, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 325.16, 1885.62, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19354, 321.76, 1886.66, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
 	   SetObjectMaterial(CreateObject(19446, 323.33, 1885.85, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
       CreateDynamicObject(19378, 314.04, 1866.27, 911.82,   0.00, 0.00, 90.00);
       CreateDynamicObject(19378, 292.50, 1866.35, 911.82,   0.00, 0.00, 90.00);
       CreateDynamicObject(19378, 304.17, 1926.58, 911.82,   0.00, 0.00, 90.00);
		//// —тены
SetObjectMaterial(CreateObject(19446, 297.64, 1900.45, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19384, 307.27, 1912.28, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 294.42, 1909.15, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 284.80, 1909.15, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 284.27, 1913.81, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 284.28, 1923.16, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 285.21, 1919.97, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 294.84, 1919.97, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 299.57, 1921.72, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 303.90, 1926.49, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 308.43, 1921.70, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 307.20, 1916.79, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 306.94, 1917.73, 908.53,   0.00, 0.00, -57.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 307.34, 1918.01, 908.53,   0.00, 0.00, -45.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 301.44, 1917.65, 908.53,   0.00, 0.00, 57.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 300.74, 1918.01, 908.53,   0.00, 0.00, 45.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 301.06, 1916.86, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 299.54, 1918.38, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 308.89, 1922.27, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 308.74, 1918.31, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 313.56, 1919.81, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 315.53, 1915.53, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 313.69, 1912.29, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 308.67, 1910.68, 908.53,   0.00, 0.00, 8.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 299.51, 1910.67, 908.53,   0.00, 0.00, -8.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 299.31, 1910.79, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19384, 300.94, 1912.30, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 302.61, 1915.35, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 302.62, 1912.15, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 305.64, 1915.29, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19354, 305.65, 1912.15, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19384, 304.13, 1916.87, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19384, 304.14, 1910.62, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 308.88, 1905.14, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 299.41, 1905.24, 908.53,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 310.42, 1900.47, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19446, 297.64, 1900.45, 908.53,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19384, 304.04, 1900.46, 908.54,   0.00, 0.00, 90.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(2774, 308.07, 1874.98, 908.00,   0.00, 0.00, 0.00),1, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(2774, 299.99, 1875.00, 908.00,   0.00, 0.00, 0.00),1, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19378, 289.19, 1914.08, 902.23,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);
SetObjectMaterial(CreateObject(19378, 289.19, 1923.70, 902.23,   0.00, 0.00, 0.00),0, 14606, "mafiacasino01", "cof_wood1", 0);

////ѕот
SetObjectMaterial(CreateObject(19378, 304.00, 1870.53, 906.66,   0.00, 90.00, 90.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(6959, 274.65, 1879.71, 910.13,   0.00, 180.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(6959, 315.99, 1879.73, 910.13,   0.00, 180.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(6959, 334.23, 1904.38, 906.59,   0.00, 180.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(6959, 304.45, 1919.70, 910.13,   0.00, 180.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(6959, 273.87, 1886.82, 905.78,   0.00, 180.00, 0.00),0, 18029, "genintintsmallrest", "GB_restaursmll06", 0);
SetObjectMaterial(CreateObject(19446, 284.87, 1897.20, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 283.06, 1893.17, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 284.89, 1890.08, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 286.13, 1886.96, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 323.34, 1871.25, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 327.61, 1876.10, 908.53,   0.00, 0.00, 0.00),0, 13007, "sw_bankint", "bank_wall1", 0);
SetObjectMaterial(CreateObject(19446, 323.20, 1880.88, 908.53,   0.00, 0.00, 90.00),0, 13007, "sw_bankint", "bank_wall1", 0);

////ѕол
SetObjectMaterial(CreateObject(19379, 299.24, 1895.31, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 308.87, 1895.37, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 299.24, 1884.88, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 308.87, 1884.88, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 308.87, 1874.38, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 299.24, 1874.39, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);
SetObjectMaterial(CreateObject(19379, 318.50, 1887.55, 903.29,   0.00, 90.00, 90.00),0, 14425, "madbedrooms", "AH_flroortile12", 0);

////Ћестницы
SetObjectMaterial(CreateObject(14409, 310.88, 1872.75, 903.68,   0.00, 0.00, 0.00),1, 13007, "sw_bankint", "beige_64", 0);
SetObjectMaterial(CreateObject(14409, 314.97, 1872.75, 903.68,   0.00, 0.00, 0.00),1, 13007, "sw_bankint", "beige_64", 0);
SetObjectMaterial(CreateObject(14409, 297.13, 1872.79, 903.68,   0.00, 0.00, 0.00),1, 13007, "sw_bankint", "beige_64", 0);
SetObjectMaterial(CreateObject(14409, 293.03, 1872.79, 903.68,   0.00, 0.00, 0.00),1, 13007, "sw_bankint", "beige_64", 0);

////ќбьекты
CreateObject(19378, 313.99, 1865.72, 911.82,   0.00, 0.00, 90.00);
CreateObject(19378, 292.65, 1865.81, 911.82,   0.00, 0.00, 90.00);
CreateObject(19378, 304.19, 1926.85, 911.82,   0.00, 0.00, 90.00);
CreateObject(1569, 294.62, 1884.92, 903.36,   0.00, 0.00, 90.00);
CreateObject(1569, 327.53, 1877.95, 906.88,   0.00, 0.00, 90.00);
CreateObject(3850, 313.62, 1872.73, 907.38,   0.00, 0.00, 0.00);
CreateObject(13007, 304.08, 1866.42, 901.25,   0.00, 0.00, 90.00);
CreateObject(19379, 289.75, 1876.15, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 294.48, 1865.66, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 304.05, 1863.90, 903.29,   0.00, 90.00, 90.00);
CreateObject(19379, 313.56, 1865.64, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 318.39, 1876.13, 906.81,   0.00, 90.00, 90.00);
CreateObject(3850, 313.62, 1876.17, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 313.62, 1879.64, 907.38,   0.00, 0.00, 0.00);
CreateObject(19379, 318.38, 1886.63, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 318.40, 1897.13, 906.81,   0.00, 90.00, 90.00);
CreateObject(3850, 313.63, 1883.07, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 313.62, 1886.54, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 313.64, 1889.99, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 313.63, 1893.45, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 311.88, 1895.23, 907.38,   0.00, 0.00, 90.00);
CreateObject(3850, 308.41, 1895.23, 907.38,   0.00, 0.00, 90.00);
CreateObject(3850, 304.95, 1895.24, 907.38,   0.00, 0.00, 90.00);
CreateObject(3850, 301.49, 1895.25, 907.38,   0.00, 0.00, 90.00);
CreateObject(3850, 298.02, 1895.25, 907.38,   0.00, 0.00, 90.00);
CreateObject(3850, 296.32, 1895.24, 907.38,   0.00, 0.00, 90.00);
CreateObject(19379, 289.73, 1897.14, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 289.73, 1886.64, 906.81,   0.00, 90.00, 90.00);
CreateObject(3850, 294.61, 1893.51, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.60, 1890.06, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.63, 1886.64, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.65, 1883.21, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.65, 1879.80, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.64, 1876.41, 907.38,   0.00, 0.00, 0.00);
CreateObject(3850, 294.62, 1872.95, 907.38,   0.00, 0.00, 0.00);
CreateObject(19378, 304.00, 1875.72, 911.82,   0.00, 0.00, 90.00);
CreateObject(632, 300.85, 1876.76, 903.77,   0.00, 0.00, 0.00);
CreateObject(632, 308.97, 1876.61, 903.77,   0.00, 0.00, 0.00);
CreateObject(2614, 304.05, 1875.86, 908.41,   0.00, 0.00, 180.00);
CreateObject(18092, 304.00, 1875.19, 903.81,   0.00, 0.00, 0.00);
CreateObject(2310, 304.84, 1876.63, 903.86,   0.00, 0.00, 24.00);
CreateObject(2310, 303.13, 1876.68, 903.86,   0.00, 0.00, -200.00);
CreateObject(2059, 305.68, 1875.56, 904.32,   0.00, 0.00, 0.00);
CreateObject(14487, 304.30, 1888.10, 910.12,   0.00, 0.00, 0.00);
CreateObject(2824, 302.26, 1875.24, 904.31,   0.00, 0.00, 0.00);
CreateObject(2894, 303.97, 1875.46, 904.31,   0.00, 0.00, 0.00);
CreateObject(2608, 305.47, 1870.67, 905.30,   0.00, 0.00, 180.00);
CreateObject(1723, 306.39, 1870.86, 903.33,   0.00, 0.00, 180.00);
CreateObject(2605, 302.17, 1871.09, 903.78,   0.00, 0.00, 180.00);
CreateObject(1714, 303.96, 1873.87, 903.41,   0.00, 0.00, -185.00);
CreateObject(1714, 302.12, 1872.44, 903.41,   0.00, 0.00, 0.00);
CreateObject(19379, 289.61, 1891.21, 903.29,   0.00, 90.00, 90.00);
CreateObject(1723, 317.91, 1885.98, 906.75,   0.00, 0.00, -90.00);
CreateObject(19466, 313.58, 1886.74, 905.31,   0.00, 0.00, 0.00);
CreateObject(1723, 317.14, 1891.67, 903.35,   0.00, 0.00, 0.00);
CreateObject(1723, 319.46, 1885.04, 903.37,   0.00, 0.00, 180.00);
CreateObject(632, 312.78, 1893.59, 907.18,   0.00, 0.00, 0.00);
CreateObject(1724, 316.72, 1885.06, 903.38,   0.00, 0.00, 180.00);
CreateObject(1808, 314.55, 1884.74, 903.38,   0.00, 0.00, 180.00);
CreateObject(2315, 318.65, 1887.57, 903.38,   0.00, 0.00, 90.00);
CreateObject(2852, 318.42, 1888.37, 903.87,   0.00, 0.00, 0.00);
CreateObject(2315, 317.69, 1887.57, 903.38,   0.00, 0.00, 90.00);
CreateObject(2854, 317.80, 1889.09, 903.87,   0.00, 0.00, 0.00);
CreateObject(2813, 317.60, 1887.58, 903.87,   0.00, 0.00, 0.00);
CreateObject(1502, 294.56, 1889.23, 903.38,   0.00, 0.00, 90.00);
CreateObject(1502, 313.57, 1889.26, 903.38,   0.00, 0.00, 90.00);
CreateObject(2854, 317.82, 1888.08, 903.45,   0.00, 0.00, -28.00);
CreateObject(19379, 294.42, 1897.46, 906.80,   0.00, 90.00, 45.00);
CreateObject(19379, 313.97, 1897.98, 906.80,   0.00, 90.00, 45.00);
CreateObject(2240, 320.37, 1886.03, 903.91,   0.00, 0.00, 0.00);
CreateObject(2240, 320.23, 1890.72, 903.91,   0.00, 0.00, 0.00);
CreateObject(632, 296.87, 1893.58, 907.18,   0.00, 0.00, 0.00);
CreateObject(2257, 321.35, 1888.47, 905.35,   0.00, 0.00, -90.00);
CreateObject(19379, 304.08, 1907.43, 906.81,   0.00, 90.00, 90.00);
CreateObject(19462, 299.36, 1896.96, 906.82,   0.00, 90.00, 90.00);
CreateObject(19462, 299.33, 1900.46, 906.82,   0.00, 90.00, 90.00);
CreateObject(19462, 308.99, 1896.94, 906.82,   0.00, 90.00, 90.00);
CreateObject(19462, 308.96, 1900.44, 906.82,   0.00, 90.00, 90.00);
CreateObject(19461, 284.97, 1889.79, 905.05,   0.00, 0.00, 0.00);
CreateObject(19461, 289.65, 1894.40, 905.05,   0.00, 0.00, 90.00);
CreateObject(19461, 289.65, 1887.88, 905.05,   0.00, 0.00, 90.00);
CreateObject(19461, 294.42, 1895.52, 905.05,   0.00, 0.00, 0.00);
CreateObject(19461, 294.39, 1884.54, 905.05,   0.00, 0.00, 0.00);
CreateObject(2514, 292.83, 1893.74, 903.45,   0.00, 0.00, 0.00);
CreateObject(2742, 292.82, 1888.09, 904.41,   0.00, 0.00, 180.00);
CreateObject(1523, 292.02, 1892.03, 903.28,   0.00, 0.00, 0.00);
CreateObject(19397, 292.80, 1892.07, 905.05,   0.00, 0.00, 90.00);
CreateObject(19461, 291.28, 1896.85, 905.05,   0.00, 0.00, 0.00);
CreateObject(19397, 289.66, 1892.07, 905.05,   0.00, 0.00, 90.00);
CreateObject(1523, 288.86, 1892.01, 903.28,   0.00, 0.00, 0.00);
CreateObject(1523, 285.67, 1891.99, 903.28,   0.00, 0.00, 0.00);
CreateObject(19397, 286.47, 1892.05, 905.05,   0.00, 0.00, 90.00);
CreateObject(2514, 289.90, 1893.71, 903.45,   0.00, 0.00, 0.00);
CreateObject(19461, 288.06, 1896.94, 905.05,   0.00, 0.00, 0.00);
CreateObject(2514, 286.44, 1893.67, 903.45,   0.00, 0.00, 0.00);
CreateObject(6959, 273.87, 1886.82, 905.84,   0.00, 180.00, 0.00);
CreateObject(2290, 300.02, 1899.87, 906.91,   0.00, 0.00, 0.00);
CreateObject(2739, 292.64, 1888.45, 903.38,   0.00, 0.00, 180.00);
CreateObject(2742, 290.42, 1888.07, 904.41,   0.00, 0.00, 180.00);
CreateObject(2739, 290.27, 1888.43, 903.38,   0.00, 0.00, 180.00);
CreateObject(2739, 287.96, 1888.43, 903.38,   0.00, 0.00, 180.00);
CreateObject(2742, 288.08, 1888.06, 904.41,   0.00, 0.00, 180.00);
CreateObject(2741, 291.40, 1892.88, 904.34,   0.00, 0.00, 90.00);
CreateObject(2741, 288.22, 1892.70, 904.34,   0.00, 0.00, 90.00);
CreateObject(2741, 285.41, 1892.84, 904.34,   0.00, 0.00, 90.00);
CreateObject(2290, 306.21, 1899.90, 906.91,   0.00, 0.00, 0.00);
CreateObject(1502, 303.26, 1900.45, 906.79,   0.00, 0.00, 0.00);
CreateObject(19379, 294.45, 1907.41, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 304.07, 1917.93, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 313.70, 1917.22, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 294.44, 1917.91, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 284.82, 1914.35, 906.81,   0.00, 90.00, 90.00);
CreateObject(19379, 284.81, 1924.85, 906.81,   0.00, 90.00, 90.00);
CreateObject(13007, 280.64, 1916.61, 905.32,   0.00, 0.00, 180.00);
CreateObject(2208, 288.75, 1913.24, 907.30,   0.00, 0.00, 90.00);
CreateObject(1714, 287.09, 1914.61, 907.48,   0.00, 0.00, 84.00);
CreateObject(2894, 288.67, 1914.53, 908.16,   0.00, 0.00, 90.00);
CreateObject(1723, 298.48, 1911.76, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 298.80, 1919.36, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 296.93, 1919.37, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 294.92, 1919.35, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 292.96, 1919.38, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 296.56, 1911.76, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 294.76, 1911.81, 906.77,   0.00, 0.00, -90.00);
CreateObject(1723, 292.84, 1911.75, 906.77,   0.00, 0.00, -90.00);
CreateObject(2208, 286.91, 1909.90, 907.30,   0.00, 0.00, 90.00);
CreateObject(2208, 286.93, 1916.79, 907.30,   0.00, 0.00, 90.00);
CreateObject(2894, 286.86, 1912.14, 908.16,   0.00, 0.00, 90.00);
CreateObject(2894, 286.84, 1910.39, 908.16,   0.00, 0.00, 84.00);
CreateObject(1714, 285.41, 1912.37, 907.48,   0.00, 0.00, 84.00);
CreateObject(1714, 285.46, 1910.71, 907.48,   0.00, 0.00, 84.00);
CreateObject(1714, 285.39, 1917.02, 907.48,   0.00, 0.00, 84.00);
CreateObject(1714, 285.42, 1918.68, 907.48,   0.00, 0.00, 84.00);
CreateObject(2894, 286.90, 1919.07, 908.16,   0.00, 0.00, 90.00);
CreateObject(2894, 286.87, 1917.20, 908.16,   0.00, 0.00, 74.00);
CreateObject(2196, 288.40, 1914.19, 908.16,   0.00, 0.00, 126.00);
CreateObject(2196, 287.52, 1912.05, 908.16,   0.00, 0.00, -105.00);
CreateObject(2196, 286.62, 1909.94, 908.16,   0.00, 0.00, 127.00);
CreateObject(2196, 286.46, 1918.64, 908.16,   0.00, 0.00, 126.00);
CreateObject(2196, 286.51, 1916.84, 908.16,   0.00, 0.00, 127.00);
CreateObject(14762, 284.41, 1914.55, 909.00,   0.00, 0.00, 0.00);
CreateObject(1502, 300.14, 1912.28, 906.78,   0.00, 0.00, 0.00);
CreateObject(2257, 301.02, 1916.66, 908.69,   0.00, 0.00, 0.00);
CreateObject(2257, 307.13, 1916.66, 908.69,   0.00, 0.00, 0.00);
CreateObject(1502, 303.35, 1910.58, 906.79,   0.00, 0.00, 0.00);
CreateObject(1502, 303.35, 1916.84, 906.75,   0.00, 0.00, 0.00);
CreateObject(1502, 306.45, 1912.27, 906.78,   0.00, 0.00, 0.00);
CreateObject(19446, 283.81, 1913.74, 908.53,   0.00, 0.00, 0.00);
CreateObject(19446, 283.76, 1923.22, 908.53,   0.00, 0.00, 0.00);
CreateObject(2290, 299.92, 1901.07, 906.91,   0.00, 0.00, 90.00);
CreateObject(2290, 299.93, 1903.93, 906.91,   0.00, 0.00, 90.00);
CreateObject(2290, 308.37, 1902.95, 906.91,   0.00, 0.00, -90.00);
CreateObject(2290, 308.41, 1905.80, 906.91,   0.00, 0.00, -90.00);
CreateObject(632, 301.01, 1906.98, 907.21,   0.00, 0.00, 0.00);
CreateObject(632, 309.13, 1906.81, 907.21,   0.00, 0.00, 0.00);
CreateObject(19379, 304.38, 1928.43, 906.81,   0.00, 90.00, 90.00);
CreateObject(14487, 304.39, 1871.60, 910.12,   0.00, 0.00, 0.00);
CreateObject(18608, 294.06, 1914.69, 911.41,   0.00, 0.00, 90.00);
CreateObject(1502, 318.47, 1878.00, 906.79,   0.00, 0.00, 90.00);
CreateObject(1502, 318.48, 1890.80, 906.77,   0.00, 0.00, 90.00);
CreateObject(1502, 289.71, 1895.71, 906.80,   0.00, 0.00, -90.00);
CreateObject(1502, 289.80, 1878.27, 906.77,   0.00, 0.00, 90.00);
CreateObject(1723, 320.93, 1889.44, 903.35,   0.00, 0.00, -90.00);
CreateObject(1723, 290.36, 1884.35, 906.75,   0.00, 0.00, 90.00);
CreateObject(2256, 289.89, 1885.38, 908.64,   0.00, 0.00, 90.00);
CreateObject(2256, 318.35, 1885.03, 908.64,   0.00, 0.00, -90.00);
CreateObject(2010, 290.39, 1883.43, 906.86,   0.00, 0.00, 0.00);
CreateObject(2010, 317.84, 1883.07, 906.86,   0.00, 0.00, 0.00);
CreateObject(14762, 315.69, 1866.42, 908.62,   0.00, 0.00, 90.00);
CreateObject(14762, 292.20, 1866.49, 908.62,   0.00, 0.00, 90.00);
CreateObject(1808, 290.15, 1875.94, 906.90,   0.00, 0.00, 90.00);
CreateObject(1808, 318.18, 1875.68, 906.90,   0.00, 0.00, -90.00);
CreateObject(18608, 304.36, 1883.19, 911.23,   0.00, 0.00, 0.00);
CreateObject(2207, 303.16, 1923.30, 906.90,   0.00, 0.00, 0.00);
CreateObject(1714, 304.24, 1925.43, 906.95,   0.00, 0.00, 0.00);
CreateObject(14740, 306.08, 1926.35, 909.01,   0.00, 0.00, -90.00);
CreateObject(2894, 303.65, 1923.51, 907.66,   0.00, 0.00, -26.00);
CreateObject(2271, 304.07, 1925.92, 908.54,   0.00, 0.00, 0.00);
CreateObject(1723, 307.73, 1921.70, 906.85,   0.00, 0.00, -90.00);
CreateObject(2164, 308.33, 1923.75, 906.90,   0.00, 0.00, -90.00);
CreateObject(2164, 308.34, 1925.53, 906.90,   0.00, 0.00, -90.00);
CreateObject(1723, 300.25, 1919.66, 906.83,   0.00, 0.00, 90.00);
CreateObject(2164, 299.74, 1922.84, 906.90,   0.00, 0.00, 90.00);
CreateObject(2200, 299.71, 1924.59, 906.90,   0.00, 0.00, 90.00);
CreateObject(1811, 305.13, 1922.06, 907.39,   0.00, 0.00, -58.00);
CreateObject(1811, 303.28, 1922.02, 907.39,   0.00, 0.00, -120.00);
CreateObject(2833, 307.45, 1920.18, 906.90,   0.00, 0.00, 90.00);
CreateObject(2833, 301.51, 1920.24, 906.90,   0.00, 0.00, 90.00);
CreateObject(2010, 300.41, 1918.86, 906.87,   0.00, 0.00, 0.00);
CreateObject(2010, 307.47, 1918.86, 906.87,   0.00, 0.00, 0.00);
CreateObject(2278, 307.86, 1920.68, 908.66,   0.00, 0.00, -90.00);
CreateObject(2280, 300.17, 1920.75, 908.65,   0.00, 0.00, 90.00);
CreateObject(14762, 306.07, 1926.38, 908.73,   0.00, 0.00, -90.00);
CreateObject(2267, 313.39, 1880.88, 905.45,   0.00, 0.00, -90.00);
CreateObject(2286, 294.63, 1881.28, 905.63,   0.00, 0.00, 90.00);
CreateObject(2264, 297.36, 1892.65, 905.20,   0.00, 0.00, 45.00);
CreateObject(2262, 310.80, 1892.76, 905.15,   0.00, 0.00, -45.00);
CreateObject(2282, 301.03, 1899.75, 908.84,   0.00, 0.00, 0.00);
CreateObject(2281, 307.22, 1899.80, 908.71,   0.00, 0.00, 0.00);
CreateObject(2684, 306.24, 1917.46, 908.74,   0.00, 0.00, 34.00);
CreateObject(1723, 309.33, 1917.19, 906.90,   0.00, 0.00, 90.00);
CreateObject(14762, 315.35, 1917.95, 908.70,   0.00, 0.00, 180.00);
CreateObject(2205, 313.38, 1915.35, 906.90,   0.00, 0.00, 90.00);
CreateObject(2200, 314.98, 1912.56, 906.90,   0.00, 0.00, 180.00);
CreateObject(2164, 312.64, 1912.44, 906.90,   0.00, 0.00, 180.00);
CreateObject(1714, 315.02, 1916.00, 906.95,   0.00, 0.00, -90.00);
CreateObject(2059, 313.28, 1915.77, 907.85,   0.00, 0.00, 90.00);
CreateObject(2010, 310.69, 1912.77, 906.89,   0.00, 0.00, 0.00);
CreateObject(2007, 314.78, 1919.28, 906.90,   0.00, 0.00, 0.00);
CreateObject(2828, 304.68, 1923.45, 907.67,   0.00, 0.00, 0.00);
CreateObject(2200, 312.47, 1919.72, 906.90,   0.00, 0.00, 0.00);
CreateObject(2004, 303.72, 1926.42, 907.30,   0.00, 0.00, 0.00);
CreateObject(18608, 304.33, 1898.07, 911.23,   0.00, 0.00, 0.00);
CreateObject(2261, 299.91, 1909.70, 908.77,   0.00, 0.00, 90.00);
CreateObject(2260, 308.35, 1909.42, 908.77,   0.00, 0.00, -90.00);
CreateObject(19379, 280.12, 1876.18, 906.81,   0.00, 90.00, 90.00);
CreateObject(2202, 281.82, 1876.89, 906.88,   0.00, 0.00, 90.00);
CreateObject(2200, 289.14, 1872.71, 906.90,   0.00, 0.00, 180.00);
CreateObject(2164, 286.72, 1881.17, 906.89,   0.00, 0.00, 0.00);
CreateObject(2165, 288.14, 1875.16, 906.90,   0.00, 0.00, 0.00);
CreateObject(2165, 289.12, 1876.14, 906.90,   0.00, 0.00, 180.00);
CreateObject(2166, 282.70, 1880.68, 906.90,   0.00, 0.00, -90.00);
CreateObject(2608, 281.58, 1879.58, 908.77,   0.00, 0.00, 90.00);
CreateObject(2165, 282.24, 1874.61, 906.85,   0.00, 0.00, 0.00);
CreateObject(2164, 286.84, 1872.70, 906.89,   0.00, 0.00, 180.00);
CreateObject(2608, 283.03, 1872.81, 908.80,   0.00, 0.00, 180.00);
CreateObject(2894, 283.58, 1879.87, 907.69,   0.00, 0.00, 94.00);
CreateObject(1721, 284.74, 1880.74, 906.90,   0.00, 0.00, 167.00);
CreateObject(1721, 282.19, 1875.84, 906.90,   0.00, 0.00, -105.00);
CreateObject(1671, 288.74, 1877.14, 907.38,   0.00, 0.00, -28.00);
CreateObject(1671, 288.98, 1874.09, 907.38,   0.00, 0.00, 215.00);
CreateObject(1671, 283.01, 1873.51, 907.38,   0.00, 0.00, 185.00);
CreateObject(1671, 282.32, 1879.78, 907.38,   0.00, 0.00, 84.00);
CreateObject(2010, 288.97, 1880.73, 906.85,   0.00, 0.00, 0.00);
CreateObject(19466, 289.77, 1891.79, 908.64,   0.00, 0.00, 0.00);
CreateObject(19379, 280.10, 1895.20, 906.81,   0.00, 90.00, 90.00);
CreateObject(1726, 285.67, 1896.56, 906.84,   0.00, 0.00, 0.00);
CreateObject(2200, 283.23, 1895.33, 906.90,   0.00, 0.00, 90.00);
CreateObject(2010, 288.83, 1896.48, 906.85,   0.00, 0.00, 0.00);
CreateObject(2009, 287.96, 1892.36, 906.90,   0.00, 0.00, 0.00);
CreateObject(2007, 286.80, 1890.62, 906.90,   0.00, 0.00, 180.00);
CreateObject(2200, 289.15, 1890.19, 906.90,   0.00, 0.00, 180.00);
CreateObject(1714, 289.09, 1891.94, 906.88,   0.00, 0.00, -185.00);
CreateObject(2606, 284.67, 1890.20, 909.03,   14.00, 0.00, 180.00);
CreateObject(2165, 285.15, 1890.82, 906.90,   0.00, 0.00, 180.00);
CreateObject(1714, 284.33, 1891.90, 906.88,   0.00, 0.00, 4.00);
CreateObject(19379, 328.01, 1891.00, 906.81,   0.00, 90.00, 90.00);
CreateObject(2604, 320.51, 1893.24, 907.60,   0.00, 0.00, 180.00);
CreateObject(2165, 319.36, 1888.10, 906.90,   0.00, 0.00, 0.00);
CreateObject(2164, 320.42, 1886.02, 906.90,   0.00, 0.00, 180.00);
CreateObject(2164, 323.85, 1886.01, 906.90,   0.00, 0.00, 180.00);
CreateObject(2165, 322.99, 1888.08, 906.90,   0.00, 0.00, 0.00);
CreateObject(1811, 320.28, 1889.17, 907.39,   0.00, 0.00, 0.00);
CreateObject(1811, 323.85, 1889.09, 907.39,   0.00, 0.00, 0.00);
CreateObject(2200, 319.11, 1896.18, 906.88,   0.00, 0.00, 0.00);
CreateObject(2164, 321.35, 1896.16, 906.90,   0.00, 0.00, 0.00);
CreateObject(2202, 323.36, 1895.66, 906.87,   0.00, 0.00, 0.00);
CreateObject(1714, 319.39, 1894.74, 906.90,   0.00, 0.00, 0.00);
CreateObject(1714, 319.96, 1886.79, 906.90,   0.00, 0.00, 180.00);
CreateObject(1714, 323.29, 1886.86, 906.90,   0.00, 0.00, 180.00);
CreateObject(1714, 321.31, 1894.81, 906.90,   0.00, 0.00, 0.00);
CreateObject(2264, 324.57, 1890.73, 908.47,   0.00, 0.00, -90.00);
CreateObject(2164, 325.04, 1893.41, 906.90,   0.00, 0.00, -90.00);
CreateObject(19379, 327.98, 1876.09, 906.81,   0.00, 90.00, 90.00);
CreateObject(14600, 326.92, 1880.67, 908.42,   0.00, 0.00, 90.00);
CreateObject(14632, 332.19, 1868.48, 908.37,   0.00, 0.00, 0.00);
CreateObject(14632, 339.83, 1868.64, 908.37,   0.00, 0.00, 0.00);
CreateObject(2833, 310.63, 1917.75, 906.90,   0.00, 0.00, 90.00);
CreateObject(2167, 309.45, 1912.39, 906.90,   0.00, 0.00, 180.00);
CreateObject(2010, 309.27, 1916.32, 906.89,   0.00, 0.00, 0.00);
CreateObject(1811, 311.92, 1915.00, 907.39,   0.00, 0.00, -127.00);
CreateObject(1811, 312.04, 1916.83, 907.39,   0.00, 0.00, -236.00);
CreateObject(6959, 334.23, 1904.38, 906.59,   0.00, 180.00, 0.00);
CreateObject(1569, 302.56, 1895.01, 903.36,   0.00, 0.00, 0.00);
CreateObject(1569, 305.55, 1895.00, 903.36,   0.00, 0.00, 180.00);

//////////////////

 /////////////////////////////////////////////////////////////////

	//ќтели
	//Ioaee
	CreateObject(19379, 2238.9800, -1165.9700, 28.3300, 0.0000, 90.0000, 0.0000, 50000.0); // object (14)
	CreateObject(19379, 2238.9500, -1175.5900, 28.3300, 0.0000, 90.0000, 0.0000, 50000.0); // object (15)
	CreateObject(19379, 2238.9700, -1185.1801, 28.3300, 0.0000, 90.0000, 0.0000, 50000.0); // object (16)
	CreateObject(5461, 2011.4688, -1300.8984, 28.6953, 0.0000, 0.0000, 0.0000, 50000.0); // object (31)
	CreateObject(1360, 2218.3601, -1144.3320, 25.5150, 0.0000, 0.0000, 344.2500, 50000.0); // object (54)
	CreateObject(982, 2235.6650, -1148.0670, 25.4530, 0.0000, 0.0000, 74.0000, 50000.0); // object (55)
	CreateObject(7597, 2232.7915, -1148.3243, 34.1769, 0.0000, 0.0000, -86.8000, 50000.0); // object (56)
	CreateObject(18762, 2234.1599, -1161.0500, 25.9700, 0.0000, 0.0000, 0.0000, 50000.0); // object (58)
	CreateObject(19121, 2234.0400, -1161.5500, 25.4700, 0.0000, 0.0000, 0.0000, 50000.0); // object (59)
	CreateObject(19325, 2236.0400, -1161.3500, 26.2700, 0.0000, 0.0000, 0.0000, 50000.0); // object (60)
	CreateObject(18762, 2236.1599, -1162.0800, 25.3800, 270.5000, 179.9900, 179.9900, 50000.0); // object (61)
	CreateObject(984, 2207.2571, -1139.4580, 25.3680, 0.0000, 0.0000, 71.2500, 50000.0); // object (62)
	CreateObject(19454, 2241.1899, -1157.1200, 30.1700, 0.0000, 0.0000, 0.0000, 50000.0); // object (63)
	CreateObject(19325, 2233.8899, -1164.5200, 26.4200, 0.0000, 0.0000, 0.0000, 50000.0); // object (64)
	CreateObject(701, 2237.6699, -1162.3000, 26.5200, 0.0000, 0.0000, 0.0000, 50000.0); // object (65)
	CreateObject(19377, 2238.9600, -1161.1200, 27.0800, 271.0000, 0.0000, 89.5000, 50000.0); // object (66)
	CreateObject(19325, 2234.0000, -1164.5000, 31.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (67)
	CreateObject(18762, 2236.1299, -1164.1899, 25.8800, 0.0000, 0.0000, 0.0000, 50000.0); // object (68)
	CreateObject(866, 2239.7700, -1161.2100, 26.0000, 0.0000, 0.0000, 0.0000, 50000.0); // object (69)
	CreateObject(1606, 2238.6799, -1162.4301, 26.5000, 0.0000, 0.0000, 244.0000, 50000.0); // object (70)
	CreateObject(2301, 2237.5801, -1163.3600, 28.4200, 0.0000, 0.0000, 91.5000, 50000.0); // object (71)
	CreateObject(2898, 2239.2800, -1162.4800, 25.8000, 0.0000, 0.0000, 269.2500, 50000.0); // object (72)
	CreateObject(19362, 2235.6001, -1165.0400, 30.1700, 0.0000, 0.0000, 268.9900, 50000.0); // object (73)
	CreateObject(1610, 2240.3799, -1162.3300, 25.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (74)
	CreateObject(18762, 2239.1001, -1164.2000, 25.3600, 270.5000, 179.9900, 89.9900, 50000.0); // object (75)
	CreateObject(19325, 2239.0801, -1164.6600, 26.2200, 0.0000, 0.0000, 270.5000, 50000.0); // object (76)
	CreateObject(1505, 2241.1299, -1162.6600, 28.4200, 0.0000, 0.0000, 89.4900, 50000.0); // object (77)
	CreateObject(19325, 2242.5200, -1161.3800, 26.2700, 0.0000, 0.0000, 0.0000, 50000.0); // object (78)
	CreateObject(18762, 2237.6499, -1165.1200, 30.9200, 0.0000, 0.0000, 0.0000, 50000.0); // object (79)
	CreateObject(18762, 2242.0701, -1162.0200, 25.3800, 270.5000, 179.9900, 179.9900, 50000.0); // object (80)
	CreateObject(2091, 2240.9299, -1163.1200, 28.4200, 0.0000, 0.0000, 270.0000, 50000.0); // object (81)
	CreateObject(1505, 2241.2600, -1162.8400, 28.4200, 0.0000, 0.0000, 89.4900, 50000.0); // object (82)
	CreateObject(9339, 2233.8201, -1168.1500, 25.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (83)
	CreateObject(2132, 2239.6101, -1164.5800, 28.4200, 0.0000, 0.0000, 182.5000, 50000.0); // object (84)
	CreateObject(18762, 2234.1599, -1168.3101, 25.9700, 0.0000, 0.0000, 0.0000, 50000.0); // object (85)
	CreateObject(19379, 2238.8899, -1165.7600, 24.8200, 0.0000, 90.0000, 0.0000, 50000.0); // object (86)
	CreateObject(19325, 2244.1799, -1159.7500, 29.7500, 0.0000, 0.0000, 0.0000, 50000.0); // object (87)
	CreateObject(18762, 2234.1399, -1168.3199, 30.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (88)
	CreateObject(19362, 2239.7100, -1165.1899, 30.1700, 0.0000, 0.0000, 268.9900, 50000.0); // object (89)
	CreateObject(18766, 2236.7600, -1166.6000, 32.7800, 270.0000, 180.0000, 270.0100, 50000.0); // object (90)
	CreateObject(2132, 2239.5701, -1165.7700, 28.4200, 0.0000, 0.0000, 359.2500, 50000.0); // object (91)
	CreateObject(9339, 2233.9099, -1168.9700, 29.1100, 0.0000, 0.0000, 0.0000, 50000.0); // object (92)
	CreateObject(18762, 2242.0500, -1164.2500, 25.9100, 0.0000, 0.0000, 0.0000, 50000.0); // object (93)
	CreateObject(19379, 2238.9600, -1165.9500, 31.7500, 0.0000, 90.0000, 0.0000, 50000.0); // object (94)
	CreateObject(638, 2241.7200, -1164.3199, 29.1200, 0.0000, 0.0000, 180.0000, 50000.0); // object (95)
	CreateObject(19121, 2244.0901, -1162.1200, 25.4700, 0.0000, 0.0000, 0.0000, 50000.0); // object (96)
	CreateObject(19325, 2200.7900, -1151.2000, 26.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (97)
	CreateObject(9339, 2200.6799, -1151.3199, 25.3000, 0.0000, 0.0000, 0.0000, 50000.0); // object (98)
	CreateObject(2811, 2200.3601, -1151.1899, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (99)
	CreateObject(633, 2235.4700, -1169.6700, 25.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (100)
	CreateObject(2845, 2236.6499, -1168.8600, 29.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (101)
	CreateObject(19445, 2199.7900, -1150.6600, 26.3600, 0.0000, 0.0000, 270.2500, 50000.0); // object (102)
	CreateObject(2093, 2238.9299, -1168.1700, 28.4200, 0.0000, 0.0000, 224.0000, 50000.0); // object (103)
	CreateObject(2265, 2199.7200, -1151.2400, 26.9200, 0.0000, 0.0000, 0.0000, 50000.0); // object (104)
	CreateObject(18762, 2234.2100, -1170.3600, 30.8200, 0.0000, 0.0000, 0.0000, 50000.0); // object (105)
	CreateObject(18766, 2246.0300, -1161.6200, 27.3600, 0.0000, 90.0000, 180.0100, 50000.0); // object (106)
	CreateObject(19379, 2200.2600, -1154.9000, 24.5800, 0.0000, 90.0000, 90.0000, 50000.0); // object (107)
	CreateObject(19454, 2241.1899, -1166.7500, 30.1700, 0.0000, 0.0000, 0.0000, 50000.0); // object (108)
	CreateObject(19362, 2236.0400, -1170.5300, 30.1700, 0.0000, 0.0000, 268.9900, 50000.0); // object (109)
	CreateObject(16152, 2199.8501, -1155.3300, 24.4200, 0.0000, 0.0000, 179.7500, 50000.0); // object (110)
	CreateObject(19325, 2200.7900, -1157.8400, 26.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (111)
	CreateObject(19325, 2233.8999, -1172.0699, 26.4000, 0.0000, 0.0000, 0.0000, 50000.0); // object (112)
	CreateObject(2229, 2198.5200, -1150.6400, 24.6600, 0.0000, 0.0000, 2.0000, 50000.0); // object (113)
	CreateObject(1505, 2241.1399, -1168.0400, 28.4200, 0.0000, 0.0000, 89.4900, 50000.0); // object (114)
	CreateObject(1505, 2241.2600, -1168.0500, 28.4200, 0.0000, 0.0000, 89.9900, 50000.0); // object (115)
	CreateObject(2300, 2239.1201, -1169.7300, 28.4200, 0.0000, 0.0000, 90.0000, 50000.0); // object (116)
	CreateObject(19377, 2244.2200, -1165.7600, 23.9900, 0.0000, 0.0000, 0.0000, 50000.0); // object (117)
	CreateObject(18762, 2237.9900, -1170.2100, 30.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (118)
	CreateObject(1817, 2235.6599, -1171.9200, 24.9100, 0.0000, 0.0000, 272.7500, 50000.0); // object (119)
	CreateObject(14651, 2239.9500, -1169.5800, 27.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (120)
	CreateObject(19325, 2233.9199, -1172.1100, 31.0000, 0.0000, 0.0000, 0.0000, 50000.0); // object (121)
	CreateObject(2104, 2197.9399, -1150.7100, 24.6200, 0.0000, 0.0000, 0.0000, 50000.0); // object (122)
	CreateObject(2136, 2238.0000, -1171.0500, 28.4200, 0.0000, 0.0000, 0.0000, 50000.0); // object (123)
	CreateObject(19325, 2244.1799, -1166.3700, 29.7000, 0.0000, 0.0000, 0.0000, 50000.0); // object (124)
	CreateObject(1753, 2234.4700, -1172.8800, 24.9100, 0.0000, 0.0000, 91.0000, 50000.0); // object (125)
	CreateObject(2229, 2197.5500, -1150.7500, 24.6600, 0.0000, 0.0000, 2.0000, 50000.0); // object (126)
	CreateObject(2245, 2236.2300, -1172.4500, 25.7200, 0.0000, 0.0000, 0.0000, 50000.0); // object (127)
	CreateObject(1710, 2243.7600, -1167.7100, 24.9100, 0.0000, 0.0000, 270.0000, 50000.0); // object (128)
	CreateObject(19362, 2239.7200, -1170.5000, 30.1700, 0.0000, 0.0000, 268.9900, 50000.0); // object (129)
	CreateObject(638, 2241.6299, -1169.9200, 29.1200, 0.0000, 0.0000, 179.9900, 50000.0); // object (130)
	CreateObject(2135, 2240.0701, -1171.0699, 28.4200, 0.0000, 0.0000, 0.0000, 50000.0); // object (131)
	CreateObject(18766, 2246.0300, -1166.1500, 28.7200, 270.0000, 180.0000, 270.0100, 50000.0); // object (132)
	CreateObject(2346, 2237.7700, -1172.4800, 28.4200, 0.0000, 0.0000, 270.0000, 50000.0); // object (133)
	CreateObject(18766, 2246.0400, -1166.1500, 31.6800, 270.0000, 180.0000, 270.0000, 50000.0); // object (134)
	CreateObject(1792, 2237.9299, -1172.8400, 28.9100, 0.0000, 0.0000, 270.0000, 50000.0); // object (135)
	CreateObject(633, 2235.4700, -1174.2100, 25.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (136)
	CreateObject(2270, 2195.9600, -1151.3199, 26.3900, 0.0000, 0.0000, 0.0000, 50000.0); // object (137)
	CreateObject(19377, 2195.5500, -1147.2500, 28.1200, 0.0000, 270.0000, 0.0000, 50000.0); // object (138)
	CreateObject(19325, 2200.7900, -1164.4600, 26.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (139)
	CreateObject(18762, 2234.1599, -1175.4000, 25.9700, 0.0000, 0.0000, 0.0000, 50000.0); // object (140)
	CreateObject(18762, 2234.1599, -1175.3500, 30.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (141)
	CreateObject(2298, 2238.0701, -1174.1200, 28.4200, 0.0000, 0.0000, 91.0000, 50000.0); // object (142)
	CreateObject(16152, 2199.8201, -1164.6100, 24.4200, 0.0000, 0.0000, 179.7500, 50000.0); // object (143)
	CreateObject(19379, 2200.2600, -1165.3900, 24.5800, 0.0000, 90.0000, 90.0000, 50000.0); // object (144)
	CreateObject(19377, 2195.5601, -1156.8600, 28.1000, 0.0000, 270.0000, 0.0000, 50000.0); // object (145)
	CreateObject(19362, 2236.1699, -1175.7400, 30.1700, 0.0000, 0.0000, 268.9900, 50000.0); // object (146)
	CreateObject(633, 2235.4700, -1176.4000, 25.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (147)
	CreateObject(19379, 2238.8899, -1175.3900, 24.8200, 0.0000, 90.0000, 0.0000, 50000.0); // object (148)
	CreateObject(1505, 2241.0901, -1174.1400, 28.4200, 0.0000, 0.0000, 88.7400, 50000.0); // object (149)
	CreateObject(18762, 2238.1201, -1175.4500, 30.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (150)
	CreateObject(1505, 2241.2700, -1174.1200, 28.4000, 0.0000, 0.0000, 90.2400, 50000.0); // object (151)
	CreateObject(633, 2243.5500, -1172.9200, 25.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (152)
	CreateObject(2099, 2239.5500, -1175.4700, 28.4200, 0.0000, 0.0000, 178.0000, 50000.0); // object (153)
	CreateObject(2257, 2244.0601, -1172.8700, 26.5900, 0.0000, 0.0000, 269.0000, 50000.0); // object (154)
	CreateObject(19379, 2238.9500, -1175.4900, 31.7400, 0.0000, 90.0000, 0.0000, 50000.0); // object (155)
	CreateObject(18766, 2236.7300, -1176.4700, 32.7600, 270.0000, 180.0000, 270.0100, 50000.0); // object (156)
	CreateObject(1893, 2193.6201, -1155.4700, 28.5600, 0.0000, 0.0000, 269.2500, 50000.0); // object (157)
	CreateObject(19325, 2244.1799, -1172.9700, 29.7700, 0.0000, 0.0000, 0.0000, 50000.0); // object (158)
	CreateObject(19362, 2239.6599, -1175.7400, 30.1700, 0.0000, 0.0000, 269.0000, 50000.0); // object (159)
	CreateObject(2286, 2192.5400, -1150.8400, 27.2900, 0.0000, 0.0000, 354.0000, 50000.0); // object (160)
	CreateObject(9339, 2200.6799, -1168.9000, 25.3200, 0.0000, 0.0000, 0.0000, 50000.0); // object (161)
	CreateObject(19325, 2233.9199, -1178.4800, 26.4000, 0.0000, 0.0000, 0.0000, 50000.0); // object (162)
	CreateObject(19325, 2233.9399, -1178.1100, 31.1400, 0.0000, 0.0000, 0.0000, 50000.0); // object (163)
	CreateObject(16151, 2192.3601, -1151.8101, 24.9600, 0.0000, 0.0000, 91.2500, 50000.0); // object (164)
	CreateObject(2198, 2239.6399, -1176.3000, 28.4200, 0.0000, 0.0000, 359.2500, 50000.0); // object (165)
	CreateObject(1817, 2235.8501, -1178.0800, 24.9100, 0.0000, 0.0000, 272.0000, 50000.0); // object (166)
	CreateObject(2346, 2237.7500, -1177.4000, 28.4200, 0.0000, 0.0000, 270.0000, 50000.0); // object (167)
	CreateObject(2710, 2240.1299, -1176.4700, 29.3300, 0.0000, 0.0000, 0.0000, 50000.0); // object (168)
	CreateObject(1710, 2243.6699, -1174.6500, 24.9100, 0.0000, 0.0000, 270.0000, 50000.0); // object (169)
	CreateObject(1792, 2238.0200, -1177.7900, 28.9100, 0.0000, 0.0000, 270.0000, 50000.0); // object (170)
	CreateObject(2245, 2236.3701, -1178.6100, 25.7200, 0.0000, 0.0000, 0.0000, 50000.0); // object (171)
	CreateObject(19377, 2191.1201, -1147.3800, 28.0900, 0.0000, 270.0000, 0.0000, 50000.0); // object (172)
	CreateObject(19454, 2241.1899, -1176.3600, 30.1700, 0.0000, 0.0000, 0.0000, 50000.0); // object (173)
	CreateObject(1753, 2234.5601, -1179.4600, 24.9100, 0.0000, 0.0000, 92.0000, 50000.0); // object (174)
	CreateObject(638, 2241.6399, -1176.3400, 29.1200, 0.0000, 0.0000, 179.9900, 50000.0); // object (175)
	CreateObject(2299, 2237.5601, -1178.4700, 28.4200, 0.0000, 0.0000, 90.0000, 50000.0); // object (176)
	CreateObject(2120, 2240.2900, -1177.2000, 29.0500, 0.0000, 0.0000, 280.0000, 50000.0); // object (177)
	CreateObject(2366, 2193.0801, -1159.1899, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (178)
	CreateObject(19325, 2200.7900, -1171.0699, 26.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (179)
	CreateObject(19325, 2224.3201, -1181.0900, 26.4000, 0.0000, 0.0000, 270.0000, 50000.0); // object (180)
	CreateObject(1557, 2227.1299, -1181.0500, 24.8800, 0.0000, 0.0000, 0.0000, 50000.0); // object (181)
	CreateObject(19445, 2190.8501, -1150.6899, 26.3600, 0.0000, 0.0000, 270.0000, 50000.0); // object (182)
	CreateObject(19377, 2244.2200, -1175.3800, 23.9900, 0.0000, 0.0000, 0.0000, 50000.0); // object (183)
	CreateObject(19454, 2226.8000, -1181.1300, 30.1600, 0.0000, 0.0000, 90.0000, 50000.0); // object (184)
	CreateObject(1557, 2230.1599, -1181.0500, 24.8900, 0.0000, 0.0000, 179.9900, 50000.0); // object (185)
	CreateObject(19325, 2230.9600, -1181.0900, 26.3900, 0.0000, 0.0000, 270.0000, 50000.0); // object (186)
	CreateObject(19325, 2217.6799, -1181.0900, 26.4000, 0.0000, 0.0000, 270.0000, 50000.0); // object (187)
	CreateObject(19379, 2190.6599, -1154.7600, 24.5800, 0.0000, 90.0000, 90.0000, 50000.0); // object (188)
	CreateObject(638, 2231.8899, -1181.5400, 25.6000, 0.0000, 0.0000, 89.7400, 50000.0); // object (189)
	CreateObject(19454, 2217.2600, -1181.1300, 30.1600, 0.0000, 0.0000, 90.0000, 50000.0); // object (190)
	CreateObject(1893, 2193.5901, -1162.9800, 28.5600, 0.0000, 0.0000, 269.2500, 50000.0); // object (191)
	CreateObject(18762, 2234.4500, -1180.6000, 30.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (192)
	CreateObject(1703, 2198.8601, -1170.7800, 24.6400, 0.0000, 0.0000, 303.0000, 50000.0); // object (193)
	CreateObject(19377, 2195.5701, -1166.4900, 28.1100, 0.0000, 270.0000, 0.0000, 50000.0); // object (194)
	CreateObject(19377, 2191.1101, -1156.9800, 28.0900, 0.0000, 270.0000, 0.0000, 50000.0); // object (195)
	CreateObject(18980, 2228.7900, -1181.5699, 31.8300, 270.2500, 0.0000, 90.0000, 50000.0); // object (196)
	CreateObject(3660, 2217.0300, -1181.8101, 27.1900, 0.0000, 0.0000, 0.0000, 50000.0); // object (197)
	CreateObject(633, 2235.4700, -1181.1400, 25.8800, 0.0000, 0.0000, 0.0000, 50000.0); // object (198)
	CreateObject(19121, 2226.2500, -1182.7400, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (199)
	CreateObject(2253, 2200.3201, -1173.3800, 24.9400, 0.0000, 0.0000, 0.0000, 50000.0); // object (200)
	CreateObject(18766, 2246.0100, -1176.1500, 28.7200, 270.0000, 180.0000, 270.0100, 50000.0); // object (201)
	CreateObject(19121, 2219.1399, -1182.6300, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (202)
	CreateObject(18980, 2234.0100, -1181.5601, 20.6100, 0.0000, 0.0000, 0.0000, 50000.0); // object (203)
	CreateObject(2366, 2193.1399, -1164.2500, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (204)
	CreateObject(19454, 2236.4299, -1181.1300, 30.1700, 0.0000, 0.0000, 90.0000, 50000.0); // object (205)
	CreateObject(2204, 2237.4500, -1180.9800, 28.4200, 0.0000, 0.0000, 179.9900, 50000.0); // object (206)
	CreateObject(2270, 2188.7400, -1151.3700, 26.4100, 0.0000, 0.0000, 0.0000, 50000.0); // object (207)
	CreateObject(1505, 2241.0901, -1179.5500, 28.4200, 0.0000, 0.0000, 88.7400, 50000.0); // object (208)
	CreateObject(18766, 2246.0400, -1176.1300, 31.6800, 270.0000, 180.0000, 270.0000, 50000.0); // object (209)
	CreateObject(1505, 2241.2600, -1179.5601, 28.4200, 0.0000, 0.0000, 89.5000, 50000.0); // object (210)
	CreateObject(1713, 2223.3101, -1183.6200, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (211)
	CreateObject(19325, 2211.0400, -1181.0900, 26.9500, 0.0000, 0.0000, 270.0000, 50000.0); // object (212)
	CreateObject(2110, 2221.1899, -1183.6600, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (213)
	CreateObject(2816, 2221.4199, -1183.7000, 25.7000, 0.0000, 0.0000, 0.0000, 50000.0); // object (214)
	CreateObject(2811, 2200.1299, -1174.3900, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (215)
	CreateObject(321, 2241.1001, -1180.1700, 29.6000, 0.0000, 0.0000, 0.0000, 50000.0); // object (216)
	CreateObject(1713, 2218.4900, -1183.6100, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (217)
	CreateObject(2200, 2239.8101, -1181.0400, 28.3900, 0.0000, 0.0000, 179.9900, 50000.0); // object (218)
	CreateObject(1610, 2234.1599, -1183.0400, 29.2600, 0.0000, 0.0000, 0.0000, 50000.0); // object (219)
	CreateObject(2253, 2200.3201, -1175.2300, 24.9400, 0.0000, 0.0000, 0.0000, 50000.0); // object (220)
	CreateObject(2816, 2217.2200, -1183.6600, 25.7000, 0.0000, 0.0000, 0.0000, 50000.0); // object (221)
	CreateObject(19121, 2213.6699, -1182.7400, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (222)
	CreateObject(2110, 2216.4600, -1183.6899, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (223)
	CreateObject(638, 2239.6799, -1181.5800, 29.1200, 0.0000, 0.0000, 89.7400, 50000.0); // object (224)
	CreateObject(19379, 2200.2600, -1175.6899, 24.5800, 0.0000, 90.0000, 89.9900, 50000.0); // object (225)
	CreateObject(19325, 2233.6499, -1183.6000, 30.4800, 0.0000, 0.0000, 0.0000, 50000.0); // object (226)
	CreateObject(19325, 2244.1799, -1179.5000, 29.8200, 0.0000, 0.0000, 0.0000, 50000.0); // object (227)
	CreateObject(19325, 2234.4500, -1183.6600, 30.2500, 0.0000, 0.0000, 0.0000, 50000.0); // object (228)
	CreateObject(2366, 2193.2000, -1168.3101, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (229)
	CreateObject(633, 2243.4700, -1180.4399, 25.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (230)
	CreateObject(1713, 2213.7300, -1183.5699, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (231)
	CreateObject(1703, 2199.9099, -1176.0200, 24.6400, 0.0000, 0.0000, 242.2500, 50000.0); // object (232)
	CreateObject(2257, 2244.0601, -1180.2300, 26.5700, 0.0000, 0.0000, 269.7400, 50000.0); // object (233)
	CreateObject(1893, 2193.5500, -1168.9100, 28.5600, 0.0000, 0.0000, 269.2500, 50000.0); // object (234)
	CreateObject(1601, 2234.0701, -1184.1000, 29.8700, 0.0000, 0.0000, 8.0000, 50000.0); // object (235)
	CreateObject(1557, 2207.0901, -1181.0400, 24.8900, 0.0000, 0.0000, 180.0000, 50000.0); // object (236)
	CreateObject(19454, 2207.6599, -1181.1100, 30.1400, 0.0000, 0.0000, 90.0000, 50000.0); // object (237)
	CreateObject(18762, 2234.0300, -1184.4301, 28.7700, 270.5000, 180.0000, 180.0000, 50000.0); // object (238)
	CreateObject(1843, 2186.6001, -1152.2600, 24.6100, 0.0000, 0.0000, 89.0000, 50000.0); // object (239)
	CreateObject(2816, 2212.1699, -1183.5699, 25.7000, 0.0000, 0.0000, 0.0000, 50000.0); // object (240)
	CreateObject(19379, 2190.6399, -1165.2200, 24.5800, 0.0000, 90.0000, 90.0000, 50000.0); // object (241)
	CreateObject(19445, 2185.9900, -1147.9500, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (242)
	CreateObject(19377, 2191.2200, -1166.4900, 28.1400, 0.0000, 270.0000, 0.0000, 50000.0); // object (243)
	CreateObject(19377, 2191.2200, -1166.4900, 28.2400, 0.0000, 270.0000, 0.0000, 50000.0); // object (244)
	CreateObject(2110, 2211.4800, -1183.6300, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (245)
	CreateObject(19325, 2200.7900, -1177.6700, 26.7900, 0.0000, 0.0000, 0.0000, 50000.0); // object (246)
	CreateObject(18762, 2234.0200, -1184.4800, 31.8300, 270.5000, 179.9900, 179.9900, 50000.0); // object (247)
	CreateObject(1844, 2186.5500, -1155.2200, 24.6100, 0.0000, 0.0000, 89.0000, 50000.0); // object (248)
	CreateObject(1817, 2236.4500, -1184.4100, 28.4200, 0.0000, 0.0000, 276.0000, 50000.0); // object (249)
	CreateObject(1893, 2186.5300, -1155.2000, 28.5700, 0.0000, 0.0000, 270.0000, 50000.0); // object (250)
	CreateObject(19454, 2199.9399, -1177.1300, 30.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (251)
	CreateObject(19379, 2228.9700, -1186.2700, 24.8200, 0.0000, 90.0000, 269.9900, 50000.0); // object (252)
	CreateObject(19121, 2207.5601, -1182.6500, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (253)
	CreateObject(19379, 2219.3501, -1186.2600, 24.8200, 0.0000, 90.0000, 269.9900, 50000.0); // object (254)
	CreateObject(1991, 2186.5100, -1157.2400, 24.5900, 0.0000, 0.0000, 87.2500, 50000.0); // object (255)
	CreateObject(19173, 2186.1399, -1155.7400, 27.4900, 0.0000, 359.7500, 268.4900, 50000.0); // object (256)
	CreateObject(19325, 2204.4099, -1181.0900, 26.9000, 0.0000, 0.0000, 270.0000, 50000.0); // object (257)
	CreateObject(1557, 2204.0901, -1181.0400, 24.8900, 0.0000, 0.0000, 0.0000, 50000.0); // object (258)
	CreateObject(2813, 2237.0601, -1184.9200, 28.9300, 0.0000, 0.0000, 0.0000, 50000.0); // object (259)
	CreateObject(1710, 2243.7000, -1182.3500, 24.9100, 0.0000, 0.0000, 270.0000, 50000.0); // object (260)
	CreateObject(1713, 2208.4900, -1183.6400, 24.9000, 0.0000, 0.0000, 0.0000, 50000.0); // object (261)
	CreateObject(19445, 2185.9900, -1157.2100, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (262)
	CreateObject(1610, 2234.1799, -1186.0000, 29.2800, 0.0000, 0.0000, 0.0000, 50000.0); // object (263)
	CreateObject(1887, 2186.4700, -1159.2200, 24.6100, 0.0000, 0.0000, 89.7500, 50000.0); // object (264)
	CreateObject(19379, 2228.5000, -1186.7700, 31.7500, 0.0000, 90.0000, 0.0000, 50000.0); // object (265)
	CreateObject(638, 2229.6201, -1187.1300, 25.5900, 0.0000, 0.0000, -90.0000, 50000.0); // object (266)
	CreateObject(19379, 2238.8799, -1185.0100, 24.8200, 0.0000, 90.0000, 0.0000, 50000.0); // object (267)
	CreateObject(2366, 2193.2100, -1172.3199, 24.6600, 0.0000, 0.0000, 0.0000, 50000.0); // object (268)
	CreateObject(1846, 2186.0701, -1159.0000, 23.2100, 0.0000, 0.0000, 0.0000, 50000.0); // object (269)
	CreateObject(19379, 2218.0300, -1186.8600, 31.7700, 0.0000, 90.0000, 0.0000, 50000.0); // object (270)
	CreateObject(18980, 2203.8201, -1181.5500, 31.9400, 270.2500, 0.0000, 90.0000, 50000.0); // object (271)
	CreateObject(19379, 2238.9500, -1185.0699, 31.7500, 0.0000, 90.0000, 0.0000, 50000.0); // object (272)
	CreateObject(2253, 2200.2900, -1179.7900, 24.9400, 0.0000, 0.0000, 0.0000, 50000.0); // object (273)
	CreateObject(638, 2202.6399, -1181.5000, 25.6000, 0.0000, 0.0000, 89.7400, 50000.0); // object (274)
	CreateObject(2251, 2186.1799, -1161.1100, 25.5000, 0.0000, 0.0000, 0.0000, 50000.0); // object (275)
	CreateObject(639, 2232.4800, -1187.5400, 26.2600, 0.0000, 0.0000, 270.5000, 50000.0); // object (276)
	CreateObject(19377, 2195.5801, -1176.0000, 28.1400, 0.0000, 270.0000, 0.0000, 50000.0); // object (277)
	CreateObject(19454, 2232.2300, -1187.6500, 26.6600, 0.0000, 0.0000, 90.7500, 50000.0); // object (278)
	CreateObject(18762, 2234.0100, -1187.1400, 30.8000, 0.0000, 0.0000, 0.0000, 50000.0); // object (279)
	CreateObject(638, 2235.5100, -1187.1300, 25.5900, 0.0000, 0.0000, 90.0000, 50000.0); // object (280)
	CreateObject(1502, 2241.8201, -1185.3199, 28.4200, 0.0000, 0.0000, 0.0000, 50000.0); // object (281)
	CreateObject(1709, 2236.0300, -1187.3900, 28.4200, 0.0000, 0.0000, 90.5000, 50000.0); // object (282)
	CreateObject(19174, 2186.1101, -1163.2100, 27.0600, 0.0000, 0.0000, 90.0000, 50000.0); // object (283)
	CreateObject(1698, 2200.1599, -1181.0500, 24.6800, 0.0000, 0.0000, 274.0000, 50000.0); // object (284)
	CreateObject(19379, 2209.7100, -1186.2700, 24.8200, 0.0000, 90.0000, 270.0000, 50000.0); // object (285)
	CreateObject(3361, 2230.8899, -1188.7800, 26.3300, 0.0000, 0.0000, 182.0000, 50000.0); // object (286)
	CreateObject(1845, 2187.5000, -1166.6600, 24.6600, 0.0000, 0.0000, 90.0000, 50000.0); // object (287)
	CreateObject(2811, 2219.9199, -1189.0300, 25.6500, 0.0000, 0.0000, 0.0000, 50000.0); // object (288)
	CreateObject(19391, 2242.5701, -1185.3101, 30.1700, 0.0000, 0.0000, 270.0000, 50000.0); // object (289)
	CreateObject(18980, 2200.6899, -1181.4600, 19.9500, 0.0000, 0.0000, 0.0000, 50000.0); // object (290)
	CreateObject(2422, 2218.4500, -1189.1100, 25.6100, 0.0000, 0.0000, 150.0000, 50000.0); // object (291)
	CreateObject(1893, 2193.5000, -1175.7500, 28.5600, 0.0000, 0.0000, 269.2500, 50000.0); // object (292)
	CreateObject(19377, 2244.2200, -1185.0200, 23.9900, 0.0000, 0.0000, 0.0000, 50000.0); // object (293)
	CreateObject(638, 2216.6599, -1188.9500, 25.9700, 0.0000, 0.0000, 89.7400, 50000.0); // object (294)
	CreateObject(18766, 2216.0400, -1189.0200, 23.1500, 0.0000, 0.0000, 0.0000, 50000.0); // object (295)
	CreateObject(19454, 2198.9700, -1181.1300, 30.1500, 0.0000, 0.0000, 90.0000, 50000.0); // object (296)
	CreateObject(19362, 2240.9500, -1186.8101, 30.1700, 0.0000, 0.0000, 179.2400, 50000.0); // object (297)
	CreateObject(2422, 2214.4099, -1188.9301, 25.6500, 0.0000, 0.0000, 149.9900, 50000.0); // object (298)
	CreateObject(19454, 2233.7400, -1189.2700, 23.6000, 270.0000, 0.0000, 360.0000, 50000.0); // object (299)
	CreateObject(2268, 2186.5701, -1167.2100, 26.7600, 0.0000, 0.0000, 90.0000, 50000.0); // object (300)
	CreateObject(638, 2212.8999, -1188.9301, 25.9700, 0.0000, 0.0000, 89.7400, 50000.0); // object (301)
	CreateObject(19445, 2185.9900, -1166.7400, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (302)
	CreateObject(19454, 2232.2700, -1190.0100, 26.6500, 0.0000, 0.0000, 90.7500, 50000.0); // object (303)
	CreateObject(1893, 2186.9500, -1168.4000, 28.5700, 0.0000, 0.0000, 270.0000, 50000.0); // object (304)
	CreateObject(1845, 2187.4900, -1169.6600, 24.6600, 0.0000, 0.0000, 90.0000, 50000.0); // object (305)
	CreateObject(19379, 2207.5801, -1186.7400, 31.8000, 0.0000, 90.0000, 0.0000, 50000.0); // object (306)
	CreateObject(19325, 2244.1799, -1186.1200, 29.9100, 0.0000, 0.0000, 0.0000, 50000.0); // object (307)
	CreateObject(19454, 2237.0601, -1189.2200, 23.5800, 270.7500, 360.0000, 2.7500, 50000.0); // object (308)
	CreateObject(2773, 2207.4900, -1187.5000, 25.4200, 0.0000, 0.0000, 90.0000, 50000.0); // object (309)
	CreateObject(1698, 2196.8601, -1181.2800, 24.6800, 0.0000, 0.0000, 274.0000, 50000.0); // object (310)
	CreateObject(2523, 2241.5500, -1188.0100, 28.4600, 0.0000, 0.0000, 90.0000, 50000.0); // object (311)
	CreateObject(19174, 2224.2700, -1191.4800, 26.7300, 0.0000, 0.0000, 180.0000, 50000.0); // object (312)
	CreateObject(18766, 2246.0100, -1186.0900, 28.7200, 270.0000, 180.0000, 270.0100, 50000.0); // object (313)
	CreateObject(19377, 2191.2300, -1176.0200, 28.1900, 0.0000, 270.0000, 0.0000, 50000.0); // object (314)
	CreateObject(2773, 2208.8301, -1188.5300, 25.4200, 0.0000, 0.0000, 0.0000, 50000.0); // object (315)
	CreateObject(18980, 2233.8201, -1190.2700, 19.6500, 0.0000, 0.0000, 0.0000, 50000.0); // object (316)
	CreateObject(19379, 2190.6699, -1175.7300, 24.5800, 0.0000, 90.0000, 89.9900, 50000.0); // object (317)
	CreateObject(19377, 2228.1201, -1191.5699, 27.2600, 270.5000, 179.9900, 269.9900, 50000.0); // object (318)
	CreateObject(3920, 2227.3000, -1191.4800, 30.6200, 0.0000, 0.0000, 0.0000, 50000.0); // object (319)
	CreateObject(18766, 2246.0400, -1186.1000, 31.6800, 270.0000, 180.0000, 270.0100, 50000.0); // object (320)
	CreateObject(14455, 2238.4700, -1189.7500, 26.5800, 0.0000, 0.0000, 0.0000, 50000.0); // object (321)
	CreateObject(2164, 2218.7200, -1191.4301, 24.9000, 0.0000, 0.0000, 179.5000, 50000.0); // object (322)
	CreateObject(19377, 2238.8401, -1189.8400, 27.0800, 270.5000, 179.9900, 270.0000, 50000.0); // object (323)
	CreateObject(2773, 2205.0200, -1187.5000, 25.4200, 0.0000, 0.0000, 90.0000, 50000.0); // object (324)
	CreateObject(2527, 2243.0000, -1188.2800, 28.3600, 0.0000, 0.0000, 181.2500, 50000.0); // object (325)
	CreateObject(2163, 2216.9500, -1191.4399, 24.9000, 0.0000, 0.0000, 180.0000, 50000.0); // object (326)
	CreateObject(19377, 2217.6499, -1191.5699, 27.1800, 270.5000, 179.9900, 269.9900, 50000.0); // object (327)
	CreateObject(2528, 2241.5000, -1189.1400, 28.4200, 0.0000, 0.0000, 89.2500, 50000.0); // object (328)
	CreateObject(2257, 2186.1299, -1170.6600, 27.1000, 0.0000, 0.0000, 90.0000, 50000.0); // object (329)
	CreateObject(18763, 2210.1399, -1190.0200, 24.9800, 0.0000, 0.0000, 0.0000, 50000.0); // object (330)
	CreateObject(7313, 2215.7000, -1191.5000, 28.0800, 0.0000, 0.0000, 180.0000, 50000.0); // object (331)
	CreateObject(18980, 2233.8000, -1191.2500, 19.7600, 0.0000, 0.0000, 0.0000, 50000.0); // object (332)
	CreateObject(19172, 2215.0701, -1191.4500, 26.8300, 0.0000, 0.0000, 180.0000, 50000.0); // object (333)
	CreateObject(18763, 2210.1201, -1190.0200, 29.8300, 0.0000, 0.0000, 0.0000, 50000.0); // object (334)
	CreateObject(1842, 2187.0000, -1172.5601, 25.1300, 0.0000, 0.0000, 270.0000, 50000.0); // object (335)
	CreateObject(2163, 2213.7400, -1191.4000, 24.9000, 0.0000, 0.0000, 179.9900, 50000.0); // object (336)
	CreateObject(3920, 2214.6201, -1191.5601, 30.7200, 0.0000, 0.0000, 0.0000, 50000.0); // object (337)
	CreateObject(19362, 2240.9299, -1189.9399, 30.1700, 0.0000, 0.0000, 179.2400, 50000.0); // object (338)
	CreateObject(1893, 2187.1299, -1173.3900, 28.5700, 0.0000, 0.0000, 270.0000, 50000.0); // object (339)
	CreateObject(638, 2208.2600, -1190.0500, 25.5500, 0.0000, 0.0000, 359.7400, 50000.0); // object (340)
	CreateObject(19377, 2198.5000, -1184.8700, 27.6500, 270.5000, 179.9900, 219.9900, 50000.0); // object (341)
	CreateObject(2773, 2202.4399, -1187.5100, 25.4200, 0.0000, 0.0000, 90.0000, 50000.0); // object (342)
	CreateObject(19121, 2244.1299, -1189.1600, 24.9700, 0.0000, 0.0000, 0.0000, 50000.0); // object (343)
	CreateObject(2854, 2187.4299, -1174.3800, 25.6100, 0.0000, 0.0000, 0.0000, 50000.0); // object (344)
	CreateObject(1984, 2187.4900, -1174.4900, 24.6600, 0.0000, 0.0000, 270.0000, 50000.0); // object (345)
	CreateObject(19379, 2200.0701, -1186.2600, 24.8200, 0.0000, 90.0000, 269.9900, 50000.0); // object (346)
	CreateObject(2855, 2187.6499, -1174.9600, 25.6100, 0.0000, 0.0000, 0.0000, 50000.0); // object (347)
	CreateObject(2898, 2206.7700, -1190.3101, 24.8800, 0.0000, 0.0000, 0.0000, 50000.0); // object (348)
	CreateObject(19454, 2200.0901, -1186.7000, 29.9200, 0.0000, 0.0000, 0.0000, 50000.0); // object (349)
	CreateObject(18762, 2244.3401, -1189.8600, 24.5300, 0.0000, 0.0000, 0.0000, 50000.0); // object (350)
	CreateObject(18762, 2244.3401, -1189.8500, 29.4700, 0.0000, 0.0000, 0.0000, 50000.0); // object (351)
	CreateObject(18766, 2246.0400, -1189.7400, 26.4500, 0.0000, 90.0000, 180.0100, 50000.0); // object (352)
	CreateObject(638, 2206.5901, -1191.0500, 25.5500, 0.0000, 0.0000, 89.7400, 50000.0); // object (353)
	CreateObject(19377, 2207.1699, -1191.5699, 27.1100, 270.5000, 179.9900, 269.9900, 50000.0); // object (354)
	CreateObject(19445, 2190.3999, -1180.8800, 26.4100, 0.0000, 0.0000, 270.0000, 50000.0); // object (355)
	CreateObject(19445, 2185.9900, -1176.2100, 26.3600, 0.0000, 0.0000, 0.0000, 50000.0); // object (356)
	CreateObject(2898, 2202.7000, -1190.3101, 24.8800, 0.0000, 0.0000, 0.0000, 50000.0); // object (357)
	CreateObject(19377, 2194.9299, -1185.4200, 28.2000, 0.0000, 270.0000, 0.0000, 50000.0); // object (358)
	CreateObject(19379, 2197.1001, -1186.7000, 31.7400, 0.0000, 90.0000, 0.0000, 50000.0); // object (359)
	CreateObject(19454, 2201.8601, -1190.5800, 26.8800, 89.7500, 0.0000, 360.0000, 50000.0); // object (360)
	CreateObject(2339, 2186.5901, -1178.3600, 24.6600, 0.0000, 0.0000, 90.0000, 50000.0); // object (361)
	CreateObject(3920, 2201.9900, -1191.4399, 30.7100, 0.0000, 0.0000, 0.0000, 50000.0); // object (362)
	CreateObject(19172, 2186.1101, -1179.3199, 27.1600, 0.0000, 0.0000, 88.7500, 50000.0); // object (363)
	CreateObject(2132, 2186.6001, -1180.3101, 24.6600, 0.0000, 0.0000, 90.0000, 50000.0); // object (364)
	CreateObject(19377, 2196.7800, -1191.5300, 27.0300, 270.5000, 179.9900, 269.9900, 50000.0); // object (365)
	CreateObject(1360, 2165.6140, -1138.0959, 24.9870, 0.0000, 0.0000, 90.9998, 50000.0); // object (366)
	CreateObject(9915, 2196.9800, -1197.4200, 9.0800, 0.0000, 0.0000, 52.5000, 50000.0); // object (367)
	CreateObject(8530, 2165.7971, -1134.2380, 29.2670, 0.0000, 0.0000, 0.0000, 50000.0); // object (368)
	CreateObject(983, 2166.2849, -1131.5670, 25.1060, 0.0000, 0.0000, 359.7473, 50000.0); // object (369)
	CreateObject(982, 2153.6111, -1126.7180, 25.0600, 0.0000, 0.0000, 262.4963, 50000.0); // object (370)
	CreateObject(982, 2152.0420, -1126.5220, 25.0590, 0.0000, 0.0000, 262.5000, 50000.0); // object (371)
	CreateObject(1360, 2164.2749, -1202.2720, 23.7350, 0.0000, 0.0000, 91.0000, 50000.0); // object (372)
	CreateObject(983, 2165.1819, -1207.6600, 23.4770, 0.0000, 0.0000, 359.7500, 50000.0); // object (373)
	CreateObject(956, 2139.5156, -1161.4844, 23.3594, 0.0000, 0.0000, 90.0000, 50000.0); // object (374)
	CreateObject(982, 2152.3149, -1210.8650, 23.6310, 0.0000, 0.0000, 270.0000, 50000.0); // object (375)
	CreateObject(5340, 2313.4661, -1218.0000, 24.7000, 0.0000, 0.0000, 0.0000, 50000.0); // object (376)
	CreateObject(982, 2126.7009, -1210.8621, 23.6460, 0.0000, 0.0000, 270.0000, 50000.0); // object (377)
	CreateObject(956, 2153.2344, -1016.1484, 62.2344, 0.0000, 0.0000, 128.0000, 50000.0); // object (378)
	CreateObject(5340, 2360.9399, -1272.1000, 24.5000, 0.0000, 0.0000, 180.0000, 50000.0); // object (379)
	CreateObject(983, 2056.7000, -1274.2000, 23.3000, 0.0000, 0.0000, 0.2500, 50000.0); // object (380)
	CreateObject(19477, 2019.5262, -1272.7943, 34.2064, 90.0000, 0.0000, 0.0000, 50000.0); // object (381)
	CreateObject(19483, 2019.5300, -1272.9100, 33.5000, 0.0000, 0.0000, 0.0000, 50000.0); // object (382)
	CreateObject(19477, 2019.5292, -1273.0336, 32.7800, 90.0000, 0.0000, 0.0000, 50000.0); // object (383)
	CreateObject(19477, 2019.5292, -1273.0336, 34.2039, 90.0000, 0.0000, 0.0000, 50000.0); // object (384)
	CreateObject(19477, 2018.9204, -1272.7900, 32.7800, 90.0000, 0.0000, 0.0000, 50000.0); // object (385)
	CreateObject(19477, 2018.9204, -1272.7900, 34.2134, 90.0000, 0.0000, 0.0000, 50000.0); // object (386)
	CreateObject(19483, 2018.9100, -1272.9100, 33.5000, 0.0000, 0.0000, 180.0000, 50000.0); // object (387)
	CreateObject(19477, 2018.9211, -1273.0388, 34.2134, 90.0000, 0.0000, 0.0000, 50000.0); // object (388)
	CreateObject(10631, 2006.5000, -1041.5000, 27.8000, 0.0000, 0.0000, 161.0000, 50000.0); // object (389)
	CreateObject(1500, 2002.3000, -1049.5000, 23.8180, 0.0000, 0.0000, 341.2500, 50000.0); // object (390)
	CreateObject(955, 2352.1797, -1357.1563, 23.7734, 0.0000, 0.0000, 90.0000, 50000.0); // object (391)
	CreateObject(1557, 2036.7000, -1316.9000, 24.1000, 0.0000, 0.0000, 270.0000, 50000.0); // object (392)
	CreateObject(983, 2022.7000, -1306.8000, 20.5000, 0.0000, 0.0000, 348.5000, 50000.0); // object (393)
	CreateObject(1557, 2026.5996, -1318.1992, 24.2000, 0.0000, 0.0000, 89.4946, 50000.0); // object (394)
	CreateObject(17951, 2031.5996, -1328.5996, 23.6000, 0.0000, 0.0000, 89.2474, 50000.0); // object (395)
	CreateObject(1522, 1970.2303, -1286.0616, 27.4919, 0.0000, 0.0000, 0.0000, 50000.0); // object (396)
 //// јћћќ by Duke
    CreateObject(16769,782.0999800,-1295.0000000,12.6000000,0.0000000,0.0000000,90.0000000); //object(desn2_ammun04) (1)
    CreateObject(1522,789.5999800,-1298.0000000,12.5000000,0.0000000,0.0000000,90.0000000); //object(gen_doorshop3) (1)
 ////// Int LSPD test
 CreateObject(2957,239.5996100,117.5000000,1003.8000000,0.0000000,0.0000000,90.0000000); //object(chinatgaragedoor) (1)
CreateObject(2957,253.1000100,108.5000000,1003.8000000,0.0000000,0.0000000,90.0000000); //object(chinatgaragedoor) (2)
CreateObject(2957,218.2002000,116.5996100,999.5999800,0.0000000,0.0000000,179.9950000); //object(chinatgaragedoor) (4)
CreateObject(2957,221.3999900,115.9000000,1003.8000000,0.0000000,0.0000000,179.9950000); //object(chinatgaragedoor) (3)
CreateObject(2957,220.0000000,121.2000000,999.5999800,0.0000000,0.0000000,269.9950000); //object(chinatgaragedoor) (4)
CreateObject(1567,233.1000100,119.3000000,1002.2000000,0.0000000,0.0000000,0.0000000); //object(gen_wardrobe) (1)
CreateObject(1555,214.7000000,127.1000000,1002.2000000,0.0000000,0.0000000,0.0000000); //object(gen_doorext17) (1)
CreateObject(4100,246.6000100,119.4000000,1005.1000000,0.0000000,0.0000000,320.0000000); //object(meshfence1_lan) (1)
CreateObject(2957,241.5000000,76.1000000,1005.7000000,0.0000000,0.0000000,270.0000000); //object(chinatgaragedoor) (6)
CreateObject(2957,262.2900100,90.8000000,1001.5000000,0.0000000,0.0000000,270.0000000); //object(chinatgaragedoor) (7)
CreateObject(1567,252.3000000,73.8300000,1002.6000000,0.0000000,0.0000000,270.0000000); //object(gen_wardrobe) (2)
CreateObject(1567,252.3300000,73.8000000,1002.6000000,0.0000000,0.0000000,90.0000000); //object(gen_wardrobe) (3)
	return 1;
}
public housecl() return MoveObject(housegate ,1643.5996094,-1714.9765625,16.1000004,3,0.0000000,0.0000000,0.0000000); // тут название форварда + new + координаты «ј –џ“џ’ ворот!
public Arvorotacl() return MoveObject(arvorota ,-1530.31, 482.44, 7.88,3,0.00, 0.00, 0.00);
public LicClose() return MoveObject(licgate ,-2050.3899, -80.0900, 35.0000-0.004, 0.004,0.0000, 90.0000, 0.0000);
public Armygate() return MoveObject(armygate[0] ,-1545.10, 506.38, 6.94-0.004, 0.004,0.00, 90.00, 84.00);
public Armygate2() return MoveObject(armygate[1] ,-1543.65, 515.57, 6.94-0.004, 0.004, 0.00, 90.00, 84.00);
public PlayerToPoint(Float:radi, playerid, Float:x, Float:y, Float:z)
{
	new Float:oldposx, Float:oldposy, Float:oldposz;
	new Float:tempposx, Float:tempposy, Float:tempposz;
	GetPlayerPos(playerid, oldposx, oldposy, oldposz);
	tempposx = (oldposx -x);
	tempposy = (oldposy -y);
	tempposz = (oldposz -z);
	if (((tempposx < radi) && (tempposx > -radi)) && ((tempposy < radi) && (tempposy > -radi)) && ((tempposz < radi) && (tempposz > -radi))) return true;
	return false;
}
